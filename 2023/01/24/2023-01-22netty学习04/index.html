<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"github",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言前面我们学了Netty的组件及其设计，这次我们深入一下它的各个环节。"><meta property="og:type" content="article"><meta property="og:title" content="Netty学习之初探二"><meta property="og:url" content="https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty%E5%AD%A6%E4%B9%A004/index.html"><meta property="og:site_name" content="Zeus的小窝QAQ"><meta property="og:description" content="前言前面我们学了Netty的组件及其设计，这次我们深入一下它的各个环节。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://github/images/netty4.png"><meta property="og:image" content="https://github/images/netty5.png"><meta property="og:image" content="https://github/images/netty6.png"><meta property="og:image" content="https://github/images/netty7.png"><meta property="og:image" content="https://github/images/netty8.png"><meta property="og:image" content="https://github/images/netty9.png"><meta property="og:image" content="https://github/images/netty10.png"><meta property="og:image" content="https://github/images/netty11.png"><meta property="og:image" content="https://github/images/netty12.png"><meta property="og:image" content="https://github/images/netty13.png"><meta property="og:image" content="https://github/images/netty14.png"><meta property="og:image" content="https://github/images/netty15.png"><meta property="og:image" content="https://github/images/netty16.png"><meta property="article:published_time" content="2023-01-24T03:35:00.000Z"><meta property="article:modified_time" content="2023-08-07T00:18:37.950Z"><meta property="article:author" content="zhuchong"><meta property="article:tag" content="Java"><meta property="article:tag" content="Netty"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://github/images/netty4.png"><link rel="canonical" href="https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty%E5%AD%A6%E4%B9%A004/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Netty学习之初探二 | Zeus的小窝QAQ</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Zeus的小窝QAQ" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Zeus的小窝QAQ</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">55</span></a></li></ul></nav></div></header><div class="reading-progress-bar"></div><a href="https://github.com/zhuchong6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty%E5%AD%A6%E4%B9%A004/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhuchong"><meta itemprop="description" content="世人慌慌张张，不过是图碎银几两； 偏偏这碎银几两，能解世间万种慌张"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zeus的小窝QAQ"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Netty学习之初探二</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-01-24 11:35:00" itemprop="dateCreated datePublished" datetime="2023-01-24T11:35:00+08:00">2023-01-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-08-07 08:18:37" itemprop="dateModified" datetime="2023-08-07T08:18:37+08:00">2023-08-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面我们学了Netty的组件及其设计，这次我们深入一下它的各个环节。</p><span id="more"></span><p>本文代码可以通过这里查看<a target="_blank" rel="noopener" href="https://github.com/zhuchong6/netty-learn">地址</a></p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>channel翻译为传输，我们所说的传输就是数据在网络的流动，一般是以字节形式流动的。但是，用户其实不关心这些细节的，他们只关心他们的字节被可靠的发送和接收。</p><p>在上述代码地址中，有Java API版本的传输的例子，包含NIO和BIO。然后在Netty版本中，我们发现NIO和BIO（Netty叫OIO）的版本如此简洁一致，只需要<strong>EventLoopGroup</strong>和channel传入的方法即可轻松切换；而Java版本的却十分复杂。这就是Netty的优点之一，api一致性。</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p>传输API的核心是Channel接口，它处理所有的IO操作，下面是它的接口层次结构：</p><p><img src="/images/netty4.png" alt="channel接口层次图"></p><p>我们可以看到，每个Channel都会生成一个ChannelPipeline和ChannelConfig。ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实 例，这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑；ChannelConfig包含了该Channel的所有配置设置，并且支持热更新。</p><blockquote><p>ChannelPipeline实现了拦截过滤模式，有点类似Java中拦截器和过滤器的作用，持有的ChannelHandler有以下几个作用：</p><ul><li>将数据从一种格式转换成另一种格式</li><li>提供异常通知</li><li>提供Channel变为active或者非active通知</li><li>提供当 Channel 注册到 EventLoop 或者从 EventLoop 注销时的通知</li><li>提供有关用户自定义事件的通知</li></ul></blockquote><h2 id="内置的Channel"><a href="#内置的Channel" class="headerlink" title="内置的Channel"></a>内置的Channel</h2><p>Netty内置了一些可以开箱即用的Channel，参见下表：</p><p></p><table><thead><tr><th>名称</th><th>包</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>使用java.nio.channels包作为基础——基于 选择器的方式</td></tr><tr><td>Epoll</td><td>io.netty.channel.epoll</td><td>由 JNI 驱动的 epoll()和非阻塞 IO。这个传输支持 只有在 Linux 上可用的多种特性，如 SO_REUSEPORT， 比 NIO 传输更快，而且是完全非阻塞的</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>使用java.net包作为基础——使用阻塞流</td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td>可以在 VM 内部通过管道进行通信的本地传输</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>Embedded 传输，允许使用 ChannelHandler 而又 不需要一个真正的基于网络的传输。这在测试你的 ChannelHandler 实现时非常有用</td></tr></tbody></table><h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><p>之前提到网络数据的基本单位总是字节，Java NIO提供了ByteBuffer作为它的字节容器，但是使用起来极其复杂，难用。因此，Netty实现了自己的数据容器-ByteBuf,一个强大的实现，既解决了 JDK API 的局限性， 又为网络应用程序的开发者提供了更好的 API。</p><h2 id="API介绍-1"><a href="#API介绍-1" class="headerlink" title="API介绍"></a>API介绍</h2><p>Netty数据处理的API主要依赖抽象类ByteBuf和ByteBufHolder接口,它具有以下优点：</p><ul><li>它可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝</li><li>容量可以按需增长(类似于 JDK 的 StringBuilder)</li><li>在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法</li><li>读和写使用了不同的索引</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持池化</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>ByteBuf是一个由不同的索引分别控制读访问和写访问的字节数组。它维护了两个不同的索引，一个用于读，一个用于写。当你从ByteBuf读的时候，它的readerIndex将会递增已被读取的字节数；当你向ByteBuf写入的时候，它的writeIndex也会递增；当readerIndex达到writeIndex的时候，就会达到可读数据的末尾，试图读取超出该点的数据会出发数组越界，抛出异常IndexOutOfBoundsExcetption，下图是ByteBuf的简单结构：</p><p><img src="/images/netty5.png" alt="ByteBuf基础结构"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="堆缓冲区"><a href="#堆缓冲区" class="headerlink" title="堆缓冲区"></a>堆缓冲区</h3><p>最常用的方式是将将数据存储在JVM堆区中，这种模式叫做支撑数组，它能在没有池化的情况下提供快速分配和释放，适合有遗留的数据需要处理的情况，可见代码：</p><pre><code class="java">ByteBuf buf = ...
//检查ByteBuf是否有一个支撑数组
if(buf.hasArray())&#123;
  //如果有获取数组的引用
  byte[] array = buf.array();
  int firstIndex = buf.arrayOffset() + buf.readerIndex(); //计算第一个字节的偏移
  int length = buf.readableBytes();//获取可读字节数
  handleArray(array, firstIndex, length);//使用数组
&#125;
</code></pre><h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p>将数据存储在JVM堆外。这样做的好处在于，如果是在对上分配的数据，那么在发送到Socket之前，JVM会把你的数据复制到堆外的缓存区中，在把这个缓存区发送到Socket里。</p><p>缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵；如果你在处理历史代码的时候，因为数据不是在JVM堆上，你需要进行额外的处理(处理代码如下)。如果说你知道ByteBuf容器中的数据是作为数组来访问的，建议使用</p><pre><code class="java">ByteBuf buf = ...;
//检查ByteBuf是否有一个支撑数组
if(!buf.hasArray())&#123;
  //没有支撑数组，证明是一个直接缓冲区
  int length = buf.readableBytes();//获取可读字节数
  byte[] array = new byte[length];//分配一个新数组来保存堆外数据
  buf.getBytes(buf.readerIndex(), array);//将堆外数据复制到堆内
  handleArray(array, 0, length);//使用数组
&#125;
</code></pre><h3 id="复合缓冲区"><a href="#复合缓冲区" class="headerlink" title="复合缓冲区"></a>复合缓冲区</h3><p>简单来说就是多个ByteBuf聚合在一起，可以根据需要添加或者删除ByteBuf实例，这个功能JDK没有。Netty通过一个ByteBuf子类—-CompositeByteBuf实现这个模式。</p><p>为什么需要这个？</p><p>假设一个消息由头部和主体组成，这两个部分分别由不同程序产生，会在消息被发送的时候组装到一起。问题来了，如果发送多条消息，消息头部一致，只是内容不一样。传统方案处理方式是每发送一条消息就创建一个新的头部和主体的缓冲区，这样就导致了内存的占用。</p><p>使用CompositeByteBuf的话就只需要为主体创建缓冲区，头部复用之前的缓冲区即可，消除了没有必要的复制，并且提供了和ByteBuf一致的API。</p><p>下面代码显示两个处理方式之间的区别：</p><h4 id="使用ByteBuffer"><a href="#使用ByteBuffer" class="headerlink" title="使用ByteBuffer"></a>使用<strong>ByteBuffer</strong></h4><pre><code class="java">// Use an array to hold the message parts
ByteBuffer[] message = new ByteBuffer[] &#123; header, body &#125;;
// Create a new ByteBuffer and use copy to merge the header and body ByteBuffer message2 =
ByteBuffer.allocate(header.remaining() + body.remaining()); message2.put(header);
message2.put(body);
message2.flip();
</code></pre><h4 id="使用CompositeByteBuf"><a href="#使用CompositeByteBuf" class="headerlink" title="使用CompositeByteBuf"></a>使用<strong>CompositeByteBuf</strong></h4><pre><code class="java">CompositeByteBuf messageBuf = Unpooled.compositeBuffer(); 
ByteBuf headerBuf = ...; // can be backing or direct 
ByteBuf bodyBuf = ...; // can be backing or direct 
messageBuf.addComponents(headerBuf, bodyBuf);
  .....
messageBuf.removeComponent(0); // remove the header 
for (ByteBuf buf : messageBuf) &#123;
    System.out.println(buf.toString());
&#125;

//访问 CompositeByteBuf 中的数据
int length = messageBuf.readableBytes();//获得可读字节数
byte[] array = new byte[length];//根据length分配数组
messageBuf.getBytes(compBuf.readerIndex(), array);//将字节读到该数组中去
handleArray(array, 0, array.length);//使用数组
</code></pre><h2 id="字节级操作"><a href="#字节级操作" class="headerlink" title="字节级操作"></a>字节级操作</h2><p>ByteBuf 提供了许多超出基本读、写操作的方法用于修改它的数据，接下来我们研究一下。</p><h3 id="随机访问索引"><a href="#随机访问索引" class="headerlink" title="随机访问索引"></a>随机访问索引</h3><p>ByteBuf索引是从0开始的，最后一个字节的索引总是capacity()-1，所以可以这样遍历：</p><pre><code class="java">ByteBuf buffer = ...;
for (int i = 0; i &lt; buffer.capacity(); i++) &#123;
byte b = buffer.getByte(i); //注意，这里不回改变读写指针的位置
System.out.println((char)b); 
&#125;
</code></pre><h3 id="访问索引顺序"><a href="#访问索引顺序" class="headerlink" title="访问索引顺序"></a>访问索引顺序</h3><p>JDK中的ByteBuffer只有一个索引，这就是为什么它读写的时候需要flip()方法来切换读写模式。对于Nett，ByteBuf有两个索引，更易操作和理解。如图：</p><p><img src="/images/netty6.png" alt="bytebuf内部分段"></p><h3 id="可丢弃字节"><a href="#可丢弃字节" class="headerlink" title="可丢弃字节"></a>可丢弃字节</h3><p>在上图标记的可丢弃字节中，表示已经被读取过的字节。通过调用discardReadBytes()方法，丢弃并回收空间，此时可读部分（content标记）必须移动到缓存区前面，如图：</p><p><img src="/images/netty7.png" alt="可丢弃部分合并"></p><p>所以，建议只有在<strong>真正需要的时候（内存很宝贵的时候）</strong>这样做，因为会导致内存复制影响性能。</p><h3 id="可读字节"><a href="#可读字节" class="headerlink" title="可读字节"></a>可读字节</h3><p>ByteBuf可读字节分段存储了实际数据，默认readerIndex是0，read或者skip开头的方法会检索或者跳过当前readerIndex数据，并且将它增加已读字节数。</p><p>如果read开头的方法（<code>readBytes(ByteBuf byteBuf)</code>）需要一个ByteBuf作为参数，那么此时writeIndex也会增加。</p><p>下面代码展示如何读取所有数据：</p><pre><code class="java">ByteBuf buf = Unpooled.buffer();
while (buf.isReadable())&#123;
        ...
&#125;
</code></pre><h3 id="可写字节"><a href="#可写字节" class="headerlink" title="可写字节"></a>可写字节</h3><p>可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域，默认的writeIndex是0，write开头的方法会从当前的writeIndex开始写数据，并将它增加已写入的字节数。</p><p>如果write开头的方法（<code>writeBytes(ByteBuf dest)</code>）需要传递一个ByteBuf参数，那么此时readIndex也会增加同样大小。</p><p>下面代码展示用随机整数值填充缓冲区，直到它空间不足为止：</p><pre><code class="java">ByteBuf buf = Unpooled.buffer();
//方法返回可写字节数，等效于this.capacity - this.writerIndex
while (buf.writableBytes()&gt;4)&#123;
  buf.writeInt(new Random().nextInt());
&#125;
</code></pre><h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>JDK中InputStream定义了mark(int readlimit)和reset()方法用于将流中的当前位置标记为指定的值，以及将流重置到该位置。</p><p>同样的，ByteBuf可以通过调用 markReaderIndex()、markWriterIndex()、resetWriterIndex() 和 resetReaderIndex()来标记和重置 ByteBuf 的 readerIndex 和 writerIndex。</p><p>也可以通过调用 readerIndex(int)或者 writerIndex(int)来将索引移动到指定位置。试图将任何一个索引设置到一个无效的位置都将导致一个 IndexOutOfBoundsException。</p><p>可以通过调用 clear()方法来将 readerIndex 和 writerIndex 都设置为 0。<strong>注意，这并不会清除内存中的内容</strong></p><p>因此，比discardReadBytes()轻量很多，没有内存复制。</p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>最简单的就是indexOf方法查找，稍微复杂的可以使用<strong>ByteProcessor</strong>。举个例子：</p><pre><code class="java">ByteBuf buf = Unpooled.buffer();
int index = buf.forEachByte(ByteProcessor.FIND_LF);
</code></pre><h3 id="派生缓冲区"><a href="#派生缓冲区" class="headerlink" title="派生缓冲区"></a>派生缓冲区</h3><p>以下几个方法可以创建派生缓冲区：</p><ul><li>duplicate()</li><li>slice()</li><li>slice(int, int)</li><li>Unpooled.unmodifiableBuffer(…)</li><li>order(ByteOrder);</li><li>readSlice(int)</li></ul><p>每个这些方法都将返回一个新的 ByteBuf 实例，它具有自己的读索引、写索引和标记索引。</p><p>其内部存储和 JDK 的 ByteBuffer 一样也是共享的。</p><p>这使得派生缓冲区的创建成本是很低廉的，但是这也意味着，如果你修改了它的内容，也同时修改了其对应的源实例，所以要小心。</p><blockquote><p><strong>ByteBuf</strong> 复制</p><p>如果需要一个现有缓冲区的真实副本，请使用 copy()或者 copy(int, int)方法。不同于派生缓冲区，由这个调用所返回的 ByteBuf 拥有独立的数据副本。</p></blockquote><p>我们来看看派生和复制带案例：</p><pre><code class="java">//派生缓冲区
Charset utf8 = Charset.forName(&quot;UTF-8&quot;);
//创建一个ByteBuf
ByteBuf buf = Unpooled.copiedBuffer(&quot;Netty in Action rocks!&quot;, utf8);
//创建一个切片
ByteBuf sliced = buf.slice(0, 15);
//打印 Netty in Action
System.out.println(sliced.toString(utf8));
//更新原来ByteBuf 索引0位置的字节
buf.setByte(0, (byte)&#39;J&#39;);
//因为数据是共享的，改一个另一个也会改，结果是true
System.out.println(buf.getByte(0) == sliced.getByte(0));
</code></pre><pre><code class="java">//复制
Charset utf8 = Charset.forName(&quot;UTF-8&quot;);
ByteBuf buf = Unpooled.copiedBuffer(&quot;Netty in Action rocks!&quot;, utf8);
//复制一份ByteBuf
ByteBuf copy = buf.copy(0, 15);
//打印 Netty in Action
System.out.println(copy.toString(utf8));
//更新原来ByteBuf 索引0位置的字节
buf.setByte(0, (byte) &#39;J&#39;);
//因为数据不是共享的，改一个另一个不拜年，结果是false
System.out.println(buf.getByte(0) == copy.getByte(0));
</code></pre><h2 id="ByteBufHolder接口"><a href="#ByteBufHolder接口" class="headerlink" title="ByteBufHolder接口"></a>ByteBufHolder接口</h2><p>除了实际数据之外，我们还需要存储各种属性值，HTTP响应便是一个很好的例子，除了表示为字节的内容，还包括状态码、cookie 等。</p><p>为了处理这种常见的用例，Netty 提供了 ByteBufHolder</p><p>ByteBufHolder 只有几种用于访问底层数据和引用计数的方法，见下表：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>content()</td><td>返回由这个 ByteBufHolder 所持有的 ByteBuf</td></tr><tr><td>copy()</td><td>返回这个 ByteBufHolder 的一个深拷贝，包括一个其所包含的 ByteBuf 的非共享拷贝</td></tr><tr><td>duplicate()</td><td>返回这个ByteBufHolder的一个浅拷贝，包括一个其所包含的ByteBuf的共享拷贝</td></tr></tbody></table><h2 id="ByteBuf分配"><a href="#ByteBuf分配" class="headerlink" title="ByteBuf分配"></a>ByteBuf分配</h2><ol><li><p>按需分配：ByteBufAllocator</p><p>为了节省内存分配和释放的压力，Netty通过ByteBufAllocator实现了ByteBuf的池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。下面列出一些api：</p><table><thead><tr><th>名称</th><th align="left">描述</th></tr></thead><tbody><tr><td>buffer()<br>buffer(int initialCapacity);<br>buffer(int initialCapacity, int maxCapacity);</td><td align="left">返回一个基于堆或者直接内存 存储的 ByteBuf</td></tr><tr><td>heapBuffer()<br>heapBuffer(int initialCapacity)<br>heapBuffer(int initialCapacity, int maxCapacity)</td><td align="left">返回一个基于堆内存存储的ByteBuf</td></tr><tr><td>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</td><td align="left">返回一个基于直接内存存储的ByteBuf</td></tr><tr><td>compositeBuffer()<br>compositeBuffer(int maxNumComponents)<br>compositeDirectBuffer()<br>compositeDirectBuffer(int maxNumComponents)<br>compositeHeapBuffer()<br>compositeHeapBuffer(int maxNumComponents)</td><td align="left">返回一个可以通过添加最大到指定数目的基于堆的或者直接内存存储的缓冲区来扩展的 CompositeByteBuf</td></tr><tr><td>ioBuffer()</td><td align="left">返回一个用于套接字的 I&#x2F;O 操 作的 ByteBuf</td></tr></tbody></table><p>Netty提供了两种ByteBufAllocator的实现:<strong>PooledByteBufAllocator</strong>和<strong>UnpooledByteBufAllocator</strong>，前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。</p></li><li><p>Unpooled 缓冲区</p><p>可能某些情况下，你未能获取一个到 ByteBufAllocator 的引用。对于这种情况，Netty 提 供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf 实例。下面是一些api：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer()<br>buffer(int initialCapacity)<br>buffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于堆内存存储的</td></tr><tr><td>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于直接内存存储 的 ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的 ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的 ByteBuf</td></tr></tbody></table><p>Unpooled 类还使得 ByteBuf 同样可用于那些并不需要 Netty 的其他组件的非网络项目， 使得其能得益于高性能的可扩展的缓冲区 API。</p></li><li><p>ByteBufUtil 类</p><p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。因为这个 API 是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。</p><p>这些静态方法中最有价值的可能就是 hexdump()方法，它以十六进制的表示形式打印 ByteBuf 的内容。这在各种情况下都很有用，例如，出于调试的目的记录 ByteBuf 的内容。十六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。</p><p>另一个有用的方法是 boolean equals(ByteBuf, ByteBuf)，它被用来判断两个 ByteBuf 实例的相等性。如果你实现自己的 ByteBuf 子类，你可能会发现 ByteBufUtil 的其他有用方法。</p></li></ol><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</p><p>引用计数背后的想法并不是特别的复杂;它主要涉及跟踪到某个特定对象的活动引用的数量。一个 ReferenceCounted 实现的实例将通常以活动的引用计数为 1 作为开始。只要引用 数大于 0，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。注意， 虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。</p><p>引用释放的代码示例：</p><pre><code class="java">ByteBufAllocator alloc = ByteBufAllocator.DEFAULT;

ByteBuf buf = alloc.directBuffer();
System.out.println(&quot;buf.refCnt() = &quot; + buf.refCnt());//1

//release
buf.release();
System.out.println(&quot;buf.refCnt() = &quot; + buf.refCnt());//0
</code></pre><blockquote><p>谁负责释放</p><p>一般来说，是由最后访问(引用计数)对象的那一方来负责将它释放。</p></blockquote><h1 id="ChannelHandler和ChannelPipeline"><a href="#ChannelHandler和ChannelPipeline" class="headerlink" title="ChannelHandler和ChannelPipeline"></a>ChannelHandler和ChannelPipeline</h1><p>ChannelPipeline中将ChannelHandler连接组织在一起以处理逻辑，以及ChannelHandlerContext的作用。</p><h2 id="ChannelHander家族"><a href="#ChannelHander家族" class="headerlink" title="ChannelHander家族"></a>ChannelHander家族</h2><h3 id="Channel的生命周期"><a href="#Channel的生命周期" class="headerlink" title="Channel的生命周期"></a>Channel的生命周期</h3><p>Channel定义了一组和ChannelInboundHandler API密切相关的简单但是功能强大的状态模型，以下是Channel的这4个状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel 已经被创建，但还未注册到 EventLoop</td></tr><tr><td>ChannelRegistered</td><td>Channel 已经被注册到了 EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel 处于活动状态(已经连接到它的远程节点)。它现在可以接收和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table><p>Channel的正常生命周期如下图所示，当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应。</p><p><img src="/images/netty8.png" alt="channel状态流转"></p><h3 id="ChannelHandler的生命周期"><a href="#ChannelHandler的生命周期" class="headerlink" title="ChannelHandler的生命周期"></a>ChannelHandler的生命周期</h3><p>下表列出了ChannelHandler定义的生命周期操作，在ChannelHandler被添加到ChannelPipeline中或者被从ChannelPipeline中移除会调用这些操作，这些方法都接收一个ChannelHandlerContext参数。</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把 ChannelHandler 添加到 ChannelPipeline 中时被调用</td></tr><tr><td>handlerRemoved</td><td>当从 ChannelPipeline 中移除 ChannelHandler 时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在 ChannelPipeline 中有错误产生时被调用</td></tr></tbody></table><p>Netty定义了下面两个最重要的ChannelHandler接口：</p><ul><li>ChannelInboundHandler—处理入站数据以及各种状态变化</li><li>ChannelOutboundHandler—处理出站数据并且允许拦截所有的操作</li></ul><h3 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h3><p>下表列出ChannelInboundHandler的生命周期方法，这些方法会在数据被接收或者与其对应的Channel状态发生改变时被调用。</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>channelRegistered</td><td>当 Channel 已经注册到它的 EventLoop 并且能够处理 I&#x2F;O 时被调用</td></tr><tr><td>channelUnregistered</td><td>当 Channel 从它的 EventLoop 注销并且无法处理任何 I&#x2F;O 时被调用</td></tr><tr><td>channelActive</td><td>当 Channel 处于活动状态时被调用;Channel 已经连接&#x2F;绑定并且已经就绪</td></tr><tr><td>channelInactive</td><td>当 Channel 离开活动状态并且不再连接它的远程节点时被调用</td></tr><tr><td>channelReadComplete</td><td>当Channel上的一个读操作完成时被调用</td></tr><tr><td>channelRead</td><td>当从 Channel 读取数据时被调用</td></tr><tr><td>ChannelWritabilityChanged</td><td>当Channel的可写状态发生改变时被调用</td></tr><tr><td>userEventTriggered</td><td>当 ChannelnboundHandler.fireUserEventTriggered()方法被调 用时被调用，因为一个 POJO 被传进了 ChannelPipeline</td></tr></tbody></table><p>当某个ChannelInboundHandler的实现重写了channelRead()方法时，它将负责显式地释放与池化ByteBuf实例相关的内存，为此Netty提供了一个实用方法ReferenceCountUtil.release(),代码如下：</p><pre><code class="java">@Sharable
public class DiscardHandler extends ChannelInboundHandlerAdapter &#123;
  @Override
  public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
    ReferenceCountUtil.release(msg); 
  &#125;
&#125;
</code></pre><p>但是以这种方式管理资源可能很繁琐，一个更加简单的方式是使用SimpleChannelInboundHandler，具体代码如下：</p><pre><code class="java">@Sharable
public class SimpleDiscardHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; 
  @Override
  public void channelRead0(ChannelHandlerContext ctx,Object msg) &#123;
          // No need to do anything special
  &#125; 
&#125;
</code></pre><p>由于 SimpleChannelInboundHandler 会自动释放资源，所以你不应该存储指向任何消息的引用供将来使用，因为这些引用都将会失效。</p><h3 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h3><p>ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求，下面显示 ChannelOutboundHandler 本身所定义的方法：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>bind(ChannelHandlerContext,<br>SocketAddress,ChannelPromise)</td><td>当请求将 Channel 绑定到本地地址时被调用</td></tr><tr><td>connect(ChannelHandlerContext, SocketAddress,SocketAddress,ChannelPromise)</td><td>当请求将 Channel 连接到远程节点时被调用</td></tr><tr><td>disconnect(ChannelHandlerContext, ChannelPromise)</td><td>当请求将 Channel 从远程节点断开时被调用</td></tr><tr><td>close(ChannelHandlerContext,ChannelPromise)</td><td>当请求关闭 Channel 时被调用</td></tr><tr><td>deregister(ChannelHandlerContext, ChannelPromise)</td><td>当请求将 Channel 从它的 EventLoop 注销 时被调用</td></tr><tr><td>read(ChannelHandlerContext)</td><td>当请求从 Channel 读取更多的数据时被调用</td></tr><tr><td>flush(ChannelHandlerContext)</td><td>当请求通过 Channel 将入队数据冲刷到远程</td></tr><tr><td>write(ChannelHandlerContext,Object, ChannelPromise)</td><td>当请求通过 Channel 将数据写到远程节点时 被调用</td></tr></tbody></table><blockquote><p><strong>ChannelPromise</strong>与<strong>ChannelFuture</strong></p><p>ChannelOutboundHandler中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。</p><p>ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess()和setFailure()，从而使ChannelFuture不可变 。</p></blockquote><h3 id="ChannelHandler-适配器"><a href="#ChannelHandler-适配器" class="headerlink" title="ChannelHandler 适配器"></a>ChannelHandler 适配器</h3><p>你可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 类作为自己的 ChannelHandler 的起始点。</p><p>这两个适配器分别提供了 ChannelInboundHandler 和 ChannelOutboundHandler 的基本实现。通过扩展抽象类 ChannelHandlerAdapter，它们 获得了它们共同的超接口 ChannelHandler 的方法。</p><p>具体类图如下：</p><p><img src="/images/netty9.png" alt="适配器结构图"></p><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>每一个新创建的 Channel 都将会被分配一个新的 ChannelPipeline。这项关联是永久性 的;Channel 既不能附加另外一个 ChannelPipeline，也不能分离其当前的。在 Netty 组件 的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。</p><p>根据事件的起源，事件将会被 ChannelInboundHandler 或者 ChannelOutboundHandler处理。随后，通过调用 ChannelHandlerContext 实现，它将被转发给同一超类型的下一个ChannelHandler。</p><blockquote><p>ChannelHandlerContext</p><p>ChannelHandlerContext使得ChannelHandler能够和它的ChannelPipeline以及其他的 ChannelHandler 交 互 。 ChannelHandler 可 以 通 知 其 所 属 的 ChannelPipeline 中 的 下 一 个 ChannelHandler，甚至可以动态修改它所属的ChannelPipeline1。</p><p>ChannelHandlerContext 具有丰富的用于处理事件和执行 I&#x2F;O 操作的 API。6.3 节将提供有关 ChannelHandlerContext 的更多内容。</p></blockquote><p>下图是传播流程：</p><p><img src="/images/netty10.png" alt="适配器结构图"></p><p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该 ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p><h3 id="修改ChannelPipeline"><a href="#修改ChannelPipeline" class="headerlink" title="修改ChannelPipeline"></a>修改ChannelPipeline</h3><p>ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改 ChannelPipeline 的布局。(它也可以将它自己从 ChannelPipeline 中移除。)这是 Channel- Handler 最重要的能力之一，所以我们将仔细地来看看它是如何做到的。下表列出了相关方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>addFirstaddBefore<br>addAfteraddLast</td><td>将一个ChannelHandler添加到ChannelPipeline中</td></tr><tr><td>remove</td><td>将一个 ChannelHandler 从 ChannelPipeline 中移除</td></tr><tr><td>replace</td><td>将 ChannelPipeline 中的一个 ChannelHandler 替换为另一个 ChannelHandler</td></tr></tbody></table><blockquote><p><strong>ChannelHandler 的执行和阻塞</strong></p><p>通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop(I&#x2F;O 线程)来处</p><p>理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I&#x2F;O 处理产生负面的影响。</p><p>但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。</p><p>对于这种情况，ChannelPipeline 有一些 接受一个 EventExecutorGroup 的 add()方法。</p><p>如果一个事件被传递给一个自定义的 EventExecutorGroup，它将被包含在这个 EventExecutorGroup 中的某个 EventExecutor 所处理，从而被从该 Channel 本身的 EventLoop 中移除。</p><p>对于这种用例，Netty 提供了一个叫 DefaultEventExecutor- Group 的默认实现。</p></blockquote><h2 id="ChannelHandlerContext接口"><a href="#ChannelHandlerContext接口" class="headerlink" title="ChannelHandlerContext接口"></a>ChannelHandlerContext接口</h2><p>ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关系，每当有ChannelHandler添加到ChannelPipeline中，都会创建ChannelHandlerContext，主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>通过观察api发现，ChannelHandlerContext很多方法，Channel和ChannelPipeline都有，区别就是： <strong>Channel 或者 ChannelPipeline 上的这 些方法，它们将沿着整个 ChannelPipeline 进行传播；ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该 ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler</strong></p><blockquote><p>注意：</p><ul><li>ChannelHandlerContext 和 ChannelHandler 之间的关联(绑定)是永远不会改变的，所以缓存对它的引用是安全的</li><li>相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能</li></ul></blockquote><h3 id="使用ChannelHandlerContext"><a href="#使用ChannelHandlerContext" class="headerlink" title="使用ChannelHandlerContext"></a>使用ChannelHandlerContext</h3><p>先观察图片,可以看出ChannelHandlerContext、ChannelHandler、Channel和ChannelPipeline之间的关系：</p><p><img src="/images/netty11.png" alt="关系图"></p><p>我们看下面一段代码：</p><pre><code class="java">//利用Channel写入缓冲区
ChannelHandlerContext ctx = ..;
Channel channel = ctx.channel();//ctx获取关联的Channel
//channel写入缓冲区
channel.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));


//利用ChannelPipeline写入缓冲区
ChannelHandlerContext ctx = ..;
ChannelPipeline pipeline = ctx.pipeline();//ctx获取关联的ChannelPipeline
//pipeline写入缓冲区
pipeline.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));
</code></pre><p>代码的调用流程图如下所示：</p><p><img src="/images/netty12.png" alt="关系图"></p><blockquote><p>为什么会想要从 ChannelPipeline 中的某个特定点开始传播事件呢?</p><ul><li><p>为了减少将事件传经对它不感兴趣的 ChannelHandler 所带来的开销</p></li><li><p>为了避免将事件传经，那些可能会对它感兴趣的 ChannelHandler</p></li></ul></blockquote><p>如果想要从特定的某个ChannelHandler开始处理问题，必须获取这个handler之前的ChannelHandler，并获取其关联的ChannelHandlerContext，这个ChannelHandlerContext将调用和它所关联的ChannelHandler之后的 ChannelHandler，具体代码和调用流程如下图：</p><pre><code class="java">ChannelHandlerContext ctx = ..;
ctx.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));
</code></pre><p><img src="/images/netty13.png" alt="关系图"></p><h3 id="ChannelHandler和ChannelHandlerContext的高级用法"><a href="#ChannelHandler和ChannelHandlerContext的高级用法" class="headerlink" title="ChannelHandler和ChannelHandlerContext的高级用法"></a>ChannelHandler和ChannelHandlerContext的高级用法</h3><ol><li><p>可以通过ctx的pipeline方法获取ChannelPipeline的引用，可以在运行时操作ChannelHandler，比如可以实现动态的协议切换</p></li><li><p>将ChannelHandlerContext的引用缓存起来，可以在ChannelHandler方法之外，甚至不同线程使用，具体代码可以看下面：</p><pre><code class="java">public class WriteHandler extends ChannelHandlerAdapter &#123;
    private ChannelHandlerContext ctx;
  @Override
  public void handlerAdded(ChannelHandlerContext ctx) &#123;
    this.ctx = ctx;//存储到 ChannelHandlerContext 的引用以供稍后使用
  &#125;
  public void send(String msg) &#123;
      ctx.writeAndFlush(msg);// 使用之前存储的到 ChannelHandlerContext 的引用来发送消息
    &#125;
&#125;
</code></pre><p>由于ChannelHandler可以属于多个ChannelPipeline，所以它会绑定多个ChannelHandlerContext。因此，对于那些希望在多个ChannelPipeline中共享同一个个ChannelHandler的用法，需要使用**@Sharable**注解，具体如下：</p><pre><code class="java">@Sharable
public class SharableHandler extends ChannelInboundHandlerAdapter &#123;
  //这里不要加状态，否则会线程不安全
  @Override
  public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
    System.out.println(&quot;Channel read message: &quot; + msg);
    ctx.fireChannelRead(msg);
  &#125;
&#125;
</code></pre><blockquote><p>为啥要共享一个<strong>ChannelHandler</strong>？</p><p>在多个ChannelPipeline中安装同一个ChannelHandler的一个常见的原因是用于收集跨越多个 Channel 的统计信息。</p></blockquote></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理是程序的重要组成部分，Netty提供了几种方式用于处理入站或者出站过程中发生的异常。</p><h3 id="入站异常处理"><a href="#入站异常处理" class="headerlink" title="入站异常处理"></a>入站异常处理</h3><p>入站的异常遵循以下事实：</p><ol><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline中的下一个 ChannelHandler。</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理。</li><li>要想定义自定义的处理逻辑，你需要重写 exceptionCaught()方法。然后你需要决定是否需要将该异常传播出去。</li></ol><p>具体处理代码如下：</p><pre><code class="java">public class InboundExceptionHandler extends ChannelInboundHandlerAdapter &#123; 
  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;
    cause.printStackTrace();
    ctx.close();
  &#125; 
&#125;
</code></pre><h3 id="出站异常处理"><a href="#出站异常处理" class="headerlink" title="出站异常处理"></a>出站异常处理</h3><p>用于处理出站操作中的正常完成以及异常的选项，都基于以下的通知机制：</p><ol><li>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了</li><li>几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。</li></ol><p>代码如下：</p><pre><code class="java">ChannelFuture future = channel.write(someMessage); 
  future.addListener(new ChannelFutureListener() &#123;
    @Override
    public void operationComplete(ChannelFuture f) &#123;
        if (!f.isSuccess()) &#123; 
        f.cause().printStackTrace();
        f.channel().close();
      &#125;
&#125;); 
</code></pre><pre><code class="java">public class OutboundExceptionHandler extends ChannelOutboundHandlerAdapter &#123; @Override
  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;
    promise.addListener(new ChannelFutureListener() &#123;
      @Override
      public void operationComplete(ChannelFuture f) &#123;
        if (!f.isSuccess()) &#123; 
          f.cause().printStackTrace();
          f.channel().close();
        &#125;
      &#125;); 
    &#125; 
  &#125;
&#125;
</code></pre><h1 id="EventLoop和线程模型"><a href="#EventLoop和线程模型" class="headerlink" title="EventLoop和线程模型"></a>EventLoop和线程模型</h1><p>本节我们探讨下Netty的线程模型，简化应用程序代码，同时最大限度提高性能。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能，与之相应的编程上的构造通常被称为<strong>事件循环</strong>（Netty 使用了 interface io.netty.channel. EventLoop 来适配的术语）。</p><p>可以看下下面的伪代码，理解EventLoop的思想：</p><pre><code class="java">while (!terminated) &#123;
    List&lt;Runnable&gt; readyEvents = blockUntilEventsReady(); 
  for (Runnable ev: readyEvents) &#123;//循环遍历，处理所有的事件
        ev.run(); 
  &#125;
&#125;
</code></pre><p>在这个模型中，一个EventLoop将由一个永远都不会改变的Thread绑定，同时任务 (Runnable 或者 Callable)可以直接提交给EventLoop实现，以立即执行或者调度执行。</p><p>因此，我们可以把EventLoop看作一个包含了Channel的线程。</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>我们需要调度任务延迟执行或者周期性执行，例如：心跳检测就需要周期性执行。</p><p>下面代码展示了EventLoop如何调度任务：</p><ul><li><p>延迟调度</p><pre><code class="java">Channel ch = ...
ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule(new Runnable() &#123;
    @Override
    public void run() &#123;
      System.out.println(&quot;60 seconds later&quot;); 
    &#125;
&#125;, 60, TimeUnit.SECONDS);
</code></pre></li><li><p>周期性调度</p><pre><code class="java">Channel ch = ...
ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(new Runnable() &#123;
    @Override
    public void run() &#123;
      System.out.println(&quot;Run every 60 seconds&quot;); 
    &#125;
&#125;, 60, 60, TimeUnit.Seconds);
</code></pre></li><li><p>取消调度</p><pre><code class="java">ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(...); 
// Some other code that runs...
boolean mayInterruptIfRunning = false; 
future.cancel(mayInterruptIfRunning);
</code></pre></li></ul><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><p><img src="/images/netty14.png" alt="netty线程管理"></p><p>就看当前调度线程和EventLoop绑定的线程是不是一样的，如果一致会立马执行；否则，放入EventLoop的<strong>任务队列（每个EventLoop都有自己的任务队列）</strong>等待下一次调度执行。</p><blockquote><p>注意：</p><p>不要把一个长时间的任务放到任务队列中，会阻塞当前线程；如果必须要进行阻塞调用或者执行长时间的任务，那么请将其放到专门的任务线程池中执行。</p></blockquote><h4 id="线程分配"><a href="#线程分配" class="headerlink" title="线程分配"></a>线程分配</h4><p>分为两种情况，NIO和BIO，具体如图：</p><p><img src="/images/netty15.png" alt="NIO线程分配"></p><p><img src="/images/netty16.png" alt="BIO线程分配"></p><h1 id="自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。"><a href="#自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。" class="headerlink" title="自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。"></a>自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。</h1></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>zhuchong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty%E5%AD%A6%E4%B9%A004/" title="Netty学习之初探二">https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty学习04/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"># Java</a> <a href="/tags/Netty/" rel="tag"># Netty</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/23/2023-01-22netty%E5%AD%A6%E4%B9%A003/" rel="prev" title="Netty学习之初探"><i class="fa fa-chevron-left"></i> Netty学习之初探</a></div><div class="post-nav-item"><a href="/2023/02/08/2023-02-08linux%E5%9F%BA%E7%A1%80/" rel="next" title="linux基础">linux基础 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Channel"><span class="nav-number">2.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#API%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">API介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84Channel"><span class="nav-number">2.2.</span> <span class="nav-text">内置的Channel</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ByteBuf"><span class="nav-number">3.</span> <span class="nav-text">ByteBuf</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#API%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">3.1.</span> <span class="nav-text">API介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.3.1.</span> <span class="nav-text">堆缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.3.2.</span> <span class="nav-text">直接缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.3.3.</span> <span class="nav-text">复合缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ByteBuffer"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">使用ByteBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8CompositeByteBuf"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">使用CompositeByteBuf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.</span> <span class="nav-text">字节级操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">随机访问索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">访问索引顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%B8%A2%E5%BC%83%E5%AD%97%E8%8A%82"><span class="nav-number">3.4.3.</span> <span class="nav-text">可丢弃字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%AF%BB%E5%AD%97%E8%8A%82"><span class="nav-number">3.4.4.</span> <span class="nav-text">可读字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%86%99%E5%AD%97%E8%8A%82"><span class="nav-number">3.4.5.</span> <span class="nav-text">可写字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86"><span class="nav-number">3.4.6.</span> <span class="nav-text">索引管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.7.</span> <span class="nav-text">查找操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.4.8.</span> <span class="nav-text">派生缓冲区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ByteBufHolder%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.5.</span> <span class="nav-text">ByteBufHolder接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ByteBuf%E5%88%86%E9%85%8D"><span class="nav-number">3.6.</span> <span class="nav-text">ByteBuf分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">引用计数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ChannelHandler%E5%92%8CChannelPipeline"><span class="nav-number">4.</span> <span class="nav-text">ChannelHandler和ChannelPipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelHander%E5%AE%B6%E6%97%8F"><span class="nav-number">4.1.</span> <span class="nav-text">ChannelHander家族</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.1.1.</span> <span class="nav-text">Channel的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelHandler%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.1.2.</span> <span class="nav-text">ChannelHandler的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelInboundHandler"><span class="nav-number">4.1.3.</span> <span class="nav-text">ChannelInboundHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelOutboundHandler"><span class="nav-number">4.1.4.</span> <span class="nav-text">ChannelOutboundHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelHandler-%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">4.1.5.</span> <span class="nav-text">ChannelHandler 适配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelPipeline"><span class="nav-number">4.2.</span> <span class="nav-text">ChannelPipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9ChannelPipeline"><span class="nav-number">4.2.1.</span> <span class="nav-text">修改ChannelPipeline</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelHandlerContext%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.</span> <span class="nav-text">ChannelHandlerContext接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ChannelHandlerContext"><span class="nav-number">4.3.1.</span> <span class="nav-text">使用ChannelHandlerContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelHandler%E5%92%8CChannelHandlerContext%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="nav-number">4.3.2.</span> <span class="nav-text">ChannelHandler和ChannelHandlerContext的高级用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E7%AB%99%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">4.4.1.</span> <span class="nav-text">入站异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BA%E7%AB%99%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">4.4.2.</span> <span class="nav-text">出站异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EventLoop%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">EventLoop和线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop"><span class="nav-number">5.0.1.</span> <span class="nav-text">EventLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-number">5.0.2.</span> <span class="nav-text">任务调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">5.0.3.</span> <span class="nav-text">实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">5.0.3.1.</span> <span class="nav-text">线程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D"><span class="nav-number">5.0.3.2.</span> <span class="nav-text">线程分配</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E6%AD%A4%EF%BC%8CNetty%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%88%91%E4%BB%AC%E5%9F%BA%E6%9C%AC%E5%B7%B2%E7%BB%8F%E4%BA%86%E8%A7%A3%E5%AE%8C%E6%AF%95%E3%80%82%E4%B8%8B%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E8%B7%B5%E4%B8%80%E4%B8%8B%E3%80%82"><span class="nav-number">6.</span> <span class="nav-text">自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">zhuchong</p><div class="site-description" itemprop="description">世人慌慌张张，不过是图碎银几两； 偏偏这碎银几两，能解世间万种慌张</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">55</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhuhcong6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhuhcong6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">zhuchong</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,tagMode:!1})</script></body></html>