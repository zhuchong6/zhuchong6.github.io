<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"github",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="引言为什么学习Python？ 换到新公司，遇到几次excel数据清洗的问题，使用java也可以做，但是比较麻烦。再加上这家公司技术栈是混合的，也有python承担一些重要的工作。所以，下决定好好学习下Python。"><meta property="og:type" content="article"><meta property="og:title" content="Python学习"><meta property="og:url" content="https://github/zhuchong6.github.io/2022/09/28/2022-09-28python%E5%AD%A6%E4%B9%A0/index.html"><meta property="og:site_name" content="Zeus的小窝QAQ"><meta property="og:description" content="引言为什么学习Python？ 换到新公司，遇到几次excel数据清洗的问题，使用java也可以做，但是比较麻烦。再加上这家公司技术栈是混合的，也有python承担一些重要的工作。所以，下决定好好学习下Python。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-09-28T09:23:02.000Z"><meta property="article:modified_time" content="2023-08-07T00:18:37.950Z"><meta property="article:author" content="zhuchong"><meta property="article:tag" content="Python"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://github/zhuchong6.github.io/2022/09/28/2022-09-28python%E5%AD%A6%E4%B9%A0/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Python学习 | Zeus的小窝QAQ</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Zeus的小窝QAQ" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Zeus的小窝QAQ</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">55</span></a></li></ul></nav></div></header><div class="reading-progress-bar"></div><a href="https://github.com/zhuchong6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://github/zhuchong6.github.io/2022/09/28/2022-09-28python%E5%AD%A6%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhuchong"><meta itemprop="description" content="世人慌慌张张，不过是图碎银几两； 偏偏这碎银几两，能解世间万种慌张"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zeus的小窝QAQ"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Python学习</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-28 17:23:02" itemprop="dateCreated datePublished" datetime="2022-09-28T17:23:02+08:00">2022-09-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-08-07 08:18:37" itemprop="dateModified" datetime="2023-08-07T08:18:37+08:00">2023-08-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><strong>为什么学习Python？</strong></p><p>换到新公司，遇到几次excel数据清洗的问题，使用java也可以做，但是比较麻烦。再加上这家公司技术栈是混合的，也有python承担一些重要的工作。所以，下决定好好学习下Python。</p><span id="more"></span><p><strong>怎么学？</strong></p><p>这里推荐github上一个项目：<a target="_blank" rel="noopener" href="https://github.com/jackfrued/Python-100-Days">python100</a>，我基本上就是跟着这个项目和<a target="_blank" rel="noopener" href="https://docs.python.org/3.9/tutorial/">官网教程</a>学习的，入门非常合适。</p><p>ok，言归正传，我们开始Python之旅。</p><p>环境：</p><blockquote><p>Python 3.9.6 (default, Aug 5 2022, 15:21:02)</p><p>[Clang 14.0.0 (clang-1400.0.29.102)] on darwin</p></blockquote><h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><h3 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1. 变量类型"></a>1. 变量类型</h3><ul><li><p>整型:<br>Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了，支持二进制(0b100 &#x3D; 4)、八进制(0o100 &#x3D; 64)、十进制(100)和十六进制(0x100 &#x3D; 256)</p></li><li><p>浮点型:<br>也就是我们常说的小数,支持数学写法(11.2)和科学记数法(11.123e2)</p></li><li><p>字符串类型:<br>以单引号、双引号和三引号包括起来的文本(‘字符串1’ or “字符串2” or ‘’’可以换行的字符串’’’)</p></li><li><p>布尔型:<br>布尔值只有True、False两种,注意开头大写</p></li><li><p>复数型:<br>类型<code>3+5j</code>,和数学上复数表示一致，不常用了解即可</p></li></ul><h3 id="2-变量命名"><a href="#2-变量命名" class="headerlink" title="2. 变量命名"></a>2. <strong>变量命名</strong></h3><p>总所周知,命名是一个大问题,变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。</p><ul><li><p>硬性规则:</p><ul><li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头</li><li>大小写敏感（大写的a和小写的A是两个不同的变量）</li><li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突</li></ul></li><li><p>PEP 8要求:</p><ul><li>用小写字母拼写，多个单词用下划线连接。</li><li>受保护的实例属性用单个下划线开头（后面会讲到）</li><li>私有的实例属性用两个下划线开头（后面会讲到）</li></ul></li></ul><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>我们先来看一个简单的demo</p><pre><code class="python">&quot;&quot;&quot;
简单登录

&quot;&quot;&quot;
name = str(input(&#39;请输入用户名：&#39;))
passwprd = str(input(&#39;请输入密码：&#39;))
if name != &#39;zz&#39;:
     print(&#39;用户名不存在&#39;)
elif name == &#39;zz&#39; and passwprd == &#39;123456&#39;: 
     print(&#39;验证成功😁&#39;)   
else:
     print(&quot;密码错误💔&quot;) 
</code></pre><blockquote><p>注意⚠️:</p><p>input()是python的内置函数，作用是从命令行捕获输入的值.</p><p>str()是python的内置函数，作用将值变成字符串</p></blockquote><p>我们可以看到分支结构主要作用是根据条件进入到不同的分支，执行不同的代码。这里需要注意的是，if后面空一个空格才能输入条件，而不是像java一样用括号包裹起来。而且，if下面的print()函数也需要一个在前面至少一个空格才能运行。</p><p>熟悉Java的朋友应该了解，分支结构除了if-elif-else这样的语法之外，还有一个switch语法。Python在<mark>3.10</mark>版本之后正式支持，语法结构如下：</p><pre><code class="python">def http_error(status):
    match status:
        case 400:
            return &quot;Bad request&quot;
        case 404:
            return &quot;Not found&quot;
        case 418:
            return &quot;I&#39;m a teapot&quot;
        case _:
            return &quot;Something&#39;s wrong with the internet&quot;
</code></pre><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><ul><li><p>for 语句</p><pre><code class="python">&#39;&#39;&#39;
基础使用
&#39;&#39;&#39;
words = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]
for w in words:
  print(w)

##print result#
1
2
3  
</code></pre><p>其实还有个for-else语法，其作用是没有遇到任何break的时候会跳到else分支。但是，比较反直觉，一般生产不推荐使用。</p></li><li><p>range() 函数</p><pre><code class="python">&#39;&#39;&#39;
range函数包含三个参数：
start 一开始的值，默认为0
stop 结束的值
step 步长，每次数值递增的值
计算范围是[start, stop)
&#39;&#39;&#39;
sum = 0
#计算1到2之间，每次累积增加1范围内的值
for x in range(1,3,1):
    sum += x
print(sum)
##print result#
3
</code></pre></li><li><p>while循环</p><pre><code class="python">count = 0
while True:
    count += 1
    print( count)
    if count&gt;1:
        break
##print result#
1
2
</code></pre><p>上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认入参值"><a href="#默认入参值" class="headerlink" title="默认入参值"></a>默认入参值</h3><p>在Python中，函数参数可以有默认值，支持使用可变参数，所以不需要像Java一样支持函数的重载，举个例子：</p><pre><code class="python">def calculate(a=0, b=0):
    &#39;&#39;&#39;
    求和
    函数注释一般写在第一行下面，可以生成文档，
    VsCode中鼠标放到方法名上，可以预览注释内容
    &#39;&#39;&#39;
    return a +b

print(calculate())//0
print(calculate(1))//1
print(calculate(1,2))//3
print(calculate(b=2,a=1))//3
</code></pre><h3 id="Keyword-Arguments和Positional-Arguments"><a href="#Keyword-Arguments和Positional-Arguments" class="headerlink" title="Keyword Arguments和Positional Arguments"></a>Keyword Arguments和Positional Arguments</h3><p>这两个定义实在是不知道如何准确的翻译，我就把英语原文搬上来，具体定义如下：</p><ul><li>Keyword Arguments: 函数入参中使用形如<code>param_name = param_value</code>的值参数，在定义参数的时候给定默认值就叫做Keyword Arguments</li><li>Positional Arguments: 函数入参中只有一个参数名称，没有给定默认值的叫做Positional Arguments</li></ul><p>那么，这两种有什么特点呢？看下面<strong>Demo</strong>:</p><pre><code class="python">def test(a,b=&#39;b&#39;,c=&#39;c&#39;,d=&#39;d&#39;):
    print(a)
    print(b)
    print(c)
    print(d)


test() #required argument missing
test(b=3, 1) #non-keyword argument after a keyword argument
test(110, a=220) #duplicate value for the same argument
test(zzz=1231) #unknown keyword argument
</code></pre><p>可以看出，Positional Arguments的参数特点：</p><ul><li>没有初始化，所以必须填值</li><li>顺序很重要，如果顺序不一样，结果也是不一样</li><li>Positional Arguments必须要在Keyword Arguments参数前面</li></ul><p>而Keyword Arguments的参数特点：</p><ul><li>一开始有默认值，所以不一定需要初始化</li><li>因为有参数名指定参数值，所以顺序不重要</li><li>不能传入没有定义的参数</li><li>必须在Positional Arguments后面</li></ul><h3 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h3><p>一般情况下，Positional Arguments和Keyword Arguments并存，为了代码可读性考虑，增加特殊参数区分两者，例子：</p><pre><code class="python">def func(pos1, pos2, /, pos_or_kwd, *, kwd1=11, kwd2=22):
    print(pos1,pos2,pos_or_kwd, kwd1, kwd2)

func(1,2,1) #1 2 1 11 22
</code></pre><p>如上所示，<code>/</code>前代表Positional Arguments Only, <code>*</code>之后代表Keyword Arguments Only，中间部分代表Positional Or Keyword Arguments</p><blockquote><p>来自官网的最佳实践:</p><ul><li>当希望参数对用户不可用的时候使用positional-only,即参数名称没有意义的时候</li><li>对于api来说，使用positional-only可以防止参数名称改变了，对api的破坏性改动</li><li>只有当参数有意义，更便于理解,或者你不想用户依赖参数位置的时候才使用keyword-only</li></ul></blockquote><h3 id="任意参数列表"><a href="#任意参数列表" class="headerlink" title="任意参数列表"></a>任意参数列表</h3><pre><code class="python">def arbitrary_param_fun(*arguments):
    print(arguments)
arbitrary_param_fun(1, 2, 3, 4, 5)  # (1, 2, 3, 4, 5)

def arbitrary_param_fun2(*arguments, name=&quot;s&quot;):
    print(arguments, name)
arbitrary_param_fun2(1, 2, 3, 4, 5)  # (1, 2, 3, 4, 5) s
</code></pre><p>类似<code>Java</code>中的可变参数，只不过这里是以<code>*</code>开头，表示是一个任意的参数列表。</p><p>注意，当任意的参数列表在前面的时候，后面的参数只能是keyword-only形式</p><h3 id="拆包参数列表"><a href="#拆包参数列表" class="headerlink" title="拆包参数列表"></a>拆包参数列表</h3><pre><code class="python">print(list(range(3, 6)) ) #[3, 4, 5]

args = [3,6]
print(list(range(*args)) ) #[3, 4, 5]
</code></pre><p>在参数已经是定义好的元组（tuple）或者列表中，可以以<code>*</code>开头，后面跟着参数变量，当做参数传入</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda表达式就是一个匿名函数，具体如下：</p><pre><code class="python">def lambda_expression_func(n):
    &#39;&#39;&#39;
    返回一个匿名函数
    &#39;&#39;&#39;
    return lambda a: a+n

#f命名这个匿名函数，相当于 
# def f(a):
#   return a+1
f = lambda_expression_func(1);
print(f(0)) #1
print(f(1)) #2
</code></pre><h3 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h3><p>是一种元数据，与用户定义的类型信息相关。<br>注解存储在<code>_annotations_</code>属性中，作为字典，对其他部分没有影响</p><pre><code class="python">def f(a:string,v:string,c:int)-&gt;int:
    print(&quot;Annotation:&quot;, f.__annotations__)
    print(1111)
f(1,2,3) 
# Annotation: &#123;&#39;a&#39;: &lt;module &#39;string&#39; from &#39;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/string.py&#39;&gt;, &#39;v&#39;: &lt;module &#39;string&#39; from &#39;/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/string.py&#39;&gt;, &#39;c&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;int&#39;&gt;&#125;
# 1111
</code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="List详解"><a href="#List详解" class="headerlink" title="List详解"></a>List详解</h3><ul><li>list.append(x):在列表尾部添加一个元素，和<code>a[len(a):] = x</code>等价</li><li>list.extend(iterable):传入一个可以迭代的结构，列表或者字符串，然后附加到列表尾部</li><li>list.insert(i, x):在i这个位置插入x，其他数据后移。所以，a.insert(0,x)在列表最前面添加，a.insert(len(a),x)等价于list.append(x)</li><li>list.remove(x):从列表中删除其值等于x的第一项。如果没有这样的项，则会引发ValueError。</li><li>list.pop([i]):移除列表指定位置i的元素，如果i没有指定移除最后列表尾部的元素</li><li>list.clear():移除所有元素</li><li>list.index(x[, start[, end]]):查找x所在位置，返回其下标记录（0开始），start和end是可选项，指定查找x的范围</li><li>list.count(x):返回x在list中出现的次数</li><li>list.sort(*, key&#x3D;None, reverse&#x3D;False):<code>*</code>上面函数的时候讲了代表分割符号，后面都是keyword arguments；<code>key</code>代表用于在元素中提取比较键的函数，默认值是None，代表直接比较元素；<code>reverse</code>是一个boolean值，如果设置为true，代表每个比较被反转（意思是，如果默认是升序，那么revese&#x3D;True之后就是降序）</li><li>list.reverse():反转list的元素</li><li>list.copy():返回列表的浅拷贝</li></ul><pre><code class="python">fruits = [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;]

fruits.append(&quot;andOne&quot;)
print(fruits)


fruits.extend(&#39;123&#39;)
ttt = [&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;]
fruits.extend(ttt)
print(fruits)

fruits.insert(0,&quot;-1&quot;)
print(fruits)

fruits.pop(0)
print(fruits)
fruits.pop()
print(fruits)

index = fruits.index(&#39;apple&#39;)
print(index)

count_banana = fruits.count(&#39;banana&#39;)
print(count_banana)

fruits.sort()
print(fruits)
fruits.sort(reverse=True)
print(fruits)

fruits.reverse()
print(fruits)

copy_fruit = fruits.copy()
print(copy_fruit)


# [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;andOne&#39;]
# [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;andOne&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;]
# [&#39;-1&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;andOne&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;]
# [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;andOne&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;]
# [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;andOne&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;bb&#39;]
# 1
# 2
# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;andOne&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;bb&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;]
# [&#39;pear&#39;, &#39;orange&#39;, &#39;kiwi&#39;, &#39;bb&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;andOne&#39;, &#39;aa&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;]
# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;andOne&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;bb&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;]
# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;aa&#39;, &#39;andOne&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;bb&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;]
</code></pre><h4 id="列表实现栈"><a href="#列表实现栈" class="headerlink" title="列表实现栈"></a>列表实现栈</h4><p>栈的特点就是Last In，First Out，使用list可以很容易就能实现，具体可以看下面：</p><pre><code class="python">stack = [3, 4, 5]
stack.append(6)
stack.append(7)
stack.append(8)
print(stack)
print(stack.pop())
print(stack.pop())
print(stack.pop())
print(stack)

# [3, 4, 5, 6, 7, 8]
# 8
# 7
# 6
# [3, 4, 5]
</code></pre><h4 id="列表实现队列"><a href="#列表实现队列" class="headerlink" title="列表实现队列"></a>列表实现队列</h4><p>队列的特点就是First In，First Out，可以通过append和pop实现。但是，不够高效。<br>python中collections提供了高效的实现，具体如下：</p><pre><code class="python">from collections import deque

queue = deque([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
queue.append(&#39;d&#39;)
print(queue) #deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
poped_item = queue.popleft()
print(poped_item) #a
</code></pre><h3 id="del语句"><a href="#del语句" class="headerlink" title="del语句"></a>del语句</h3><p>del可以用于删除列表中的一个元素或者整个列表</p><pre><code class="python">a = [1,2,3]
del a[0] #删除一个元素
print(a) #[2,3]
del a[:] #删除整个列表
print(a) #[]
del a #删除变量
print(a) #NameError: name &#39;a&#39; is not defined
</code></pre><h3 id="元组-Tuples-和序列-Sequences"><a href="#元组-Tuples-和序列-Sequences" class="headerlink" title="元组(Tuples)和序列(Sequences)"></a>元组(Tuples)和序列(Sequences)</h3><p>元组是一种标准的序列化类型，由逗号分隔开的许多值组成，比如：</p><pre><code class="python">t  = 111, 222, &#39;123&#39;
print(t[0])
print(t)
# t[0]=999  &#39;tuple&#39; object does not support item assignment

u = t, (1,2,3)
print(u)

v = ([1, 2, 3], [3, 2, 1])
v[0].append(7)
print(v)

empty = ()
singleton = 1,
print(empty) #()
print(singleton) #(1,)

a, b, c = (1,2,3)
print(f&#39;a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;&#39;)
</code></pre><p>元组和列表比较像，但是两者用法不同。元组是不可变的，列表可变，使用下标修改元组数据会报错。但是，元组中元素如果是可变的列表，那么就可以修改。<br>需要注意的是，空元组和单元素元组写法比较特殊。</p><p>元组，可以解构赋值。什么意思呢？就是两边元组一致的话，右边的元组元组可以赋值给左边的变量。这点，我觉得才是元组最大的意义，因为可以实现函数的多返回值。具体，如下：</p><pre><code class="python">def return_3_result():
    #do something
    return 1,2,3

a,b,c = return_3_result()
print(f&#39;多返回值：a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;&#39;)
#多返回值：a=1, b=2, c=3
</code></pre><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p>集合是没有重复元素的无序集合，基本用途包括成员资格测试（判断一个元素是否在集合内）和消除重复项。集合对象还支持数学运算，如并集、交集、差分和对称差分。</p><p>使用<code>&#123;&#39;1&#39;,&#39;2&#39;&#125;</code>和<code>set()</code>创建集合</p><blockquote><p>注意：如果要创建空的集合必须使用<code>set()</code>,因为<code>&#123;&#125;</code>表示一个空的字典</p></blockquote><pre><code class="python">basket1 = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;
print(type(basket1)) #&lt;class &#39;set&#39;&gt;
print(&#39;orange&#39; in basket1) #True
print(&#39;orangeeee&#39; in basket1) #False
basket2 = set(&#39;asda&#39;)
print(type(basket2)) #&lt;class &#39;set&#39;&gt;
basket3 = set() 
print(type(basket3)) #&lt;class &#39;set&#39;&gt;
basket4 = &#123;&#125;
print(type(basket4)) #&lt;class &#39;dict&#39;&gt;

a = set(&#39;abracadabra&#39;)
b = set(&#39;alacazam&#39;)
print(a) #&#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;
print(a - b) #&#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;
print(a | b) #&#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;d&#39;, &#39;b&#39;, &#39;r&#39;, &#39;z&#39;&#125;
print(a &amp; b) #&#123;&#39;c&#39;, &#39;a&#39;&#125;
print(a ^ b) #&#123;&#39;d&#39;, &#39;l&#39;, &#39;m&#39;, &#39;b&#39;, &#39;r&#39;, &#39;z&#39;&#125;
</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>所谓字典，我们可以理解成为多个键值对组成的数据结构。以下是简单的案例：</p><pre><code class="python">tel  = &#123;&#39;jack&#39;:1231, &#39;sape&#39;:2345&#125;
print(tel) #&#123;&#39;jack&#39;: 1231, &#39;sape&#39;: 2345&#125;
print(tel[&#39;jack&#39;]) #1231
del tel[&#39;sape&#39;]
print(tel) #&#123;&#39;jack&#39;: 1231&#125;
tel[&#39;irv&#39;] = 6666
print(tel) #&#123;&#39;jack&#39;: 1231, &#39;irv&#39;: 6666&#125;
tel[&#39;guido&#39;] =888
print(list(tel)) #[&#39;jack&#39;, &#39;irv&#39;, &#39;guido&#39;]
print(sorted(tel)) #[&#39;guido&#39;, &#39;irv&#39;, &#39;jack&#39;]
print(&#39;guido&#39; in tel) #True
print(&#39;jack&#39; not in tel)#False


##构造dict
d = dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])
print(d) #&#123;&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098&#125;
dd = &#123;x: x**2 for x in (2, 4, 6)&#125;
print(dd) #&#123;2: 4, 4: 16, 6: 36&#125;
ddd = dict(sape=4139, guido=4127, jack=4098)
print(ddd) #&#123;&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098&#125;
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Python中一个以<code>.py</code>结尾的文件，被称作一个模块（module），模块可以被其他模块引用。比如说，我创建一个文件叫<code>a.py</code>，这个文件就是一个模块，其中<code>a</code>就是模块名，可以通过<code>__name__</code>内置的函数查看。</p><p>模块包含可执行语句和函数，可执行语句只有在import第一次遇到模块名的时候才会执行（实际上，函数的定义也是可执行的，它执行的行为就是在全局的符号表中录入函数名）。</p><p>每个模块都有自己的私有符号表，这个符号表被这个模块的所有函数使用。因此，模块作者可以使用全局变量而不用担心变量冲突，在模块外部还可以通过<code>modname.itemname</code>的方式来引用。<br>模块之间的引用，可以通过下面的方式来实现:</p><pre><code class="python">from test import t1, t2
from test import * #不推荐，可读性不好
import t1 as tt1
from test import t1 as tt1
</code></pre><h3 id="模块当作脚本执行"><a href="#模块当作脚本执行" class="headerlink" title="模块当作脚本执行"></a>模块当作脚本执行</h3><p>当我们需要把一个单独模块当成脚本执行的时候，我们需要创建一个文件，比如<code>hello.py</code>，然后写下如下代码：</p><pre><code class="python">def sum(a):
    return a

if __name__ == &#39;__main__&#39;:
    import sys
    print(sum(sys.argv[1]))
    print(sum(sys.argv[2]))
</code></pre><p>接着，执行指令：<code>python hello.py 10 20 30</code>,会看到他会立刻执行里面的函数功能。</p><h3 id="模块的搜索路径"><a href="#模块的搜索路径" class="headerlink" title="模块的搜索路径"></a>模块的搜索路径</h3><p>当我们使用<code>import</code>关键字引入一个模块，如何才能找到这个模块的文件位置呢？</p><p>解释器首先会在它的内置模块去找（所有的模块名称，可以通过<code>sys.builtin_module_names</code>查找），如果没有找到会去找<code>sys.path</code>里面查找，<code>sys.path</code>包含以下位置：</p><ul><li>输入脚本的目录，如果没有默认当前目录(<code>python test10.py 10 20 30</code>)</li><li>PYTHONPATH</li><li>依赖于安装的默认值(约定包括site-packages目录，由site模块处理)。</li></ul><blockquote><p>注意：在支持符号链接的系统中，在符号链接之后计算包含输入的脚本的目录。也就是说，包含符号链接的目录不会被添加到模块搜索路径中。</p></blockquote><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>所谓标准库，就是一些非核心代码内置到python解释器中。主要的目的是为了提高效率，或者提供对系统操作的能力。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是组织python模块的一种方式，简单来讲包就是相同功能模块的的集合，以下是个简单示例：</p><pre><code class="python">sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre><p>当导入包的时候，python在<code>sys.path</code>上搜索。</p><blockquote><p>注意：</p><p><code>__init__.py</code>在包中必须存在，这样才能将目录视为包，否则就是一个普通的目录，<code>__init__.py</code>内容可以是空，也可以是执行包初始化代码或者<code>__all__</code>变量初始化的代码。</p><p><code>__all__</code>变量内容包括如下形式，<code>__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</code>,主要目的是为了在使用<code>import *</code>时，告诉解释器要默认导入哪些模块。</p></blockquote><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="更漂亮的格式化输出"><a href="#更漂亮的格式化输出" class="headerlink" title="更漂亮的格式化输出"></a>更漂亮的格式化输出</h3><p>通常，格式化有以下3种方式：</p><ul><li>使用格式化字符串，在引号或者三引号以字母<code>f</code>或者<code>F</code>开头,在引里面可以写一个python表达式并以<code>&#123;&#125;</code>包裹</li><li>使用<code>str.format()</code>,仍使用<code>&#123;&#125;</code>包裹，要替换的位置，并提供详细的格式化命令</li><li>使用str的切片功能自定义格式化</li></ul><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>格式化字符串也叫<code>f-string</code>,允许您在字符串前加上f或f并将表达式写成{expression}，从而在字符串中包含Python表达式的值,举个例子：</p><pre><code class="python">import math
print(f&quot;The value of pi is approximately &#123;math.pi:.3f&#125;.&quot;) #:.3f表示小数点后面三个字符宽度
print(F&quot;The value of pi is approximately &#123;math.pi:.3f&#125;.&quot;)

#运行结果
#The value of pi is approximately 3.142.
#The value of pi is approximately 3.142.
</code></pre><h4 id="字符串format-方法"><a href="#字符串format-方法" class="headerlink" title="字符串format()方法"></a>字符串format()方法</h4><p>使用字符串自带的<code>format()</code>格式化字符串，具体如下：</p><pre><code class="python">print(&#39;We are the &#123;&#125; who say &quot;&#123;&#125;!&quot;&#39;.format(&#39;knights&#39;, &#39;Ni&#39;))

print(&#39;&#123;0&#125; and &#123;1&#125;&#39;.format(&#39;spam&#39;, &#39;eggs&#39;)) #使用参数的位置替换
print(&#39;&#123;1&#125; and &#123;0&#125;&#39;.format(&#39;spam&#39;, &#39;eggs&#39;))


print(&#39;This &#123;food&#125; is &#123;adjective&#125;.&#39;.format(
      food=&#39;spam&#39;, adjective=&#39;absolutely horrible&#39;)) #使用keyword param替换
print(&#39;The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.&#39;.format(&#39;Bill&#39;, &#39;Manfred&#39;,
                                                   other=&#39;Georg&#39;)) #使用位置和keyword paaram混合

table = &#123;&#39;Sjoerd&#39;: 4127, &#39;Jack&#39;: 4098, &#39;Dcab&#39;: 8637678&#125;
print(&#39;Jack: &#123;0[Jack]:d&#125;; Sjoerd: &#123;0[Sjoerd]:d&#125;; &#39;
      &#39;Dcab: &#123;0[Dcab]:d&#125;&#39;.format(table))                                                   

#运行结果
#We are the knights who say &quot;Ni!&quot;
#spam and eggs
#eggs and spam
#This spam is absolutely horrible.
#The story of Bill, Manfred, and Georg.
#Jack: 4098; Sjoerd: 4127; Dcab: 8637678
</code></pre><h4 id="手动格式化字符串"><a href="#手动格式化字符串" class="headerlink" title="手动格式化字符串"></a>手动格式化字符串</h4><p>直接使用print()一个一个拼接，最原始的方式，不推荐</p><h4 id="旧的字符串格式化方式"><a href="#旧的字符串格式化方式" class="headerlink" title="旧的字符串格式化方式"></a>旧的字符串格式化方式</h4><pre><code class="python">import math
print(&#39;The value of pi is approximately %5.3f.&#39; % math.pi)

#运行结果
#The value of pi is approximately 3.142.
</code></pre><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>系统内置函数<code>open()</code>能够返回一个文件对象，最常用的有三个参数，<code>open(filename, mode, encoding=None)</code>,下面我来解释一下：</p><ol><li>filename：文件的完整路径，比如我演示程序中的<code>/Users/knight/PythonProjects/test1/demo1.py</code></li><li>mode：设置文件的读写模式，<strong>r</strong>代表只读是默认选项，<strong>w</strong>代表只写，<strong>a</strong>代表追加到文件尾，**r+**代表读写</li><li>encoding：编码格式，例如’utf-8’等</li></ol><p>python推荐文件读写最佳实践是以<code>with</code>开头的方式，下面看例子：</p><pre><code class="python">with open(&quot;/Users/knight/PythonProjects/test1/demo1.py&quot;, mode = &quot;r+&quot;, encoding=&quot;utf-8&quot;) as f:
    read_data = f.read()
    print(read_data)

#运行结果
#print(&quot;测试文件&quot;)
</code></pre><p>这种方式可以不用考虑文件开启和关闭。否则，需要使用<code>try-finally</code>语句调用<code>f.close()</code>去手动关闭文件流。</p><h4 id="文件对象常用方法"><a href="#文件对象常用方法" class="headerlink" title="文件对象常用方法"></a>文件对象常用方法</h4><pre><code class="python">f = open(&quot;/Users/knight/PythonProjects/test1/demo1.py&quot;, mode = &quot;r+&quot;, encoding=&quot;utf-8&quot;)
f.read() #读取所有文件内容
f.readLine() #读取文件一行内容

for line in f:
    print(line, end=&#39;&#39;) #最佳实践读取所有文件内容

f.write(&#39;This is a test\n&#39;) #文件尾部写入，返回写入数据长度，只能写字符串或者二进制，其他数据类型需要转换
</code></pre><h4 id="使用json保存结构化对象"><a href="#使用json保存结构化对象" class="headerlink" title="使用json保存结构化对象"></a>使用json保存结构化对象</h4><pre><code class="python">import json

f = open(&quot;/Users/knight/PythonProjects/test1/demo1.py&quot;, mode = &quot;r+&quot;, encoding=&quot;utf-8&quot;)
x = [1, &#39;zjhu&#39;,&#39;ada&#39;]
json.dump(x, f)

ff= open(&quot;/Users/knight/PythonProjects/test1/demo1.py&quot;, mode = &quot;r+&quot;, encoding=&quot;utf-8&quot;)
x = json.load(ff)
print(x)

#运行结果
#[1, &#39;zjhu&#39;, &#39;ada&#39;]
</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>和其他语言一样，类提供一种将数据和功能绑定在一起的方式。</p><h3 id="名称和对象"><a href="#名称和对象" class="headerlink" title="名称和对象"></a>名称和对象</h3><p>对象具有独立性，多个名称可以绑定到一个对象上，在其他语言中叫做别名。</p><p>在处理不可变的基本类型(数字、字符串、元组)的时候，可以忽略。然而，涉及到可变对象的时候（列表、字典和大部分类型）的时候，会有令人惊讶的影响。这种影响对于程序是有益的，别名在某些方面类似指针（类似Java中基本类型和对象类型的引用）</p><h3 id="Python的作用域-scope-和命名空间-namespace"><a href="#Python的作用域-scope-和命名空间-namespace" class="headerlink" title="Python的作用域(scope)和命名空间(namespace)"></a>Python的作用域(scope)和命名空间(namespace)</h3><p>命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><h4 id="命名空间的分类"><a href="#命名空间的分类" class="headerlink" title="命名空间的分类"></a>命名空间的分类</h4><p>命名空间分为三种：</p><ul><li><strong>内置名称(build-in names)</strong>,在python解释器开始运行时，就会申请生成的地方，在这里存放的都是系统内置的名称，比如python关键字，print，import等等，或者内置的变量pi；该namespace只有一个，只有当python解释器退出的时候，才会进行释放回收。</li><li><strong>全局名称(global names)</strong>,在程序代码解释过程中，只要不是函数体内创建的name，都存放在全局namespace中，包含变量名、函数名、类名等等。作用域整个python程序，当该python程序运行完成后，才会进行清空回收。</li><li><strong>局部名称(lcoal names)</strong>,在函数体内定义的name，作用域只在函数体内，调用一次函数即会产生一次namespace，每个函数实例都会有自己的namespace，当函数调用完成后，就会释放消失</li></ul><h4 id="命名空间的顺序"><a href="#命名空间的顺序" class="headerlink" title="命名空间的顺序"></a>命名空间的顺序</h4><p>生成顺序：<mark>1.内置namespace，2.全局namespace，3.局部namespace</mark></p><p>销毁顺序：<mark>1.局部namespace，2.全局namespace，3.内置namespace</mark></p><p>查找顺序：<mark>当前位置，向上查找，如果在全局，只能差全局和内置，如果在局部，三个namespace都可以查找</mark></p><h4 id="命名空间的生命周期"><a href="#命名空间的生命周期" class="headerlink" title="命名空间的生命周期"></a>命名空间的生命周期</h4><p>命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束</p><h4 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h4><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域</p><p>有四种作用域：</p><ol><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数&#x2F;方法内部</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量</li><li><strong>B（Built-in）</strong>： 包含了内建的变量&#x2F;关键字等，最后被搜索</li></ol><p>顺序：<mark>L-&gt;E-&gt;G-&gt;B</mark>,在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p><h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><pre><code class="python">total = 0 # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
    #返回2个参数的和.&quot;
    total = arg1 + arg2 # total在这里是局部变量.
    print (&quot;函数内是局部变量 : &quot;, total)
    return total
 
#调用sum函数
sum( 10, 20 )
print (&quot;函数外是全局变量 : &quot;, total)

#输出结果：
#函数内是局部变量 :  30
#函数外是全局变量 :  0
</code></pre><h3 id="global-和-nonlocal关键字"><a href="#global-和-nonlocal关键字" class="headerlink" title="global 和 nonlocal关键字"></a>global 和 nonlocal关键字</h3><p>global用于修改全局变量</p><pre><code class="python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) #打印1 
    num = 123
    print(num) #打印123
fun1()
print(num) #打印123
</code></pre><p>nonlocal用于修改嵌套作用域</p><pre><code class="python">num = 0 #全局作用域
def outer():
    num = 10 #outer的局部作用域
    def inner():
        nonlocal num   # nonlocal关键字声明，修改outer的局部作用域num
        num = 100
        print(num) #100
    inner()
    print(num) #100
outer()
print(num) #没有修改所以还是0
</code></pre><h3 id="定义类的语法"><a href="#定义类的语法" class="headerlink" title="定义类的语法"></a>定义类的语法</h3><pre><code class="python">class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>类对象支持两种操作，<strong>属性引用</strong>和<strong>实例化</strong></p><p>属性引用通过标准化的<code>.</code>来直接引用，类对象创建之后所有的命名都是有效的属性名，如果类定义是这样的：</p><pre><code class="python">class DemoClass:
    &#39;&#39;&#39;类的简单例子&#39;&#39;&#39;
    i = 12345
    def f(self):
        return &quot;hello class in py&quot;

#实例化DemoClass     
x = DemoClass()
#访问类的属性和方法
print(x.i) #12345
print(x.f()) #hello class in py
</code></pre><p>有时候，在实例化类的时候，我们希望初始化自己的状态，因此python提供了一个构造器<code>__init__()</code>。</p><pre><code class="python">class ComplexClass:
    &#39;&#39;&#39;稍微复杂的例子&#39;&#39;&#39;
    #定义构造方法
    def __init__(self, realpart:int, imagpart:str) -&gt; None:
        self.r = realpart
        self.i = imagpart

x = ComplexClass(1,&#39;333&#39;)
print(x.i) #333
print(x.r) #1
</code></pre><p>其中<code>self</code>代表的是类的实例化对象，指向对象的地址，而<code>self.__class__</code>才是指向类的。</p><blockquote><p>注意⚠️：</p><p>self不是关键字，可以用其他符号代替，比如我换成cc，结果也是一样的</p></blockquote><p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例</p><pre><code class="python">#类定义
class people:
    #定义基本属性
    name = &#39;&#39;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
# 实例化类
p = people(&#39;runoob&#39;,10,30)
p.speak()
</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>语法如下：</p><pre><code class="python">class DerivedClassName(BaseClassName):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><pre><code class="python">class DerivedClassName(modname.BaseClassName):
</code></pre><p>简单案例：</p><pre><code class="python">#类定义
class people:
    #定义基本属性
    name = &#39;&#39;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = &#39;&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
 
 
 
s = student(&#39;ken&#39;,10,60,3)
s.speak() #ken 说: 我 10 岁了，我在读 3 年级
</code></pre><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>py支持有限的多继承，语法如下：</p><pre><code class="python">class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><pre><code class="python">#类定义
class people:
    #定义基本属性
    name = &#39;&#39;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = &#39;&#39;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
 
#另一个类，多重继承之前的准备
class speaker():
    topic = &#39;&#39;
    name = &#39;&#39;
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
 
#多重继承
class sample(speaker,student):
    a =&#39;&#39;
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
#方法名同，默认调用的是在括号中参数位置排前父类的方法
test.speak()   #我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p><pre><code class="python">class Parent:        # 定义父类
   def myMethod(self):
      print (&#39;调用父类方法&#39;)
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print (&#39;调用子类方法&#39;)
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
#用子类对象调用父类已被覆盖的方法
super(Child,c).myMethod() #super() 函数是用于调用父类(超类)的一个方法。

#打印结果
#调用子类方法
#调用父类方法
</code></pre><h3 id="类属性和方法"><a href="#类属性和方法" class="headerlink" title="类属性和方法"></a>类属性和方法</h3><ul><li><p>类私有属性：</p><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p></li><li><p>类方法</p><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p></li><li><p>类的私有方法</p><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p></li></ul><p>案例：</p><pre><code class="python">class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
 
    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print (self.__secretCount)
 
counter = JustCounter()
counter.count()
counter.count()
print (counter.publicCount)
print (counter.__secretCount)  # 报错，实例不能访问私有变量

#执行结果
1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: &#39;JustCounter&#39; object has no attribute &#39;__secretCount&#39;
</code></pre><h3 id="类专有的方法"><a href="#类专有的方法" class="headerlink" title="类专有的方法"></a>类专有的方法</h3><ul><li><strong><strong>init</strong> :</strong> 构造函数，在生成对象时调用</li><li><strong><strong>del</strong> :</strong> 析构函数，释放对象时使用</li><li><strong><strong>repr</strong> :</strong> 打印，转换</li><li><strong><strong>setitem</strong> :</strong> 按照索引赋值</li><li><strong><strong>getitem</strong>:</strong> 按照索引获取值</li><li><strong><strong>len</strong>:</strong> 获得长度</li><li><strong><strong>cmp</strong>:</strong> 比较运算</li><li><strong><strong>call</strong>:</strong> 函数调用</li><li><strong><strong>add</strong>:</strong> 加运算</li><li><strong><strong>sub</strong>:</strong> 减运算</li><li><strong><strong>mul</strong>:</strong> 乘运算</li><li><strong><strong>truediv</strong>:</strong> 除运算</li><li><strong><strong>mod</strong>:</strong> 求余运算</li><li><strong><strong>pow</strong>:</strong> 乘方</li></ul><p>同样的，这些方法也支持重载</p><h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例:</p><pre><code class="python">while True print(&#39;Hello world&#39;)
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
    while True print(&#39;Hello world&#39;)
    
SyntaxError: invalid syntax    
</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>即使语法正常，运行它的时候，也有可能发生错误，运行期检测到的错误被称为异常。</p><p>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里：</p><pre><code class="python">&gt;&gt;&gt; 10 * (1/0)             # 0 不能作为除数，触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
ZeroDivisionError: division by zero
&gt;&gt;&gt; 4 + spam*3             # spam 未定义，触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name &#39;spam&#39; is not defined
&gt;&gt;&gt; &#39;2&#39; + 2               # int 不能与 str 相加，触发异常
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: can only concatenate str (not &quot;int&quot;) to str
</code></pre><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。</p><p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>语法如下:</p><pre><code class="python">try:
    #执行可能有异常代码
    ---
except AssertionError as error:
    #发生异常的时候执行的代码
    ---
else:
      #没有异常的时候执行的代码
    ---
finally:
      #无论如何都会执行的代码
    print(&#39;这句话，无论异常是否发生都会执行。&#39;)
</code></pre><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>Python 使用 raise 语句抛出一个指定的异常，语法如下</p><pre><code class="python">#语法
raise [Exception [, args [, traceback]]]

#实现
x = 10
if x &gt; 5:
    raise Exception(&#39;x 不能大于 5。x 的值为: &#123;&#125;&#39;.format(x))
    
#结果
Traceback (most recent call last):
  File &quot;/Users/knight/PythonProjects/test1/demo11.py&quot;, line 3, in &lt;module&gt;
    raise Exception(&#39;x 不能大于 5。x 的值为: &#123;&#125;&#39;.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre><h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:</p><pre><code class="python">#自定义异常
class MyError(Exception):
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)

#使用自定义异常
try:
    raise MyError(2*2)
except MyError  as e:
    print(f&quot;My exception occurred, value: &#123;e&#125;&quot;)
    
#结果
#My exception occurred, value: 4    
</code></pre><h3 id="定义清理行为"><a href="#定义清理行为" class="headerlink" title="定义清理行为"></a>定义清理行为</h3><p>try 语句还有另外一个可选的子句（finally），它定义了无论在任何情况下都会执行的清理行为。</p><h3 id="预定义的清理行为"><a href="#预定义的清理行为" class="headerlink" title="预定义的清理行为"></a>预定义的清理行为</h3><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p><p>比如我们前面讲的<code>with</code>语句，就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><pre><code class="python">with open(&quot;xxx.txt&quot;) as f:
    for line in f:
        print(line, end=&quot;&quot;)
</code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>自此，我们python的基础学习告一段落。</p><p>其实，学习的时候发现很多语法或者功能都比较熟悉。毕竟，优秀的设计大家都会互相借鉴。</p><p>ok，后面python的文章可能就偏向于python的标准库实战了。毕竟，这才是pyhton的精华所在。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>zhuchong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://github/zhuchong6.github.io/2022/09/28/2022-09-28python%E5%AD%A6%E4%B9%A0/" title="Python学习">https://github/zhuchong6.github.io/2022/09/28/2022-09-28python学习/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Python/" rel="tag"># Python</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/06/21/2022-06-21elasticsearch/" rel="prev" title="ElasticSearch基础"><i class="fa fa-chevron-left"></i> ElasticSearch基础</a></div><div class="post-nav-item"><a href="/2022/12/07/2022-12-08mini-spring1/" rel="next" title="Mini-Spring之扫描组件类">Mini-Spring之扫描组件类 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0"><span class="nav-number">1.1.</span> <span class="nav-text">语言元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 变量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 变量命名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">分支结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%85%A5%E5%8F%82%E5%80%BC"><span class="nav-number">1.4.1.</span> <span class="nav-text">默认入参值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keyword-Arguments%E5%92%8CPositional-Arguments"><span class="nav-number">1.4.2.</span> <span class="nav-text">Keyword Arguments和Positional Arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">特殊参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.4.</span> <span class="nav-text">任意参数列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%86%E5%8C%85%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.5.</span> <span class="nav-text">拆包参数列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.6.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.7.</span> <span class="nav-text">函数注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.5.1.</span> <span class="nav-text">List详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">列表实现栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">列表实现队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#del%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">del语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84-Tuples-%E5%92%8C%E5%BA%8F%E5%88%97-Sequences"><span class="nav-number">1.5.3.</span> <span class="nav-text">元组(Tuples)和序列(Sequences)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sets"><span class="nav-number">1.5.4.</span> <span class="nav-text">Sets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">1.5.5.</span> <span class="nav-text">字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">1.6.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%BD%93%E4%BD%9C%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C"><span class="nav-number">1.6.1.</span> <span class="nav-text">模块当作脚本执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="nav-number">1.6.2.</span> <span class="nav-text">模块的搜索路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">1.6.3.</span> <span class="nav-text">标准库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">1.6.4.</span> <span class="nav-text">包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">1.7.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%BC%82%E4%BA%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-number">1.7.1.</span> <span class="nav-text">更漂亮的格式化输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">格式化字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2format-%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">字符串format()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">手动格式化字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">旧的字符串格式化方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">1.7.2.</span> <span class="nav-text">读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">文件对象常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8json%E4%BF%9D%E5%AD%98%E7%BB%93%E6%9E%84%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">使用json保存结构化对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.8.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.8.1.</span> <span class="nav-text">名称和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-scope-%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="nav-number">1.8.2.</span> <span class="nav-text">Python的作用域(scope)和命名空间(namespace)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">命名空间的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">命名空间的顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">命名空间的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">作用域(Scope)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">全局变量和局部变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#global-%E5%92%8C-nonlocal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.8.3.</span> <span class="nav-text">global 和 nonlocal关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">1.8.4.</span> <span class="nav-text">定义类的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.8.5.</span> <span class="nav-text">类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.8.6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">多继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="nav-number">1.8.7.</span> <span class="nav-text">方法重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.8.</span> <span class="nav-text">类属性和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%93%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.9.</span> <span class="nav-text">类专有的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.</span> <span class="nav-text">错误和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"><span class="nav-number">1.9.1.</span> <span class="nav-text">语法错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.2.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.9.3.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.4.</span> <span class="nav-text">抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">1.9.5.</span> <span class="nav-text">用户自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.9.6.</span> <span class="nav-text">定义清理行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E6%B8%85%E7%90%86%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.9.7.</span> <span class="nav-text">预定义的清理行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E5%B0%BE"><span class="nav-number">2.</span> <span class="nav-text">结尾</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">zhuchong</p><div class="site-description" itemprop="description">世人慌慌张张，不过是图碎银几两； 偏偏这碎银几两，能解世间万种慌张</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">55</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhuhcong6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhuhcong6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">zhuchong</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,tagMode:!1})</script></body></html>