<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"github",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言自上一篇Claas文件结构，我们了解Java代码编译成的字节码存储的具体细节。 本篇文章，我们需要理解虚拟机加载Class文件的过程。 环境：  操作系统：win10 JDK版本：1.8.0_291  本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。"><meta property="og:type" content="article"><meta property="og:title" content="虚拟机加载机制"><meta property="og:url" content="https://github/zhuchong6.github.io/2022/01/04/2022-01-04%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/index.html"><meta property="og:site_name" content="Zeus的小窝QAQ"><meta property="og:description" content="前言自上一篇Claas文件结构，我们了解Java代码编译成的字节码存储的具体细节。 本篇文章，我们需要理解虚拟机加载Class文件的过程。 环境：  操作系统：win10 JDK版本：1.8.0_291  本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://github/images/life_time.png"><meta property="article:published_time" content="2022-01-04T09:14:00.000Z"><meta property="article:modified_time" content="2023-08-07T00:18:37.950Z"><meta property="article:author" content="zhuchong"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://github/images/life_time.png"><link rel="canonical" href="https://github/zhuchong6.github.io/2022/01/04/2022-01-04%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>虚拟机加载机制 | Zeus的小窝QAQ</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Zeus的小窝QAQ" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Zeus的小窝QAQ</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">17</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">55</span></a></li></ul></nav></div></header><div class="reading-progress-bar"></div><a href="https://github.com/zhuchong6" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://github/zhuchong6.github.io/2022/01/04/2022-01-04%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhuchong"><meta itemprop="description" content="世人慌慌张张，不过是图碎银几两； 偏偏这碎银几两，能解世间万种慌张"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zeus的小窝QAQ"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">虚拟机加载机制</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-01-04 17:14:00" itemprop="dateCreated datePublished" datetime="2022-01-04T17:14:00+08:00">2022-01-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-08-07 08:18:37" itemprop="dateModified" datetime="2023-08-07T08:18:37+08:00">2023-08-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自上一篇<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#more">Claas文件结构</a>，我们了解Java代码编译成的字节码存储的具体细节。</p><p>本篇文章，我们需要理解虚拟机加载Class文件的过程。</p><p>环境：</p><blockquote><p>操作系统：win10</p><p>JDK版本：1.8.0_291</p></blockquote><p>本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。</p><span id="more"></span><h1 id="加载链接初始化"><a href="#加载链接初始化" class="headerlink" title="加载链接初始化"></a>加载链接初始化</h1><p>开始之前，我们先大致浏览下，类的生命周期。</p><p><img src="/images/life_time.png" alt="类的生命周期"></p><p>其主要分为<strong>Loading</strong>、<strong>Linking</strong>和<strong>Initializing</strong>这三个阶段，下面解释这三个阶段大致所做的工作：</p><ul><li>Loading：加载是找到具有特定名称的类或接口类型的二进制表示，并从该二进制表示创建类或接口的过程</li><li>Linking：链接是获取一个类或接口并将其组合到Java虚拟机的运行时状态以便执行的过程</li><li>Initializing：类或接口的初始化包括执行类或接口初始化方法<strong>&lt;clinit&gt;</strong></li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>jvm维护了一个包含所有类型的常量池，是运行时结构，用以实现符号表。</p><p>类或者接口的常量池组成运行时常量池，运行时常量池中所有的引用最初都是符号引用，运行时常量池的引用来源于以下几个方面：</p><ul><li><p>类或者接口的符号引用，是源于类或者接口的二进制表示(class文件，io流等)中<strong>CONSTANT_Class_info</strong>结构，这样的一个类或者接口的引用以Class.getName方法的返回值命名，其中：</p><ul><li>对于非数组接口，名称是类或者接口的二进制名称，例如：<em>java&#x2F;lang&#x2F;Thread</em></li><li>对一个n维数组，名称以<code>n个[</code>开头，例如：*[[java&#x2F;lang&#x2F;Thread,表示二维数组*<ul><li>如果数组元素是基本类型，那么通过相应的字段描述符<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=FieldType%E6%9C%AF%E8%AF%AD,%E8%A7%A3%E9%87%8A">对应表</a>表示，例如：*[I，表示整数数组*</li><li>如果是引用类型，那么以<em>L</em>开头，*;<em>结尾，中间是二进制名称，例如：</em>[[Ljava&#x2F;lang&#x2F;Integer; ，表示Integer二维数组*</li></ul></li></ul></li><li><p>字段的符号引用源于类或者接口的二进制表示(class文件，io流等)中<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=%E5%80%BC%0A%20%20%20%20u2%20name_index%3B%0A%7D-,CONSTANT_Fieldref_info,-%EF%BC%8CCONSTANT_Methodref_info%EF%BC%8CCONSTANT_InterfaceMethodref_info">CONSTANT_Fieldref_info</a>结构。这个引用给出了该字段名称和描述符，以及字段所在类或者接口的符号引用。</p></li><li><p>方法的符号引用源于类或者接口的二进制表示(class文件，io流等)中<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=CONSTANT_Fieldref_info%EF%BC%8C-,CONSTANT_Methodref_info,-%EF%BC%8CCONSTANT_InterfaceMethodref_info">CONSTANT_Methodref_info</a>结构。这个引用给出了该方法名称和描述符，以及方法所在类或者接口的符号引用。</p></li><li><p>接口的符号引用源于类或者接口的二进制表示(class文件，io流等)中<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=CONSTANT_Fieldref_info%EF%BC%8CCONSTANT_Methodref_info%EF%BC%8C-,CONSTANT_InterfaceMethodref_info,-CONSTANT_Fieldref_info%20%7B%0A%20%20%20%20%20%20%20//%E5%80%BC%E4%B8%BA">CONSTANT_InterfaceMethodref_info</a>结构。这个引用给出了该接口名称和描述符，以及接口的符号引用。</p></li><li><p>方法句柄（可以看作引用）的符号引用源于类或者接口的二进制表示(class文件，io流等)中<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=u1%20bytes%5Blength%5D%3B%0A%7D-,CONSTANT_MethodHandle_info,-CONSTANT_MethodHandle_info%20%7B%0A%20%20%20%20%20%20//%E5%80%BC%E4%B8%BA">CONSTANT_MethodHandle_info</a>结构。这个引用给出了给出了对类或接口的字段、类的方法或接口的方法的符号引用，这取决于方法句柄的类型。</p></li><li><p>方法类型的符号引用引用源于类或者接口的二进制表示(class文件，io流等)中<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=init%3E%0A%20%20%20%20u2%20reference_index%3B%0A%7D-,CONSTANT_MethodType_info,-CONSTANT_MethodType_info%20%7B%0A%20%20%20%20%20%20%20//%E5%80%BC%E4%B8%BA">CONSTANT_MethodType_info</a>结构。这个引用指向<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6-,%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0%E7%AC%A6,-MethodDescriptor%3A">方法描述符</a>。</p></li><li><p>调用点的符号引用源于类或者接口的二进制表示(class文件，io流等)中<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=%E7%AC%A6%0A%20%20%20u2%20descriptor_index%3B%0A%7D-,CONSTANT_InvokeDynamic_info,-//%20%E8%A1%A8%E7%A4%BAinvokedynamic%E6%8C%87%E4%BB%A4">CONSTANT_InvokeDynamic_info</a>，这个比较复杂，我会单独抽出来讲</p></li><li><p>字符串字面量是String对象的引用，源于<a target="_blank" rel="noopener" href="https://zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#:~:text=%E7%AC%A6%0A%20%20%20%20u2%20name_and_type_index%3B%0A%7D-,CONSTANT_String_info,-CONSTANT_String_info%20%7B%0A%20%20%20%20%20%20%20//%E5%80%BC%E4%B8%BA">CONSTANT_String_info</a>，这个结构给出组成字符串字面量的<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/12/unicode.html">Unicode的码点</a>。Java中规定，相同字面量（也就是码点序列一样）的字符串必须指向相同的String的引用。除此之外，调用<strong>String.intern</strong>方法，返回和这个字符串字面量相同的字符串对象的引用，例如：</p><pre><code class="java">(&quot;a&quot; + &quot;b&quot; + &quot;c&quot;).intern() == &quot;abc&quot;;//true
new String(&quot;abc&quot;) == &quot;abc&quot;; //false
new String(&quot;abc&quot;).intern() == &quot;abc&quot;; //true
</code></pre><p>为了得到字符串字面量，JVM检查<strong>CONSTANT_String_info</strong>结构的码点序列</p><ul><li>如果方法String.intern之前在一个String类的实例上被调用过，该实例包含与<strong>CONSTANT_String_info</strong>结构体相同的Unicode码位序列，那么字符串字面量的结果是对String类的同一个实例的引用</li><li>否则，将创建一个新的String类实例，其中包含由<strong>CONSTANT_String_info</strong>结构体给出的Unicode码位序列;对该类实例的引用是字符串字面量派生的结果。最后，调用新的String实例的intern方法</li></ul></li><li><p>运行时常量值源于类或者接口的二进制表示(class文件，io流等)中CONSTANT_Integer_info，CONSTANT_Float_info，CONSTANT_Long_info，CONSTANT_Double_info。</p></li></ul><h2 id="虚拟机启动"><a href="#虚拟机启动" class="headerlink" title="虚拟机启动"></a>虚拟机启动</h2><p>Java虚拟机通过使用bootstrap类加载器创建初始类来启动，该类以依赖于实现的方式指定。然后，Java虚拟机链接初始类，对其进行初始化，并调用公共类方法void main（String[]）。此方法的调用将驱动所有进一步的执行</p><h2 id="创建和加载"><a href="#创建和加载" class="headerlink" title="创建和加载"></a>创建和加载</h2><p>在jvm方法区中创建一个名称是N表示的类或者接口C，它是C的一个特定的内部实现。创建过程是由另一个类或者接口D触发，通过运行时常量池引用C触发。类或接口的创建也可以通过D调用某些Java SE平台类库中的方法来触发，比如反射。</p><blockquote><p>总结就是，创建过程是被动的，要么是别人调用你触发，要么是调用反射接口触发</p></blockquote><p>如果C不是数组，那么通过加载C的二进制表示（字节码文件）来加载它；如果是数组，没有二进制表示形式，直接通过虚拟机创建。</p><p>类加载器L通过两种方式创建C，直接定义或者委托给另外一个类加载器，具体：</p><ul><li>如果L直接创建了C，我们说L定义了C（<strong>L <em>defines</em> C</strong>），等价的L是C的<span id="dl"><code>defining loader</code></span></li><li>如果L委托另一个类加载器创建C，我们说L启动了C的加载（**L initiates loading of C **），等价的L是C的<span id="il"><code>initiating loader</code></span></li></ul><p>运行时，类或者接口通过它的二进制名称和它的定义类加载器确定；同时，每个这样的类或接口都属于一个运行时包，而运行时包也是由包名和类的定义类加载器确定。</p><p>一个好的类加载器，应该维护三个属性：</p><ol><li>给定相同的名字，一个好的类加载器应该始终返回相同<strong>Class</strong>对象</li><li>如果一个类加载器L1委托类加载器L2去加载类C，那么对于任何类型T（可以是C的直接父类或者直接父接口，可以是C的属性字段，可以是C中方法或者构造器的形参，也可以是C中方法的返回类型），L1和L2应该返回相同的<strong>Class</strong>对象</li><li>如果用户定义的类加载器预取类和接口的二进制表示，或者一起加载一组相关的类，那么它必须只在程序中没有预取或组加载时可能出现加载错误的地方反映加载错误</li></ol><h3 id="使用Bootstrap类加载器加载"><a href="#使用Bootstrap类加载器加载" class="headerlink" title="使用Bootstrap类加载器加载"></a>使用Bootstrap类加载器加载</h3><p>下面步骤用于使用bootstrap类加载器，加载创建非数组类或者接口(用C表示类)，并用N表示其类名称的过程：</p><ol><li><p>JVM首先确定是否bootstrap加载器被记录为接口或类N的初始化加载器。如果是的，那么这个类或者接口就是C，无需重新创建；如果不是，jvm将参数N传递给bootstrap类加载器上的方法调用，去搜索C。</p><blockquote><p>注意：</p><p>不能保证所找到的所谓表示是有效的，或者是c的表示。</p><p>这个加载阶段必须检测到以下错误:如果没有找到所谓的C表示，加载时会抛出ClassNotFoundException的实例</p></blockquote></li><li><p>JVM虚拟机会使用bootstrap类加载器生产一个用N表示的类C</p></li></ol><h3 id="使用用户自定义的类加载器加载"><a href="#使用用户自定义的类加载器加载" class="headerlink" title="使用用户自定义的类加载器加载"></a>使用用户自定义的类加载器加载</h3><p>下面步骤用于使用用户自定义的类加载器L，加载创建非数组类或者接口(用C表示类)，并用N表示其类名称的过程：</p><p>JVM首先确定是否自定义加载器L被记录为接口或类N的初始化加载器。如果是的，那么这个类或者接口就是C，无需重新创建；</p><p>如果不是，JVM调用L上的loadClass(N)，并返回创建好的类或者接口C。并且，JVM记录L是C的初始化加载器。</p><h3 id="创建数组类"><a href="#创建数组类" class="headerlink" title="创建数组类"></a>创建数组类</h3><p>下面步骤用于使用类加载器L(N可以是bootstrap加载器，可以是自定义加载器),加载创建数组类(C表述数组类)，并用N表示其类名的过程：</p><ol><li><p>JVM首先确定是否L加载器被记录为数组类N中类型（指数组元素的类型）的初始化加载器。如果是的，那么这个数组类或者接口就是C，无需重新创建</p></li><li><p>不是的话，在看元素组件的类型。如果是引用类型，那么则递归调用L创建C的元素的类型。然后JVM根据明确类型创建一个新的数组类。此时，如果C是引用类型，那么C被标记为C元素的<a href="#dl">define loader</a>加载；否则，C被标记为由bootstrap加载。</p><p>但无论如何，C都会记录L是C的<a href="#il"><strong>initiating loader</strong></a>。</p></li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接一个类或者接口包括验证和准备这个类或者接口，它的直接父类，它的直接父接口，和它的元素类型（如果它是一个数组类型）。解析类或者接口中的符号引用是可选部分。</p><p>JVM规范在链接活动发生时灵活的实现，但是必须要维护以下几个点：</p><ul><li>类或接口在被链接之前是完全加载的。</li><li>类或接口在初始化之前要完全验证和准备。</li><li>在链接期间检测到的错误会在程序中的某个点抛出，在这个点上，程序采取了一些操作，这些操作可能直接或间接地要求链接到错误中涉及的类或接口。</li></ul><p>因为链接涉及到新数据结构的分配，所以它可能会失败并出现OutOfMemoryError错误。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证确保类或者接口的二进制表现形式结构正确，可能会造成额外的类或者接口被加载，但是无需对这些额外的类或者接口进行验证。</p><p>如果类或者接口的二进制结构不对，必须抛出<strong>VerifyError</strong>异常。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备涉及到为类或者接口创建静态字段，初始化这些字段为默认值。注意这个过程不需要调用JVM代码，显示初始化字段（类似：a &#x3D; 1这样的操作）并不属于准备这个过程。</p><p>准备可以在创建阶段之后任何时间节点发生，但是一定要在初始化之前完成。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>JVM指令anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokspecial、invokestatic、invokvirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic对运行时常量池进行符号引用。执行任何这些指令都需要解析其符号引用。</p><blockquote><p>符号引用：类似这样的，<em>java&#x2F;lang&#x2F;Thread</em>，*[I，表示整数数组<em>，</em>[[java&#x2F;lang&#x2F;Thread,表示二维数组*</p></blockquote><p><strong>解析过程就是根据符号引用从运行时常量池中动态确定具体值的过程</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类或接口的初始化包括执行其类或接口初始化方法。</p><p>类或者接口C只在以下情况初始化：</p><ul><li>JVM指令<code>new , getstatic or invokestatic</code>中任意一个引用到C。这些指令通过字段引用或者方法引用直接或间接引用C。</li><li>方法句柄(<strong>java.lang.invoke.MethodHandle</strong>)解析到句柄类型2（REF_getStatic），4（REF_putStatic），6（REF_invokeStatic），8（REF_invokeStatic）</li><li>在类库中调用反射方法，例如<code>Class.forObject</code></li><li>如果C是一个类，初始化它的子类</li><li>如果C是非抽象或者非静态的接口，则直接或间接实现C的类初始化</li><li>如果C事一个类，被设计为JVM初始化类</li></ul><blockquote><p>注意：</p><p>在初始化之前，必须要被链接包括验证，准备，有选择性的解析</p></blockquote><p>假设有类或者接口C，唯一的初始化锁LC。</p><p><strong>下面给出C的初始化过程</strong>：</p><ol><li>为C同步获取初始化锁LC，等待直到获取成功</li><li>如果类对象C显示被其他线程正在初始化C，那么久释放当前线程锁LC并阻赛当前线程，知道通知其他线程初始化成功，在继续重复这个过程</li><li>如果类对象C显示被当前线程正在初始化C，那么这肯定是一个递归调用初始化，释放LC并完成</li><li>如果类对象C显示C已经被初始化，无需操作，释放LC并完成</li><li>如果类对象C显示C处于错误状态，初始化为成功，释放LC，并抛出一个<strong>NoClassDefFoundError</strong></li><li>否则，记录当前线程正在对C进行初始化，并释放LC</li><li>下一步，如果C是一个类而不是接口，并且它的父类并没有被初始化。然后让SC是它的父类，并且让SL1。。SLn是C的所有的父接口（至少声明一个non-abstract，non-static方法），不论是直接或者间接。父接口的顺序由C实现的文件层次结构枚举给出。对于C直接实现的接口，按照C接口数组的顺序。</li><li>下一步通过查询C的<code>defining loader</code>来确认是否启用断言</li><li>然后执行C的初始化方法</li><li>如果类或接口初始化方法的执行正常完成，则获取LC，将C的class对象标记为完全初始化，通知所有等待的线程，释放LC，并正常完成此过程。</li><li>否则，类或接口初始化方法必须通过抛出一些异常E突然完成</li><li>获取LC，将C的Class对象标记为错误，通知所有等待线程，释放LC，并突然以原因E或其替换(如前一步所确定的)完成此步</li></ol><h2 id="绑定本地方法实现"><a href="#绑定本地方法实现" class="headerlink" title="绑定本地方法实现"></a>绑定本地方法实现</h2><p>绑定是将用Java编程语言以外的语言编写并实现本机方法的函数集成到Java虚拟机中以便执行的过程。尽管这个过程传统上被称为链接，但规范中使用术语绑定是为了避免与Java虚拟机的类或接口链接混淆。</p><h2 id="退出虚拟机"><a href="#退出虚拟机" class="headerlink" title="退出虚拟机"></a>退出虚拟机</h2><p>当某个线程调用类Runtime或类System的退出方法或类Runtime的暂停方法，并且安全管理器允许退出或暂停操作时，Java虚拟机退出。</p><p>此外，JNI (Java本机接口)规范描述了当使用JNI调用API加载和卸载Java虚拟机时Java虚拟机的终止。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>zhuchong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://github/zhuchong6.github.io/2022/01/04/2022-01-04%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="虚拟机加载机制">https://github/zhuchong6.github.io/2022/01/04/2022-01-04虚拟机加载机制/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JVM/" rel="tag"># JVM</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/10/29/2021-10-29%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="prev" title="分布式事务"><i class="fa fa-chevron-left"></i> 分布式事务</a></div><div class="post-nav-item"><a href="/2022/01/06/2022-01-06Long%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%8E%B0%E8%B1%A1/" rel="next" title="Long类型有趣的现象">Long类型有趣的现象 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%93%BE%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">加载链接初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.1.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8"><span class="nav-number">2.2.</span> <span class="nav-text">虚拟机启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.3.</span> <span class="nav-text">创建和加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Bootstrap%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用Bootstrap类加载器加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.3.2.</span> <span class="nav-text">使用用户自定义的类加载器加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%B1%BB"><span class="nav-number">2.3.3.</span> <span class="nav-text">创建数组类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">2.4.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">2.4.1.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">2.4.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">2.4.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.5.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.6.</span> <span class="nav-text">绑定本地方法实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.7.</span> <span class="nav-text">退出虚拟机</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">zhuchong</p><div class="site-description" itemprop="description">世人慌慌张张，不过是图碎银几两； 偏偏这碎银几两，能解世间万种慌张</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">55</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/zhuhcong6" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhuhcong6" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">zhuchong</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.bootcdn.net/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,tagMode:!1})</script></body></html>