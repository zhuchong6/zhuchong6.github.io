<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zeus的小窝QAQ</title>
  
  
  <link href="https://github/zhuchong6.github.io/atom.xml" rel="self"/>
  
  <link href="https://github/zhuchong6.github.io/"/>
  <updated>2023-08-07T00:18:37.954Z</updated>
  <id>https://github/zhuchong6.github.io/</id>
  
  <author>
    <name>zhuchong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本地k8s搭建</title>
    <link href="https://github/zhuchong6.github.io/2023/08/01/2023-08-01K8S%E6%90%AD%E5%BB%BA/"/>
    <id>https://github/zhuchong6.github.io/2023/08/01/2023-08-01K8S%E6%90%AD%E5%BB%BA/</id>
    <published>2023-08-01T13:16:30.000Z</published>
    <updated>2023-08-07T00:18:37.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>k8s学习中，我们一直用的是本地docker中提供的k8s组件。这种方式其实就是一个单节点的k8s，只能在学习中使用，一般线上环境我们要么选择云商的k8s服务，要么多机器自己搭建k8s集群。这里，我们本地学习下k8s的搭建过程。本次搭建过程使用rancher搭建，简单快捷（对比二进制搭建来说）。</p><span id="more"></span><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li><p>准备三台主机用于部署k8s（node1:10.15.0.11, node2:10.15.0.12,node3:10.15.0.13），准备一台主机用于部署rancher（10.15.0.10），总计四台服务器</p><blockquote><p>注意：</p><p>我启动的是centos虚拟机</p><p>修改ip方法：</p><pre><code class="shell">cd /etc/sysconfig/network-scripts/vi ifcfg-ens160 #修改对应ip为你想要的ip地址，并保存，并且将BOOTPROTO对应的值改成staticsudo systemctl restart network #刷新网络服务ip addr #查看你修改的ip是否生效</code></pre></blockquote></li><li><p>所有主机全部配置内核转发功能</p><pre><code class="shell">sudo vi /etc/sysctl.conf# sysctl settings are defined through files in# /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.## Vendors settings live in /usr/lib/sysctl.d/.# To override a whole file, create a new file with the same in# /etc/sysctl.d/ and put new settings there. To override# only specific settings, add a file with a lexically later# name in /etc/sysctl.d/ and put new settings there.## For more information, see sysctl.conf(5) and sysctl.d(5).#加入下面这行命令net.ipv4.ip_forward = 1#执行使之生效,看到我们刚才的配置出现证明生效，如果没有生效检查内核版本是否支持IP 转发功能sudo sysctl -p</code></pre></li><li><p>rancher服务器准备</p><p>安装docker环境</p></li></ol><h1 id="部署rancher"><a href="#部署rancher" class="headerlink" title="部署rancher"></a>部署rancher</h1><ol><li>启动rancher容器</li></ol><pre><code class="shell">#这里操作都是rancher服务器上，也就是10.15.0.10#创建目录保存rancher数据mkdir -p /opt/data/rancher_data#启动rancher镜像,这里用的比较新的镜像，可以去github rancher仓库查看docker run -d --privileged -p 80:80 -p 443:443 -v /opt/data/rancher_data:/var/lib/rancher --restart=always --name  rancher-2.7.5 rancher/rancher:v2.7.5</code></pre><ol start="2"><li><p>访问<a href="http://10.15.0.10/">http://10.15.0.10</a></p></li><li><p>可以看到页面是这样的，然后根据它的提示进入系统</p><p><img src="/images/k8s08.png" alt="rancher_idnex"></p></li></ol><h1 id="部署K8S集群"><a href="#部署K8S集群" class="headerlink" title="部署K8S集群"></a>部署K8S集群</h1><ol><li><p>点击create创建一个集群</p><p><img src="/images/k8s09.png" alt="创建集群"></p></li><li><p>下拉到最下面选择custom自定义</p><p><img src="/images/k8s10.png" alt="选择自定义创建"></p></li><li><p>填写集群名称，其他暂时默认</p><p><img src="/images/k8s11.png" alt="默认设置"></p></li><li><p>首先配置k8s的控制节点，这里我们选择node1（10.15.0.11）作为k8s集群的控制节点。那么，如图中step1中下面全部勾选，step2中要把跳过ssl勾选（这一步不是必须，这里只是演示），然后把下面的命令复制到node1中执行即可。</p><blockquote><p>注意：这里的命令依赖OpenSSL工具，所以需要你现在服务器上下载好</p></blockquote><p><img src="/images/k8s12.png" alt="设置控制节点"></p></li><li><p>配置剩余的工作节点，在step1中只勾选worker选项，step2中勾选跳过ssl。然后复制下面命令在node2，node3中执行即可。</p><p><img src="/images/k8s13.png" alt="设置工作节点"></p></li><li><p>然后等待集群自己配置即可。如果中间出错，可以在控制台将集群删除，然后重新创建，重复上述步骤即可</p></li></ol><p>自此，已经部署完一个可用的k8s集群了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;k8s学习中，我们一直用的是本地docker中提供的k8s组件。这种方式其实就是一个单节点的k8s，只能在学习中使用，一般线上环境我们要么选择云商的k8s服务，要么多机器自己搭建k8s集群。这里，我们本地学习下k8s的搭建过程。本次搭建过程使用rancher搭建，简单快捷（对比二进制搭建来说）。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="https://github/zhuchong6.github.io/categories/k8s/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="k8s" scheme="https://github/zhuchong6.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>CodeReview应该怎么做？</title>
    <link href="https://github/zhuchong6.github.io/2023/07/25/2023-07-25CodeReview/"/>
    <id>https://github/zhuchong6.github.io/2023/07/25/2023-07-25CodeReview/</id>
    <published>2023-07-25T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.954Z</updated>
    
    <content type="html"><![CDATA[<p>对于团队来说，Code Review能显著的提高代码健壮性，减少Bug出现的几率。但是，每次做CodeReview的时候大脑都是一团乱麻，没有一个固定的方法论来指导我们该如何做？</p><p>如果你也是这样的话，下面这张图就可以系统的告诉你高该如何做Code Review。</p><span id="more"></span> <p><img src="/images/code_review_pyramid.svg" alt="code_review金字塔"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于团队来说，Code Review能显著的提高代码健壮性，减少Bug出现的几率。但是，每次做CodeReview的时候大脑都是一团乱麻，没有一个固定的方法论来指导我们该如何做？&lt;/p&gt;
&lt;p&gt;如果你也是这样的话，下面这张图就可以系统的告诉你高该如何做Code Review。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>react学习</title>
    <link href="https://github/zhuchong6.github.io/2023/07/05/2023-07-05react%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github/zhuchong6.github.io/2023/07/05/2023-07-05react%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-05T13:16:30.000Z</published>
    <updated>2023-08-07T00:18:37.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React学习"><a href="#React学习" class="headerlink" title="React学习"></a>React学习</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-React起源"><a href="#1-React起源" class="headerlink" title="1.React起源"></a>1.React起源</h3><p>React起源facebook内部项目，该公司对市场上的JavaScript MVC框架不满意，决定自己写一套，用于架设Instagram网站。做出来之后，发现很好用，就于2013年5月开源了</p><h3 id="2-React与传统MVC关系"><a href="#2-React与传统MVC关系" class="headerlink" title="2.React与传统MVC关系"></a>2.React与传统MVC关系</h3><p>轻量级视图层库。<em>A javascript library for building user interfaces</em></p><p>React是构建页面元素UI的库，可以简单理解为，React将页面分成各个独立的块，每一个块儿就是一个独立组件，各个组件之间可以进行组合、嵌套，就形成了我们的页面。</p><span id="more"></span><h3 id="3-React的特性"><a href="#3-React的特性" class="headerlink" title="3.React的特性"></a>3.React的特性</h3><ol><li>声明式设计-React采用声明范式（只关心数据层改变，无需考虑网页如何渲染），轻松描述应用</li><li>高效-React通过对DOM的模拟(V-DOM)，最大幅度的减少与DOM的交互</li><li>灵活-React可以与已知的库或者框架很好的配合</li><li>JSX-JSX是javascript语法的拓展</li><li>组件- 通过react构建组件，使代码很容易得到复用，能很好的应用在大项目的开发中去</li><li>单向的响应数据流-React实现了单向响应的数据流，减少重复代码，比传统数据绑定更加简单</li></ol><h3 id="4-虚拟DOM"><a href="#4-虚拟DOM" class="headerlink" title="4.虚拟DOM"></a>4.虚拟DOM</h3><p>传统DOM更新场景下，每一个页面对应一个DOM树，每次需要更新页面的时候，需要手动操作DOM去更新。</p><p>虚拟DOM更新场景下，React把真实的DOM树转换成JavaScript对象树，也就是VDOM。通过DIFF算法，将虚拟DOM的change更新到真实DOM中去。</p><h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><p>全局安装create-react-app</p><pre><code class="shell">$ npm install -g create-react-app</code></pre><p>创建一个项目</p><pre><code class="shell">$ create-react-app your-app-name</code></pre><p>如果不想全局安装，可以使用npx</p><pre><code class="shell">$ npx create-react-app your-app-name</code></pre><p>生成的项目目录结构如下：</p><pre><code>|--README.md #使用方法文档|--ndoe_modules #所有依赖安装的目录|--package-lock.json #锁定安装时的包版本号，保证团队的依赖一致|--package.json #|--public #静态公共目录|--src #开发用的源码代码目录</code></pre><blockquote><p>注意这一步会有依赖下载过慢的清况，可以切换到淘宝镜像，具体步骤如下：</p><ol><li>执行 npm i -g nrm 下载nrm切换镜像工具</li><li>执行nrm ls 查看所有镜像源</li><li>执行nrm use taobao 切换到淘宝源</li></ol></blockquote><h2 id="编写第一个react-app"><a href="#编写第一个react-app" class="headerlink" title="编写第一个react app"></a>编写第一个react app</h2><ol><li><p>首先删除src目录下的所有文件</p></li><li><p>在src目录下新建一个index.js文件</p></li><li><p>在index文件中写入如下代码</p><pre><code class="react">//从react的包中引入React。//只要你写react，这个包必须引入，因为react的jsx语法，需要React解析import React from &#39;react&#39;//ReacDOM可以帮助我们把React组件渲染到页面上去import ReactDOM from &#39;react-dom&#39;ReactDOM.render(//JSX语法标签&lt;h1&gt;hello react&lt;/h1&gt;, //确定要渲染的地方document.getElementById(&quot;root&quot;))</code></pre></li><li><p>执行命令<code>npm start</code>,会打开浏览器，显示出hello react文字</p></li></ol><h2 id="JSX语法与组件"><a href="#JSX语法与组件" class="headerlink" title="JSX语法与组件"></a>JSX语法与组件</h2><h3 id="1-JSX语法"><a href="#1-JSX语法" class="headerlink" title="1.JSX语法"></a>1.JSX语法</h3><p>JSX将HTML语法直接加入到JavaScript代码中，再通过翻译器转换到纯JavaScript后由浏览器运行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript代码，不会带来任何副作用，编译的过程由Babel的JSX编译器实现</p><blockquote><p><a href="https://reactjs.org/docs/hello-world.html">Https://reactjs.org/docs/hello-world.html</a></p></blockquote><h3 id="2-Class组件"><a href="#2-Class组件" class="headerlink" title="2.Class组件"></a>2.Class组件</h3><p>ES6的加入让JavaScript直接支持使用Class来定义一个类，react创建组件的方式就是使用类的继承，<code>ES6 class</code>是目前官方推荐的使用方式，它使用ES6的标准语法构建，看一下代码：</p><pre><code class="react">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;//创建一个组件，组件必须继承React.Component类//注意：首字母大写class App extends React.Component&#123;    render()&#123;          //这个节点不能有任何兄弟节点，必须是根节点          //如果要换行可以使用（）包裹，成为一个整体，否则报错        return &lt;h1&gt;hello react component&lt;/h1&gt;    &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;root&quot;))</code></pre><h3 id="3-函数式组件"><a href="#3-函数式组件" class="headerlink" title="3.函数式组件"></a>3.函数式组件</h3><pre><code class="react">import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39; //函数式组件,16.8之前函数式组件无法包含状态，所以使用类组件多；之后能够包含状态，推荐函数式组件//1.和类组件一样，div必须是根节点//2.和类组件一样函数名称必须大写//3.和类组件一样JSX如果换行，必须要（）包裹成一个整体function App()&#123;    return (        &lt;div&gt;            hello function component        &lt;/div&gt;    )&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;root&quot;))</code></pre><h4 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;import ReactDOM from &#39;react-dom&#39; //类组件class Navibar extends Component &#123;    render() &#123;      return (        &lt;div&gt;          Navibar        &lt;/div&gt;      )    &#125;&#125;//普通函数组件function Swiper()&#123;    return (        &lt;div&gt;Swiper&lt;/div&gt;    )&#125;//箭头函数组件const Tabbar = ()=&gt;&#123;    return (        &lt;div&gt;          Tabbar        &lt;/div&gt;      )&#125;//箭头函数另一种写法const Tabbar2 = ()=&gt;&lt;div&gt;Tabbar2&lt;/div&gt;//App组件，包含四个子组件class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;Navibar /&gt;        &lt;Swiper /&gt;        &lt;Tabbar /&gt;        &lt;Tabbar2 /&gt;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;root&quot;))</code></pre><h3 id="4-组件样式"><a href="#4-组件样式" class="headerlink" title="4.组件样式"></a>4.组件样式</h3><p>在react中<code>&#123;&#125;</code>包裹的是表达式，页面展示的是里面表达式计算的值。</p><blockquote><p>react注释写法优点特殊,就是js的注释，在用{}包裹起来</p><p>{&#x2F;&#x2F;} 或者{&#x2F;**&#x2F;}</p></blockquote><ul><li><p>行内样式</p><p>想给虚拟DOM添加行内样式，需要使用表达式传入样式对象的方式来实现：</p><pre><code class="react">//注意：这里的两个花括号，外层表示我们要在JSX插入JS，内层表示一个js对象//html里面font-size属性，在这类转成fontSize这种驼峰风格的，这个需要注意一下&lt;p style=&#123;&#123;color:'red', fontSize:'14px'&#125;&#125;&gt;&lt;/p&gt;</code></pre><p>行内样式需要写入一个样式对象，这个样式对象的位置可以放在很多地方，例如<code>render</code>函数里，组件原型上，外链的js上</p></li><li><p>使用Class</p><p>其实我们大多数情况还是在大量的为元素添加类名，需要注意的是，<code>class</code>需要专门写成<code>className</code>（因为是写在js代码中的，class在js是关键字；同样的label标签的for属性也是一样）</p><pre><code class="react">&lt;p className=&quot;hello&quot;&gt;hello react&lt;/p&gt;</code></pre><blockquote><p>注意：</p><p>class &#x3D;&#x3D;&#x3D;》className</p><p>for&#x3D;&#x3D;&#x3D;》htmlFor</p></blockquote></li></ul><p><em><strong>react中比较推荐使用行内样式，因为react觉得每个组件是一个独立的整体</strong></em></p><h3 id="5-事件处理"><a href="#5-事件处理" class="headerlink" title="5.事件处理"></a>5.事件处理</h3><h4 id="5-1-绑定事件"><a href="#5-1-绑定事件" class="headerlink" title="5.1 绑定事件"></a>5.1 绑定事件</h4><p>采用on+事件名的方式来绑定事件。注意，这里和原生的事件是有区别的，原生的事件全是小写<code>onclick</code>，React采取驼峰式写法<code>onClick</code>，<strong>React事件不是原生事件，是合成事件</strong></p><h4 id="5-2-事件handler写法"><a href="#5-2-事件handler写法" class="headerlink" title="5.2 事件handler写法"></a>5.2 事件handler写法</h4><ul><li>直接在render中写行内的箭头函数（不推荐）</li><li>在组件内使用箭头函数定义一个方法（推荐）</li><li>直接在组件内定义一个非箭头函数的方法，然后再render里直接使用<code>onClick=&#123;this.handlerFuntioin.bind(this)&#125;</code>（不推荐）</li><li>直接在组件定义一个非箭头函数方法，然后再construct方法里<code>bind(this)</code>（推荐）</li></ul><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  a = 1000  render() &#123;    return (      &lt;div&gt;        &lt;input&gt;&lt;/input&gt;            &#123;//不推荐&#125;        &lt;button onClick=&#123;()=&gt;&#123;          console.log(1111111, this.a)         &#125;&#125;&gt;add1&lt;/button&gt;          &#123;//不推荐&#125;        &lt;button onClick=&#123;this.Add2.bind(this)&#125;&gt;add2&lt;/button&gt;          &#123;//推荐&#125;        &lt;button onClick=&#123;this.Add3&#125;&gt;add3&lt;/button&gt;          &#123;//推荐这种方式&#125;        &lt;button onClick=&#123;()=&gt;&#123;          this.Add4()        &#125;&#125;&gt;add4&lt;/button&gt;      &lt;/div&gt;    )  &#125;  Add2()&#123;    console.log(2222, this.a)  &#125;  //箭头函数的this和App一致            Add3 = ()=&gt;&#123;    console.log(3333,this.a)  &#125;  Add4()&#123;    console.log(4444,this.a)  &#125;&#125;</code></pre><h4 id="5-3-Event-对象"><a href="#5-3-Event-对象" class="headerlink" title="5.3 Event 对象"></a>5.3 Event 对象</h4><p>和浏览器一样，事件handler会被传入一个<code>event</code>对象，这个对象和普通浏览器对象<code>event</code>对象所包含的方法属性基本一致。不同的是，React中的<code>event</code>对象不是浏览器提供的，而是它内部自己构建的，它同样具有<code>event.stopPropagation</code>、<code>event.preventDefault</code>这种常用的方法。</p><h3 id="6-Ref的应用"><a href="#6-Ref的应用" class="headerlink" title="6.Ref的应用"></a>6.Ref的应用</h3><h4 id="6-1-给标签设置ref-x3D-”username”"><a href="#6-1-给标签设置ref-x3D-”username”" class="headerlink" title="6.1 给标签设置ref&#x3D;”username”"></a>6.1 给标签设置ref&#x3D;”username”</h4><p>通过this.refs.username, ref可以获得应用的真实dom,this.refs.username.value获取对象的值</p><h4 id="6-2-给组件设置ref-x3D-”username”"><a href="#6-2-给组件设置ref-x3D-”username”" class="headerlink" title="6.2 给组件设置ref&#x3D;”username”"></a>6.2 给组件设置ref&#x3D;”username”</h4><p>通过this.refs.username, ref可以获得组件的对象</p><h4 id="6-3-新的写法"><a href="#6-3-新的写法" class="headerlink" title="6.3 新的写法"></a>6.3 新的写法</h4><pre><code class="react">myref = React.createRef()&lt;div ref=&#123;myref&#125;&gt;hello&lt;/div&gt;//访问this.myref.current获取到真实dom节点对象</code></pre><h2 id="组件数据挂载方式"><a href="#组件数据挂载方式" class="headerlink" title="组件数据挂载方式"></a>组件数据挂载方式</h2><h3 id="1-状态"><a href="#1-状态" class="headerlink" title="1. 状态"></a>1. 状态</h3><p>状态就是组件描述某种显示的数据，由组件自己设置和更改，也就是说组件自己维护，使用状态的目的就是为了在不同状态下使组件的显示不同（自己设置的）。</p><h4 id="定义state"><a href="#定义state" class="headerlink" title="定义state"></a>定义state</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  //state这个名称是固定的  //方法一：通过构造器构造state  constructor()&#123;    super()    this.state=&#123;      showLabel:true    &#125;  &#125;  //  方法二：直接通过对象修改//  state =&#123;//    showLabel:true//  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;欢迎来到react世界1&lt;/h1&gt;        &lt;button &gt;&#123;this.state.showLabel?&quot;收藏&quot;:&quot;取消收藏&quot;&#125;&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h4 id="修改state"><a href="#修改state" class="headerlink" title="修改state"></a>修改state</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  state =&#123;    showLabel:true  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;欢迎来到react世界1&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;&#123;          //state的修改只能通过setState函数修改，其他方式无效          this.setState(&#123;            showLabel: !this.state.showLabel          &#125;,()=&gt;&#123;            console.log(&quot;这个是回调函数，表明state同步完成了，渲染出了dom，后续如果有需要操作dom的可以在这里进行&quot;)          &#125;)          if(this.state.showLabel)&#123;            console.log(&quot;收藏逻辑&quot;)          &#125;else&#123;            console.log(&quot;取消收藏逻辑&quot;)          &#125;        &#125;&#125;&gt;&#123;this.state.showLabel?&quot;收藏&quot;:&quot;取消收藏&quot;&#125;&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="2-属性-props"><a href="#2-属性-props" class="headerlink" title="2. 属性(props)"></a>2. 属性(props)</h3><p><code>props</code>是正常外部传入的，组件内部也可以通过一些方式来初始化设置，属性不能被组件自己更改，但是你可以通过父组件主动重新渲染的方式来传入新的<code>props</code>。</p><p>属性是描述性质、特点的，组件自己不能随意更改。</p><p>之前的代码里有<code>props</code>的简单使用，总而言之，在使用一个组件的时候，可以把参数放在标签属性中，所有的属性都会作为组件<code>props</code>对象的键值。通过箭头函数创建的组件，需要通过函数的参数来接收<code>props</code>:</p><blockquote><p>1)在组件上通过key&#x3D;valuex 写属性，通过this.props获取属性，这样组件的可复用性提高了。</p><p>2)注意在传参数时候，如果写成isShow&#x3D;”true” 那么这是一个字符串。 如果写成isShow&#x3D;{true}，这个世布尔值</p><p>3){…对象} 展开写法，<code>&lt;Navibar title=&#123;obj.title&#125; leftShow=&#123;obj.leftShow&#125;&gt;</code>和<code>&lt;Navibar &#123;...obj&#125;/&gt;</code>等价</p><p>4)默认属性值</p><pre><code class="react">//通过设置类属性设置属性的默认值//第一种方式直接在组件外面使用类名.defaultProps方式*.defaultProps = &#123;  name:&quot;1231&quot;&#125;//或，类组件推荐这种方式，方法组件推荐上面的方式//第二种方式，在组件内部使用static defaultProps = &#123;  name:&quot;1231&quot;&#125;</code></pre><p>4)prop-types 属性验证</p><pre><code class="react">//通过设置类属性设置属性的验证//属性从组件传入的时候需要对类型进行验证，默认的类型react已经提供好了import PropTypes from &#39;prop-types&#39;//类属性，在组外部使用*.propTypes = &#123;  title: PropTypes.string,  showLeft: PropTypes.bool,&#125;//或，类组件推荐这种方式，方法组件推荐上面的方式//类属性，在组件内部使用static propTypes = &#123;  title: PropTypes.string,  showLeft: PropTypes.bool,&#125;</code></pre></blockquote><p><strong>⚠️插槽：是属性的特殊属性。</strong></p><p><strong>作用：</strong></p><p>**1.一定程度上可以减少父子通信 **</p><p>**2.复用（比如说轮播内容，第一个地方次轮播图片，第二个地方轮播视频，这时候就可以把轮播内容放到轮播组件插槽中，轮播组件只需要控制轮播方式而不关心DOM结构） **</p><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;class Child extends Component&#123;  render() &#123;    return (      &lt;div&gt;        Child        &#123;/* 插槽 */&#125;        &#123;/* 固定写法，含义是将组件内包裹的内容挂载到this.props.children属性上 */&#125;        &#123;this.props.children&#125;      &lt;/div&gt;    )  &#125; &#125;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;        App        &lt;Child&gt;          &lt;div&gt;1111&lt;/div&gt;        &lt;/Child&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h3 id="3-属性VS状态"><a href="#3-属性VS状态" class="headerlink" title="3. 属性VS状态"></a>3. 属性VS状态</h3><p>相似点：都是纯js对象，都会触发render更新，都具有确定性（状态&#x2F;属性相同，结果相同）</p><p>不同点：</p><ol><li>属性能从父组件获取，状态不能</li><li>属性可以由父组件修改，状态不能</li><li>属性能在内部设置默认值，状态也可以，设置方式不一样</li><li>属性不在组件内部修改，状态要在组件内部修改</li><li>属性能设置自组件初始值，状态不能</li><li>属性可以修改自组件的值，状态不能</li></ol><p><code>state</code>的主要作用是用于组件保存、控制、修改自己的可变状态。<code>state</code>在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为<code>state</code>是一个局部、只能被组件自身控制的数据源。<code>state</code>中状态可以通过<code>this.setState</code>方法进行更新，<code>setState</code>会导致组件的重新渲染</p><p><code>props</code>主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非，外部组件主动传入新的<code>props</code>，否则组件的<code>props</code>永远不变。</p><p>没有<code>state</code>的组件叫做<em><strong>无状态组件（stateless component）</strong></em>，设置了<code>state</code>的组件叫做<em><strong>有状态组件（stateful component）</strong></em>。因为状态回带来管理的复杂性，我们尽量多写无状态组件，尽量少些有状态的组件。这样回降低代码维护的难度，也会在一定程度上增强组件的可复用性。</p><h3 id="4-渲染数据"><a href="#4-渲染数据" class="headerlink" title="4. 渲染数据"></a>4. 渲染数据</h3><h4 id="4-1-列表渲染"><a href="#4-1-列表渲染" class="headerlink" title="4.1 列表渲染"></a>4.1 列表渲染</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  constructor()&#123;    super()    this.state = &#123;      list:[&#123;        id:1,        name:&quot;1231&quot;      &#125;,&#123;        id:2,        name:&quot;eee&quot;      &#125;,&#123;        id:3,        name:&quot;rrr&quot;      &#125;,]    &#125;  &#125;  render() &#123;    return (      &lt;div&gt;        //通过js的方式渲染列表，key是唯一键，必须要加        &#123;this.state.list.map(item=&gt;&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p>React的高效依赖于Virtual-DOM，尽量不操作DOM。对于列表元素来说会有一个问题：元素可能在一个列表中改变位置，值不变。要实现这个操作，只需要交换一下DOM位置就行了，但是React并不知道我们只是改变了元素位置，所以它会重新渲染元素（再执行Virtual-DOM）,这样会大大增加DOM操作。但是，如果给每个元素加上标识，React就可以知道这两个元素只是交换了位置，这个标识就是key，这个key必须是唯一的标识</p><blockquote><p>小技巧：</p><p>在列表渲染的时候，我们需要把要渲染的数据备份一份，然后每次操作副本不动原始数据，这样原始数据我们就不会修改，深拷贝推荐下面的方式：</p><p>let list&#x3D;[1,2,3,4]</p><p>let newList&#x3D;list.slice()&#x2F;&#x2F;副本</p></blockquote><h4 id="4-2-条件渲染"><a href="#4-2-条件渲染" class="headerlink" title="4.2 条件渲染"></a>4.2 条件渲染</h4><pre><code class="react">//三目运算符&#123;this.state.dataList.length===0 ? &lt;div&gt;暂&lt;/div&gt; : null&#125;//断路法&#123;this.state.dataList.length===0 &amp;&amp; &lt;div&gt;暂&lt;/div&gt;&#125;</code></pre><h4 id="4-3-dangerouslySetInnerHtml"><a href="#4-3-dangerouslySetInnerHtml" class="headerlink" title="4.3 dangerouslySetInnerHtml"></a>4.3 dangerouslySetInnerHtml</h4><p>对于富文本创建的内容，后台拿到的数据是这样的：</p><pre><code class="react">content = &quot;&lt;p&gt;Hello React&lt;/p&gt;&quot;</code></pre><p>处于安全考虑，React当中所有的表达式都会被转义，如果直接输入，标签会被当成文本。这个时候就需要使用<code>dangerouslySetInnerHtml</code>属性，它允许我们动态设置<code>innerHTML</code></p><pre><code class="react">&lt;div dangerouslySetInnerHTML=&#123;&#123;    //__html固定，__html: "<p>Hello React</p>"&#125;&#125;&gt;</code></pre><h2 id="表单中受控组件与非受控组件"><a href="#表单中受控组件与非受控组件" class="headerlink" title="表单中受控组件与非受控组件"></a>表单中受控组件与非受控组件</h2><h3 id="1-非受控组件"><a href="#1-非受控组件" class="headerlink" title="1. 非受控组件"></a>1. 非受控组件</h3><p>React要编写一个非受控组件，可以使用<code>ref</code>来从DOM节点中获取表单数据，就是<em><strong>非受控节点</strong></em>。</p><p>例如：下面代码使用非受控组件接受一个表单的值</p><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  username = React.createRef()  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;登录页&lt;/h1&gt;        &#123;/* 非受控的组件，value不受控制，需要修改成defaultValue */&#125;        &lt;input type=&#39;text&#39;  ref=&#123;this.username&#125;         // value=&quot;默认值&quot;        defaultValue=&#123;&quot;默认值&quot;&#125; &gt;&lt;/input&gt;        &lt;button onClick=&#123;()=&gt;&#123;          console.log(this.username.current.value)        &#125;&#125;&gt;登录&lt;/button&gt;        &lt;button onClick=&#123;()=&gt;&#123;          this.username.current.value=&quot;&quot;        &#125;&#125;&gt;重置&lt;/button&gt;        &#123;/* 非受控组件在这里会有问题，只有第一次能传值，后续值不会改变，不会触发render更新 */&#125;        &#123;/* &lt;ChileComponent myvalue=&#123;this.username.current.value&#125;&gt;&lt;/ChileComponent&gt; */&#125;      &lt;/div&gt;    )  &#125;&#125;</code></pre><p>因为非受控组件将真实数据存储在DOM节点中，所以在非受控组件中，有时候反而更容易集成React和非React代码。如果你不介意代码美观性，并希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p><blockquote><p>默认值的问题</p><p>在React渲染生命周期的时候，表单元素上的<code>value</code>将会覆盖DOM节点中的值，在非受控组件中，你经常希望React能赋予组件一个初始值，但是不去控制后续的更新。在这种情况下，你可以指定一个<code>defaultValue</code>属性，而不是<code>value</code>属性。</p></blockquote><h3 id="2-受控组件"><a href="#2-受控组件" class="headerlink" title="2. 受控组件"></a>2. 受控组件</h3><p>在HTML中，表单元素（如input、textarea和select）通常自己维护<code>state</code>，并根据用户输入进行更新。而在React中，可变状态（mutable state）通常保存在组件state属性中，并且只能通过使用<code>setState</code>来更新。</p><p>我们可以把两者结合起来，使React的state成为<strong>唯一的数据源</strong>，渲染表单的React组件还控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做<em><strong>受控组件</strong></em>。</p><p>下面就是一个受控组件的案例：</p><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123; state=&#123;   username:&quot;react&quot; &#125; render() &#123;   return (     &lt;div&gt;       &lt;h1&gt;登录页&lt;/h1&gt;            &#123;/* input是一个受控组件 */&#125;       &lt;input type=&#39;text&#39;          value=&#123;this.state.username&#125;         onChange=&#123;(event)=&gt;&#123;         // console.log(event.target.value)         this.setState(&#123;           username: event.target.value         &#125;)       &#125;&#125;&gt;&lt;/input&gt;       &lt;button onClick=&#123;()=&gt;&#123;         console.log(this.state.username)       &#125;&#125;&gt;登录&lt;/button&gt;       &lt;button onClick=&#123;()=&gt;&#123;         this.setState(&#123;           username:&#39;&#39;         &#125;)       &#125;&#125;&gt;重置&lt;/button&gt;       &#123;/* 方便传递状态给子组件 */&#125;       &lt;ChileComponent myvalue=&#123;this.username.current.value&#125;&gt;&lt;/ChileComponent&gt;     &lt;/div&gt;   ) &#125;&#125;</code></pre><blockquote><p>注意：</p><p>广义范围内，React组件的数据渲染是否被调用者传递的<code>props</code>完全控制，控制则为受控组件，否则为非受控组件。</p></blockquote><h2 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h2><h3 id="1-父子组件通信"><a href="#1-父子组件通信" class="headerlink" title="1. 父子组件通信"></a>1. 父子组件通信</h3><h4 id="1-1-传递数据（父传子）和传递回调方法（子传父）"><a href="#1-1-传递数据（父传子）和传递回调方法（子传父）" class="headerlink" title="1.1 传递数据（父传子）和传递回调方法（子传父）"></a>1.1 传递数据（父传子）和传递回调方法（子传父）</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;class Navibar extends Component &#123;  render() &#123;    return (      &lt;div style=&#123;&#123;background:"red"&#125;&#125;&gt;        &lt;button onClick=&#123;()=&gt;&#123;            // 获取自定义的属性            //这个获取的是一个函数，如果需要执行，需要在后面加上()            let cc = this.props.cc            console.log(&quot;点击之后通知父组件App，让App改变isShow的状态，从而改变Sidebar组件的显隐&quot;,cc )            //子传父，通过父组件属性传递过来的回调函数调用            cc()//执行父组件传过来的函数        &#125;&#125;&gt;子组件click&lt;/button&gt;        &lt;span&gt;Navibar&lt;/span&gt;      &lt;/div&gt;    )  &#125;&#125;class Sidebar extends Component &#123;    render() &#123;      return (        &lt;div style=&#123;&#123;background:"yellow", width:"200px"&#125;&#125;&gt;            &lt;ul&gt;                 &lt;li&gt;11111&lt;/li&gt;                &lt;li&gt;11111&lt;/li&gt;                &lt;li&gt;11111&lt;/li&gt;                &lt;li&gt;11111&lt;/li&gt;                &lt;li&gt;11111&lt;/li&gt;                &lt;li&gt;11111&lt;/li&gt;                &lt;li&gt;11111&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;      )    &#125;  &#125;export default class App extends Component &#123;    state=&#123;        isShow: true    &#125;  render() &#123;    return (      &lt;div&gt;        &#123;/* 自定义一个属性，但是不执行，执行时机是子组件自己决定的 */&#125;        &#123;/* 父传子，属性传递 */&#125;        &lt;Navibar cc=&#123;()=&gt;&#123;            console.log(&quot;父组件中自定义一个属性，传入一段函数定义&quot;)            this.changeSideBar()        &#125;&#125;/&gt;        &#123;/* &lt;button onClick=&#123;()=&gt;&#123;            this.changeSideBar()        &#125;&#125; &gt;父组件click&lt;/button&gt; */&#125;        &#123;this.state.isShow &amp;&amp; &lt;Sidebar /&gt;&#125;      &lt;/div&gt;    )  &#125;  changeSideBar = ()=&gt;&#123;    this.setState(&#123;        isShow: !this.state.isShow    &#125;)  &#125;&#125;</code></pre><h4 id="1-2-ref标记（父组件拿到子组件的引用，从而调用子组件的方法）"><a href="#1-2-ref标记（父组件拿到子组件的引用，从而调用子组件的方法）" class="headerlink" title="1.2 ref标记（父组件拿到子组件的引用，从而调用子组件的方法）"></a>1.2 ref标记（父组件拿到子组件的引用，从而调用子组件的方法）</h4><p>在父组件中清楚子组件的input输入框的value值。<strong>this.refs.form.reset()</strong></p><h3 id="2-非父子组件通信方式"><a href="#2-非父子组件通信方式" class="headerlink" title="2. 非父子组件通信方式"></a>2. 非父子组件通信方式</h3><h4 id="2-1-状态提升（中间人模式）"><a href="#2-1-状态提升（中间人模式）" class="headerlink" title="2.1 状态提升（中间人模式）"></a>2.1 状态提升（中间人模式）</h4><p>React中状态提升意思是，多个组件需要共享的状态提升到它最近的父组件上，在父组件上改变这个状态，然后在通过props分发给子组件</p><h4 id="2-2-发布订阅模式"><a href="#2-2-发布订阅模式" class="headerlink" title="2.2 发布订阅模式"></a>2.2 发布订阅模式</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;export default class App extends Component &#123;  render() &#123;    return (      &lt;div&gt;App&lt;/div&gt;    )  &#125;&#125;//处理中心var bus = &#123;    list:[],    //订阅    subscribe(callback)&#123;        console.log(callback)        this.list.push(callback)    &#125;,     //发布    publish(text)&#123;        //遍历所有的list，执行回调函数        console.log(this.list)        this.list.forEach(callback=&gt;&#123;            callback &amp;&amp; callback(text)        &#125;)    &#125;,&#125;//订阅bus.subscribe((value)=&gt;&#123;    console.log(&quot;第一次订阅&quot;, value)&#125;)bus.subscribe((value)=&gt;&#123;    console.log(&quot;第二次订阅&quot;, value)&#125;)//发布bus.publish(&quot;发布的时候传的形参&quot;)</code></pre><h4 id="2-3-context状态树传参"><a href="#2-3-context状态树传参" class="headerlink" title="2.3 context状态树传参"></a>2.3 context状态树传参</h4><pre><code class="react">import React, &#123; Component &#125; from &#39;react&#39;//1.先定义全局的context对象 const GlobalContext = React.createContext()//2.设置生产者 export default class App extends Component &#123;  state=&#123;    name:&quot;张三&quot;  &#125;  render() &#123;    return (      //包裹根节点      &lt;GlobalContext.Provider value=&#123;&#123;        call: "打电话",        phone: "手机号",        name: this.state.name,        //只能通过这种方式让父组件更新，这样才能重新渲染，重新执行render函数        //在消费组件内直接修改，不能重新渲染，不能出发页面更新        changeName:(value)=>&#123;          this.setState(&#123;            name: value          &#125;)         &#125;,      &#125;&#125;&gt;        &lt;div&gt;          App          &lt;Child&gt;&lt;/Child&gt;          &lt;Child2&gt;&lt;/Child2&gt;        &lt;/div&gt;      &lt;/GlobalContext.Provider&gt;    )  &#125;&#125;//3.设置消费者class Child extends Component&#123;  render() &#123;    return (      &lt;GlobalContext.Consumer&gt;        &#123;          (value)=&gt;&#123;            return (              //这里才是根节点内容              &lt;div style=&#123;&#123;                background:"yellow"              &#125;&#125;&gt;                Child组件1                &lt;button onClick=&#123;()=&gt;&#123;                  value.changeName(&quot;李四&quot;)                &#125;&#125;&gt;改变name值为李四&lt;/button&gt;                &lt;p&gt;&#123;value.name&#125;&lt;/p&gt;                &lt;p&gt;&#123;value.phone&#125;&lt;/p&gt;                &lt;p&gt;&#123;value.call&#125;&lt;/p&gt;              &lt;/div&gt;            )          &#125;        &#125;      &lt;/GlobalContext.Consumer&gt;    )  &#125;&#125;class Child2 extends Component&#123;  render() &#123;    return (      &lt;GlobalContext.Consumer&gt;        &#123;          (value)=&gt;&#123;            return (              //这里才是根节点内容              &lt;div style=&#123;&#123;                background:"red"              &#125;&#125;&gt;                Child组件2                &lt;p&gt;&#123;value.name&#125;&lt;/p&gt;                &lt;p&gt;&#123;value.phone&#125;&lt;/p&gt;                &lt;p&gt;&#123;value.call&#125;&lt;/p&gt;              &lt;/div&gt;            )          &#125;        &#125;      &lt;/GlobalContext.Consumer&gt;    )  &#125;&#125;</code></pre><h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><h3 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="1. 初始化阶段"></a>1. 初始化阶段</h3><blockquote><ul><li><p>componentWillMount：render之前最后一次修改状态的机会 <strong>新版本已废弃，直接替换为使用consructor</strong></p></li><li><p>render：只能访问this.props和this.state，不允许修改状态和DOM输出</p></li><li><p>componentDidMount：成功render并渲染完成真实DOM之后触发，可以修改DOM</p><pre><code class="react">componentDidMount()&#123;  console.log(&quot;mount&quot;)  //数据请求axios  //订阅函数的调用  // setInterval  // 基于创建完的DOM进行一些初始化，比如说一些初始化类库之类的，例如：BetterScroll库&#125;</code></pre></li></ul></blockquote><h3 id="2-运行中阶段"><a href="#2-运行中阶段" class="headerlink" title="2. 运行中阶段"></a>2. 运行中阶段</h3><blockquote><ul><li><p>componentWillReceiveProps：父组件修改属性的时候触发 <strong>新版本已废弃</strong></p></li><li><p>shouldComponentUpdate：返回false会阻止render调用</p><pre><code class="react">//优化组件更新操作shouldComponentUpdate(nextProps, nextState) &#123;     //return true 应该更新    //return false 阻止更新    // this.state 老状态    // nextState 新状态    if(JSON.stringify(this.state) !== JSON.stringify(nextState))&#123;      return true    &#125;    return false&#125;</code></pre></li><li><p>componentWillUpdate：不能修改属性和状态 <strong>新版本已废弃</strong></p></li><li><p>render：只能访问this.props和this.state，不允许修改状态和DOM输出</p></li><li><p>componentDidUpdate：能访问之前的props和state，可以修改DOM</p><pre><code class="react">componentDidUpdate(preProps, preState)&#123;  //preProps 老的属性  //preState 老的状态&#125;</code></pre></li></ul></blockquote><h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3. 销毁阶段"></a>3. 销毁阶段</h3><blockquote><ul><li>componentWillUnmount：在删除组件之前进行清理操作，比如计时器和事件监听</li></ul></blockquote><h4 id="老生命周期的问题"><a href="#老生命周期的问题" class="headerlink" title="老生命周期的问题"></a>老生命周期的问题</h4><ol><li>componentWillMount，在ssr中这个方法会被多次调用，所以会重复触发多次，同时在这里如果绑定事件，将无法解绑，导致内存泄漏，变得不够安全和高效，从而逐步废弃</li><li>componentWillReceiveProps，外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求</li><li>componentWillUpdate，更新前记录DOM状态，可能会做一些处理，与componentDidUpdate相隔时间过长，会导致状态不太可信</li></ol><h4 id="新生命周期的替代"><a href="#新生命周期的替代" class="headerlink" title="新生命周期的替代"></a>新生命周期的替代</h4><ol><li>getDerivedStateFromProps，第一次组件初始化，以及后续组件更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的state，返回null说明不需要在这里更新state</li><li>getSnapshotBeforeUpdate，取代了componentWillUpdate，触发事件为update发生的时候，<strong>在render之后，DOM渲染之前</strong>返回一个值，作为componentDidUpdate的第三个参数。</li></ol><h3 id="4-react中性能优化"><a href="#4-react中性能优化" class="headerlink" title="4. react中性能优化"></a>4. react中性能优化</h3><h4 id="4-1-shouldComponentUpdate"><a href="#4-1-shouldComponentUpdate" class="headerlink" title="4.1 shouldComponentUpdate"></a>4.1 shouldComponentUpdate</h4><p>控制组件自身或者子组件是否需要更新，尤其在子组件非常多的情况下，需要进行优化</p><h4 id="4-2-PureComponent"><a href="#4-2-PureComponent" class="headerlink" title="4.2 PureComponent"></a>4.2 PureComponent</h4><p>PureComponent会帮你比较新props和旧的props，新的state和旧的state（值相等、或者对象含有相同的属性、且属性值相等），决定shouldComponentUpdate返回true或者false，从而决定是否要呼叫render函数。</p><blockquote><p>注意⚠️：</p><p>如果你的state或者props永远都在变，那么PureComponent并不会更快，因为shallowEqual需要花时间。</p></blockquote><pre><code class="react">import React, &#123;  PureComponent &#125; from &#39;react&#39;export default class App extends PureComponent &#123;  render() &#123;    console.log(&quot;render&quot;)    return (      &lt;div&gt;App&lt;/div&gt;    )  &#125;&#125;</code></pre><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><h3 id="1-使用Hooks的理由"><a href="#1-使用Hooks的理由" class="headerlink" title="1. 使用Hooks的理由"></a>1. 使用Hooks的理由</h3><ol><li>高阶组件为了复用，导致代码层级复杂</li><li>生命周期复杂</li><li>写成function组件，无状态组件，因为需要状态，又改成了class，成本高</li></ol><h3 id="2-useState（保存组件状态）"><a href="#2-useState（保存组件状态）" class="headerlink" title="2. useState（保存组件状态）"></a>2. useState（保存组件状态）</h3><pre><code class="react">const [state, setState] = useState(initialState)</code></pre><p>一个小demo：</p><pre><code class="react">import React, &#123; useState &#125; from &#39;react&#39;export default function App() &#123;  var obj = useState(&quot;zzz&quot;)  //是一个数组，第一个参数是初始化的值，第二个参数是一个函数  console.log(obj)  //这个写法就是es6数组解构赋值，和上面等价  const [name, setName] = useState(&quot;zzz&quot;)  const [age, setAge] = useState(28)    return (    &lt;div&gt;      &lt;button onClick=&#123;()=&gt;&#123;        // console.log(name)        setName(&quot;修改的新name值&quot;)        setAge(18)      &#125;&#125;&gt;click&lt;/button&gt;      App-&#123;name&#125;-&#123;age&#125;    &lt;/div&gt;  )&#125;</code></pre><h3 id="3-useEffect（处理副作用）和useLayoutEffect（同步执行副作用）"><a href="#3-useEffect（处理副作用）和useLayoutEffect（同步执行副作用）" class="headerlink" title="3. useEffect（处理副作用）和useLayoutEffect（同步执行副作用）"></a>3. useEffect（处理副作用）和useLayoutEffect（同步执行副作用）</h3><p><em><strong>Function Component不存在生命周期，所以不要把Class Component的生命周期搬过来对号入坐</strong></em></p><pre><code class="react">useEffect(()=&gt;&#123;  //effect  return ()=&gt;&#123;    //cleanup  &#125;&#125;,[依赖的状态；空数组，表示不依赖])</code></pre><p><strong>不要对Dependencies撒谎，如果你明确使用了某个变量，却没有声明在依赖中，你等于向React撒谎了。后果就是，当依赖的变量改变，useEffect不会再次执行，eslint也会警告</strong></p><p>有依赖的demo：</p><pre><code class="react">import React, &#123; useEffect, useState &#125; from &#39;react&#39;export default function App() &#123;  const [name, setName] = useState(&quot;asda&quot;)  //这里使用了name，那么依赖必须要传，不然只有第一次首字母大写，后续修改name值都不会变  useEffect(()=&gt;&#123;    //首字母大写    var newName = name.substring(0,1).toUpperCase()+name.substring(1)     setName(newName)  &#125;, [name])  return (    &lt;div&gt;      &lt;button onClick=&#123;()=&gt;&#123;        setName(&quot;zzzzada&quot;)      &#125;&#125;&gt;click&lt;/button&gt;      App-&#123;name&#125;    &lt;/div&gt;  )&#125;</code></pre><p>没有依赖的demo：</p><pre><code class="react">import React, &#123; useEffect, useState &#125; from &#39;react&#39;export default function App() &#123;  const [isCreated, setIsCreated] = useState(true)  return (    &lt;div&gt;      App      &lt;button onClick=&#123;()=&gt;&#123;        setIsCreated(false)      &#125;&#125;&gt;点击销毁子组件&lt;/button&gt;      &#123;isCreated&#125;      &#123;isCreated &amp;&amp; &lt;Child  /&gt;&#125;    &lt;/div&gt;  )&#125;function Child() &#123;  useEffect(() =&gt; &#123;    //监听resize事件    window.onresize = ()=&gt;&#123;      console.log(&quot;resize&quot;)    &#125;    //启动定时器    var timer = setInterval(()=&gt;&#123;      console.log(&quot;1111&quot;)    &#125;, 1000)      return () =&gt; &#123;      console.log(&quot;组件销毁的时候执行&quot;)      //为什么要这么处理，因为react在组件销毁的时候绑定在组件上的事件，react并不会为我们清楚，所以需要自己手动清理      //去掉监听      window.onresize=&quot;&quot;      //清楚定时器      clearInterval(timer)    &#125;  &#125;, [])    return (    &lt;div&gt;      child    &lt;/div&gt;  )&#125;</code></pre><h4 id="useEffect和useLayoutEffect有啥区别？"><a href="#useEffect和useLayoutEffect有啥区别？" class="headerlink" title="useEffect和useLayoutEffect有啥区别？"></a>useEffect和useLayoutEffect有啥区别？</h4><p>简单来说就是调用时机不同，<code>useLayoutEffect</code>和原来的<code>componentDidMount和componentDidUpdate</code>一致，在React完成DOM更新之后<em><strong>马上同步调用</strong></em>代码，会阻塞页面渲染。而<code>useEffect</code>是会在整个页面渲染完才会调用代码。</p><p>官方建议优先使用useEffect。</p><p>在实际使用中如果想避免<strong>页面抖动</strong>（在useEffect中修改DOM很可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect里。在这里做DOM操作，这些DOM修改会和React做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价。</p><h3 id="4-useCallBack（记忆函数）"><a href="#4-useCallBack（记忆函数）" class="headerlink" title="4. useCallBack（记忆函数）"></a>4. useCallBack（记忆函数）</h3><p>防止因为组件重新渲染，导致方法重新创建，起到缓存的作用；只有第二个参数变化了，才重新声明一次</p><pre><code class="react">var handleClick = useCallBack(()=&gt;&#123;  console.log(name)&#125;, [name])&lt;buttton onClick=&#123;()=&gt;handleClick()&#125;&gt; hello &lt;/button&gt;//只有name改变后，这个函数才会重新声明一次//如果传入空数组，那么就是第一次创建就被缓存，如果name后期变化了，拿到的还是老的name//如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name</code></pre><h3 id="5-useMemo（记忆组件）"><a href="#5-useMemo（记忆组件）" class="headerlink" title="5. useMemo（记忆组件）"></a>5. useMemo（记忆组件）</h3><p>useCallBack的功能完全可以用useMemo取代，如果你想通过useMemo返回一个记忆函数也是完全可以的。</p><pre><code class="react">useCallBack(fn, inputs)  等价于 useMemo( ()=&gt;fn, inputs)</code></pre><p>唯一的区别是：<strong>useCallBack不会执行第一个参数函数，只是将它返回给你，而useMemo会执行第一个函数，并将结果返回给你。</strong></p><p>所以，useCallBack常用与记忆事件函数，生产记忆后的事件函数并传递给子组件使用。而useMemo更适合经过函数计算的到一个确认的值，比如记忆组件，理解为计算属性。</p><h3 id="6-useRef（保存引用值）"><a href="#6-useRef（保存引用值）" class="headerlink" title="6. useRef（保存引用值）"></a>6. useRef（保存引用值）</h3><pre><code class="react">const myswiper = useRef(null)&lt;Swiper ref=&#123;myswiper&#125; /&gt;</code></pre><h3 id="7-useReducer和useContext（减少组件层级）"><a href="#7-useReducer和useContext（减少组件层级）" class="headerlink" title="7. useReducer和useContext（减少组件层级）"></a>7. useReducer和useContext（减少组件层级）</h3><pre><code class="react">import React, &#123;  useContext, useState &#125; from &#39;react&#39;//1.先定义全局的context对象const GlobalContext = React.createContext()//2.设置生产者 export default function App()&#123;  const [name, setName] = useState(&quot;张三&quot;)  return (    //包裹根节点    &lt;GlobalContext.Provider value=&#123;&#123;      call: "打电话",      phone: "手机号",      name: name,      //只能通过这种方式让父组件更新，这样才能重新渲染，重新执行render函数      //在消费组件内直接修改，不能重新渲染，不能出发页面更新      changeName:(value)=>&#123;        setName(value)      &#125;,    &#125;&#125;&gt;      &lt;div&gt;        App        &lt;Child&gt;&lt;/Child&gt;        &lt;Child2&gt;&lt;/Child2&gt;      &lt;/div&gt;    &lt;/GlobalContext.Provider&gt;  )&#125;//3.设置消费者function Child()&#123;  //class组件的写法  return (    //直接使用标签版本    &lt;GlobalContext.Consumer&gt;      &#123;        (value)=&gt;&#123;          return (            //这里才是根节点内容            &lt;div style=&#123;&#123;              background:"yellow"            &#125;&#125;&gt;              Child组件1              &lt;button onClick=&#123;()=&gt;&#123;                value.changeName(&quot;李四&quot;)              &#125;&#125;&gt;改变name值为李四&lt;/button&gt;              &lt;p&gt;&#123;value.name&#125;&lt;/p&gt;              &lt;p&gt;&#123;value.phone&#125;&lt;/p&gt;              &lt;p&gt;&#123;value.call&#125;&lt;/p&gt;            &lt;/div&gt;          )        &#125;      &#125;    &lt;/GlobalContext.Consumer&gt;  )&#125;//useContext简化代码function Child2()&#123;  //hooks写法，大大减化代码  const context = useContext(GlobalContext)  console.log(&quot;context&quot;, context)  return (    //这里才是根节点内容    &lt;div style=&#123;&#123;      background:"red"    &#125;&#125;&gt;      Child组件2      &lt;p&gt;&#123;context.name&#125;&lt;/p&gt;      &lt;p&gt;&#123;context.phone&#125;&lt;/p&gt;      &lt;p&gt;&#123;context.call&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="userReducer将组件状态转移到外部，使得组件无状态"><a href="#userReducer将组件状态转移到外部，使得组件无状态" class="headerlink" title="userReducer将组件状态转移到外部，使得组件无状态"></a>userReducer将组件状态转移到外部，使得组件无状态</h4><pre><code class="react">import React,&#123;useReducer&#125; from &#39;react&#39;//useReducer处理函数const reducer = (preState, action)=&gt;&#123;  console.log(&quot;reducer...&quot;, preState, action)  //这里是一个技巧，操作状态不应该对原状态操作，需要深拷贝一份，对新状态操作，这样不会污染原来状态  let newState = &#123;...preState&#125;  switch(action.type)&#123;    case &quot;value-minus&quot;:      newState.count--      return newState    case &quot;value-add&quot;:      newState.count++      return newState    default:      return preState    &#125;&#125;//useReducer外部的状态const initialState=&#123;  count: 0&#125;export default function App() &#123;  // 这样做的好处就是将状态转移到外部，组件变成无状态了，类似后端开发redis作用  // const [state, dispatch] = useReducer(first, second, third)  const [state, dispatch] = useReducer(reducer, initialState)  return (    &lt;div&gt;      &lt;button onClick=&#123;()=&gt;&#123;        dispatch(&#123;          //type固定不可变，对应的值可以修改          type:&quot;value-minus&quot;        &#125;)      &#125;&#125;&gt;-&lt;/button&gt;      &#123;state.count&#125;      &lt;button onClick=&#123;()=&gt;&#123;        dispatch(&#123;          //type固定不可变，对应的值可以修改          type:&quot;value-add&quot;        &#125;)      &#125;&#125;&gt;+&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="案例：点击Child1组件的按钮，能够分别修改Child2和Child3组件的内容"><a href="#案例：点击Child1组件的按钮，能够分别修改Child2和Child3组件的内容" class="headerlink" title="案例：点击Child1组件的按钮，能够分别修改Child2和Child3组件的内容"></a>案例：点击Child1组件的按钮，能够分别修改Child2和Child3组件的内容</h4><pre><code class="react">import React,&#123;useReducer, useContext&#125; from &#39;react&#39;//将状态转移到外部const initialValue = &#123;  text1:&quot;aaaa&quot;,  text2:&quot;bbbb&quot;&#125;//定义状态发生改变的回调函数，也就是具体修改状态的地方就在这const reducer = (preState, action)=&gt;&#123;  const newState  = &#123;...preState&#125;  switch(action.type)&#123;    case &quot;click2&quot;:      newState.text1 = action.value      return newState     case &quot;click3&quot;:      newState.text2 = action.value      return newState     default:      return preState  &#125;&#125;//帮助在子节点同步状态const GlobalContext = React.createContext()export default function App() &#123;  const [state, dispatch] = useReducer(reducer, initialValue)  return (    //父组件将状态传递到子组件    &lt;GlobalContext.Provider value=&#123;&#123;      state,       dispatch    &#125;&#125;&gt;        &lt;div&gt;          APP          &lt;Child1&gt;&lt;/Child1&gt;          &lt;Child2&gt;&lt;/Child2&gt;          &lt;Child3&gt;&lt;/Child3&gt;        &lt;/div&gt;    &lt;/GlobalContext.Provider&gt;      )&#125;function Child1()&#123;  //子组件拿到状态，这里是解构赋值的方式，只用了一个，所以只写一个  //完整的是 const &#123;state, dispatch&#125; = useContext(GlobalContext)  const &#123;dispatch&#125; = useContext(GlobalContext)  return (    &lt;div&gt;      &lt;button onClick=&#123;()=&gt;&#123;        dispatch(&#123;          type:&quot;click2&quot;,          value:&quot;点击了click2&quot;        &#125;)      &#125;&#125;&gt;click2&lt;/button&gt;      Child1      &lt;button onClick=&#123;()=&gt;&#123;        dispatch(&#123;          type:&quot;click3&quot;,          value:&quot;点击了click3&quot;        &#125;)      &#125;&#125;&gt;click3&lt;/button&gt;    &lt;/div&gt;  )&#125;function Child2()&#123;  //子组件拿到状态，这里是解构赋值的方式，只用了一个，所以只写一个  //完整的是 const &#123;state, dispatch&#125; = useContext(GlobalContext)  const &#123;state&#125; = useContext(GlobalContext)  console.log(state)  return (    &lt;div&gt;      Child2-&#123;state.text1&#125;    &lt;/div&gt;  )&#125;function Child3()&#123;  //子组件拿到状态，这里是解构赋值的方式，只用了一个，所以只写一个  //完整的是 const &#123;state, dispatch&#125; = useContext(GlobalContext)  const &#123;state&#125; = useContext(GlobalContext)    return (    &lt;div&gt;      Child3-&#123;state.text2&#125;    &lt;/div&gt;  )&#125;</code></pre><h3 id="8-自定义hooks（相当于抽出公共组件）"><a href="#8-自定义hooks（相当于抽出公共组件）" class="headerlink" title="8. 自定义hooks（相当于抽出公共组件）"></a>8. 自定义hooks（相当于抽出公共组件）</h3><p><strong>当我们想在两个函数之间共享逻辑的时候，我们会把它提到第三个函数中。</strong></p><p>必须以“use”开头吗？必须如此。这个约定非常重要，不遵循的话，由于无法判断某个函数是否包含其对内部的Hook的调用，React将无法检查你的Hook是否违反了Hook的规则</p><pre><code class="react">import React, &#123; useEffect &#125; from &#39;react&#39;import axios from &#39;axios&#39;//抽出到自定义hooksfunction useGetListFromServce()&#123;  const [list, setList] = useState([])  useEffect(() =&gt; &#123;    axios.get(&quot;xxxx&quot;).then(res=&gt;&#123;      setList(res.data)    &#125;)        return () =&gt; &#123;      list    &#125;  &#125;, [])  &#125;export default function App() &#123;  //原始逻辑  // const [list, setList] = useState([])    // const getListFromServce = ()=&gt;&#123;  //   axios.get(&quot;xxxx&quot;).then(res=&gt;&#123;  //     setList(res.data)  //   &#125;)  // &#125;  //从自定义hooks拿出list  const &#123;list&#125; =  useGetListFromServce()  return (    &lt;div&gt;App      &#123;        list.length      &#125;    &lt;/div&gt;  )&#125;</code></pre><h2 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h2><h3 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h3><p>路由是根据不同的url地址展示不同的内容或者页面</p><p>一个针对React设计的路由解决方案，可以友好的帮你解决React Components 到URL之间的同步映射关系</p><h3 id="2-路由安装"><a href="#2-路由安装" class="headerlink" title="2. 路由安装"></a>2. 路由安装</h3><pre><code class="shell">npm install react-router-dom@5</code></pre><h3 id="3-路由使用"><a href="#3-路由使用" class="headerlink" title="3. 路由使用"></a>3. 路由使用</h3><h4 id="3-1-路由方法导入"><a href="#3-1-路由方法导入" class="headerlink" title="3.1 路由方法导入"></a>3.1 路由方法导入</h4><pre><code class="react">import &#123;HashRouter,Route&#125; from &#39;react-router-dom&#39;</code></pre><h4 id="3-2-定义路由以及重定向"><a href="#3-2-定义路由以及重定向" class="headerlink" title="3.2 定义路由以及重定向"></a>3.2 定义路由以及重定向</h4><pre><code class="react">&lt;HashRouter&gt;  &#123;/* switch只陪到到找到的第一个，然后就退出。        刷新之后如果匹配到，立即退出，就不会Redirect，否则继续跳到Redirect */&#125;  &#123;/* 类似switch case语句 */&#125;  &lt;Switch&gt;    &lt;Route path=&quot;/films&quot; component=&#123;Films&#125;&gt;&lt;/Route&gt;    &lt;Route path=&quot;/cinemas&quot; component=&#123;Cinemas&#125;&gt;&lt;/Route&gt;    &lt;Route path=&quot;/center&quot; component=&#123;Center&#125;&gt;&lt;/Route&gt;    &#123;/* 模糊匹配，所以每次刷新都会匹配到Redirect这里 */&#125;    &#123;/* &lt;Redirect  from=&quot;/&quot; to=&quot;/films&quot; /&gt; */&#125;    &#123;/* 精确匹配 */&#125;    &lt;Redirect  from=&quot;/&quot; to=&quot;/films&quot;  exact /&gt;    &#123;/* 放到想要做的效果就是上面都不匹配，跳到这个组件，展示404 */&#125;    &#123;/* 但是实际效果来说，会被上面的Redirect拦截掉，            因为默认的是模糊匹配，因此需要让Redirect变成精准匹配，只需要在Redirect加上exact属性即可 */&#125;    &lt;Route component=&#123;NotFound&#125; /&gt;  &lt;/Switch&gt;&lt;/HashRouter&gt;</code></pre><blockquote><p>注意⚠️：</p><ol><li><Redirect  from="/" to="/films" /> 默认模糊匹配</li><li>加上exact精准匹配</li><li>Warning :Hash history cannot PUSH the same path;a new entry will not be added to the  history stack,这个警告只有hash模式会出现</li></ol></blockquote><h4 id="3-3-嵌套路由"><a href="#3-3-嵌套路由" class="headerlink" title="3.3 嵌套路由"></a>3.3 嵌套路由</h4><pre><code class="react">&lt;Switch&gt;  &lt;Route path=&quot;/films/nowplay&quot; component=&#123;Nowplaying&#125;&gt;&lt;/Route&gt;  &lt;Route path=&quot;/films/commingsoon&quot; component=&#123;CommingSoon&#125;&gt;&lt;/Route&gt;  &lt;Redirect from=&quot;/films&quot; to=&quot;/films/nowplay&quot; &gt;&lt;/Redirect&gt;&lt;/Switch&gt;</code></pre><h4 id="3-4-路由跳转方式"><a href="#3-4-路由跳转方式" class="headerlink" title="3.4 路由跳转方式"></a>3.4 路由跳转方式</h4><h5 id="3-4-1-声明式导航"><a href="#3-4-1-声明式导航" class="headerlink" title="3.4.1 声明式导航"></a>3.4.1 声明式导航</h5><pre><code class="react"> &lt;NavLink to=&quot;/films&quot; activeClassName=&quot;zactiv&quot;&gt;电影&lt;/NavLink&gt;</code></pre><h5 id="3-4-2-编程式导航"><a href="#3-4-2-编程式导航" class="headerlink" title="3.4.2 编程式导航"></a>3.4.2 编程式导航</h5><pre><code class="react">//方式一window.location.href=&quot;#/detail/&quot;+id//方式二//方法组件中, `/detail/$&#123;id&#125;` 字符串模版props.history.push(`/detail/$&#123;id&#125;`)</code></pre><h3 id="3-5-路由传参"><a href="#3-5-路由传参" class="headerlink" title="3.5 路由传参"></a>3.5 路由传参</h3><pre><code class="react">//一、query传参数&lt;Route paht=&quot;/detail&quot; component=&#123;Detail&#125; &gt;&lt;/Route&gt;//传参数props.history.push(&#123;pathname:&#39;/detail&#39;, query:&#123;id:1&#125;&#125;)//取参数props.location.query.id//二、动态路由传参, 推荐这种&lt;Route paht=&quot;/detail/:myid&quot; component=&#123;Detail&#125; &gt;&lt;/Route&gt;//传参数props.history.push(`/detail/$&#123;id&#125;`)  //取参数 props.match.params.myid</code></pre><h3 id="3-6-路由拦截"><a href="#3-6-路由拦截" class="headerlink" title="3.6 路由拦截"></a>3.6 路由拦截</h3><pre><code class="react">//加个redirect是为了保持地址栏和组件一致&lt;Route path=&quot;/center&quot; render=&#123; (props)=&gt; isAuth()?&lt;Center &#123;...props&#125; /&gt;: &lt;Redirect to=&quot;/login&quot; /&gt; &#125; /&gt;&lt;Route path=&quot;/login&quot; component=&#123;Login&#125;&gt;&lt;/Route&gt;</code></pre><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><ol><li><p><code>npm i http-proxy-middleware</code>安装代理插件</p></li><li><p>在src目录下新建setupProxy.js</p></li><li><p>在setupProxy.js复制如下代码</p><pre><code class="js">//这段代码含义，//用户发送一个以/api开头的请求，node服务器会把这个请求拦截下来，//并由node服务器去发送请求，然后把数据给我们的代码//这样做是为了绕过，浏览器的跨域限制，由服务器去请求到数据在给到我们自己写的代码const &#123;createProxyMiddleware&#125; = require(&#39;http-proxy-middleware&#39;)module.exports = function(app)&#123;  app.use(      &#39;/api&#39;, //以api开头的接口    createProxyMiddleware(&#123;      target:&#39;http://www.newbaiduy.com&#39;, //目标请求的域名      changeOrigin: true,    &#125;)  )&#125;</code></pre></li></ol><h2 id="Flux与Redux"><a href="#Flux与Redux" class="headerlink" title="Flux与Redux"></a>Flux与Redux</h2><p>Redux主要是用于应用状态管理。简而言之，Redux用一个单独的常量状态树（state对象）保存整个应用的状态，这个对象不能被直接改变。当一些数据发生变化了，一个新的对象就会被创建（使用action和reducer），这样就可以进行数据追踪，实现时光旅行。</p><h3 id="1-redux介绍及设计和使用的三大原则"><a href="#1-redux介绍及设计和使用的三大原则" class="headerlink" title="1. redux介绍及设计和使用的三大原则"></a>1. redux介绍及设计和使用的三大原则</h3><blockquote><ul><li>state 以单一对象存储在store对象中</li><li>state 只读（每次都返回一个新对象）</li><li>使用纯函数reducer执行state更新</li></ul></blockquote><h3 id="2-redux工作流"><a href="#2-redux工作流" class="headerlink" title="2. redux工作流"></a>2. redux工作流</h3><p><img src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" alt="redux工作流"></p><blockquote><p>原图地址：<a href="https://redux.js.org/tutorials/essentials/part-1-overview-concepts#:~:text=on%20the%20screen-,Here%27s,-what%20that%20data">https://redux.js.org/tutorials/essentials/part-1-overview-concepts#:~:text=on%20the%20screen-,Here%27s,-what%20that%20data</a></p></blockquote><h2 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><blockquote><p><a href="https://github.com/reactjs/react-redux">https://github.com/reactjs/react-redux</a></p></blockquote><h3 id="2-容器组件与UI组件"><a href="#2-容器组件与UI组件" class="headerlink" title="2. 容器组件与UI组件"></a>2. 容器组件与UI组件</h3><h4 id="2-1-UI组件"><a href="#2-1-UI组件" class="headerlink" title="2.1 UI组件"></a>2.1 UI组件</h4><ul><li>只负责UI的呈现，不带有任何业务</li><li>没有状态（即不使用this.state这个变量）</li><li>所有数据都有this.props提供</li><li>不使用任何redux的api</li></ul><h4 id="2-2-容器组件"><a href="#2-2-容器组件" class="headerlink" title="2.2 容器组件"></a>2.2 容器组件</h4><ul><li>负责管理数据和业务逻辑，不负责UI的呈现</li><li>带有内部状态</li><li>使用Redux的API</li></ul><h3 id="2-3-Provider与connect"><a href="#2-3-Provider与connect" class="headerlink" title="2.3 Provider与connect"></a>2.3 Provider与connect</h3><h3 id="2-4-HOC与context通信在react-redux底层中的应用"><a href="#2-4-HOC与context通信在react-redux底层中的应用" class="headerlink" title="2.4 HOC与context通信在react-redux底层中的应用"></a>2.4 HOC与context通信在react-redux底层中的应用</h3><ol><li>connect 是HOC，高阶组件</li><li>Provider组件，可以让容器组件拿到state，使用了context</li></ol><h3 id="2-5-高阶组件构建与应用"><a href="#2-5-高阶组件构建与应用" class="headerlink" title="2.5 高阶组件构建与应用"></a>2.5 高阶组件构建与应用</h3><p>HOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生产高阶组件。</p><ol><li>代码复用，代码模块化</li><li>增删查改props</li><li>渲染劫持</li></ol><pre><code class="react">import React from &#39;react&#39;function NotFound() &#123;  return (    &lt;div&gt;404 not found&lt;/div&gt;  )&#125;function myHOC(func, obj) &#123;  //执行传入的函数  var value = func()    return (MyComponent)=&gt;&#123; //这里返回一个函数，入参是一个组件，对应下面的 myHOC(...)(NotFound) 这一部分    //执行上面定义的函数，返回一个组件    return (props)=&gt;&#123;      //劫持原组件，然后渲染一下      return (&lt;div style=&#123;&#123;background: "red"&#125;&#125;&gt;         &#123;/* 将value， 之前的props和obj绑定到新组件的props中去 */&#125;        &lt;MyComponent &#123;...value&#125; &#123;...props&#125; &#123;...obj&#125; &gt;&lt;/MyComponent&gt;      &lt;/div&gt;)//括号包裹的就是组件内容    &#125;  &#125;&#125;//自定义的高阶组件export default myHOC(()=&gt;&#123;  return &#123;    a:1,    b:2  &#125;&#125;, &#123;  f1()&#123;&#125;,  f2()&#123;&#125;,&#125;)(NotFound)</code></pre><h3 id="2-6-Redux持久化"><a href="#2-6-Redux持久化" class="headerlink" title="2.6 Redux持久化"></a>2.6 Redux持久化</h3><blockquote><p>redux-persis</p><p><a href="https://github.com/rt2zz/redux-persist">https://github.com/rt2zz/redux-persist</a></p></blockquote><h2 id="UI组件库"><a href="#UI组件库" class="headerlink" title="UI组件库"></a>UI组件库</h2><p>Ant Design是一个致力于提升【用户】和【设计者】使用体验的预言；旨在统一中台项目中的前端UI设计，屏蔽不必要的设计差异和实现成本，解放设计和前端的的研发资源；包含很多设计原则和配套的组件库。</p><h3 id="1-ant-design（PC端）"><a href="#1-ant-design（PC端）" class="headerlink" title="1. ant-design（PC端）"></a>1. ant-design（PC端）</h3><p><a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p><h2 id="2-antd-mobile（移动端）"><a href="#2-antd-mobile（移动端）" class="headerlink" title="2. antd-mobile（移动端）"></a>2. antd-mobile（移动端）</h2><p><a href="https://mobile.ant.design/">https://mobile.ant.design</a></p><h2 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h2><pre><code class="react">var obj = &#123; /* 一个十分复杂的对象 */ &#125;doSomething(obj)//上面的函数执行完之后，此时的obj还是原来的obj吗？如果函数内部发生deepCopy那么就不是，否则还是原来的地址//deepCopy?</code></pre><h3 id="1-Immutable-js介绍"><a href="#1-Immutable-js介绍" class="headerlink" title="1. Immutable.js介绍"></a>1. Immutable.js介绍</h3><blockquote><p>地址： <a href="https://github.com/immutable-js/immutable-js">https://github.com/immutable-js/immutable-js</a></p></blockquote><p>每次修改一个immutable对象时都会创建一个新的不可变对象，在新对象的操作并不会影响原始对象的数据。</p><h3 id="2-深拷贝与浅拷贝"><a href="#2-深拷贝与浅拷贝" class="headerlink" title="2. 深拷贝与浅拷贝"></a>2. 深拷贝与浅拷贝</h3><ol><li>var arr &#x3D; {}; var arr2 &#x3D; arr;   浅拷贝</li><li>Object.assign()只是一级属性复制，比浅拷贝多拷贝了一层而已</li><li>const obj1 &#x3D; JSON.parse(JSON.stringfy(obj));数组对象都好用（缺点：不能有undefined）</li></ol><h3 id="3-immutable优化性能的方式"><a href="#3-immutable优化性能的方式" class="headerlink" title="3. immutable优化性能的方式"></a>3. immutable优化性能的方式</h3><p>immutable实现的原理是Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时，为了避免deepCopy把所有节点都复制一遍带来的性能损耗，immutable使用了Structural Sharing（结构共享）。即，对象树的一个节点发生变化，只修改这个节点和它影响的父节点，其他节点共享。</p><h3 id="4-Immutable中常用的类型（Map，-List）"><a href="#4-Immutable中常用的类型（Map，-List）" class="headerlink" title="4. Immutable中常用的类型（Map， List）"></a>4. Immutable中常用的类型（Map， List）</h3><ul><li><p>Map</p><pre><code class="react">import &#123;Map&#125; from &#39;immutable&#39;const m1 = Map(&#123;a:1,b:2,c:3&#125;)const m2 = map1.set(&#39;b&#39;,50)m1.get(&#39;b&#39;)+&quot; vs &quot;+m2.get(&#39;b&#39;);   //2 vs 50</code></pre></li><li><p>List</p><pre><code class="react">import &#123;List&#125; from &#39;immutable&#39;const list = List([1,2,3])const list2 = list1.push(3,4,5) //添加const list3 = list2.unshift(0) //移除 list2.toJs() //123345list3.toJs() // 23345</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React学习&quot;&gt;&lt;a href=&quot;#React学习&quot; class=&quot;headerlink&quot; title=&quot;React学习&quot;&gt;&lt;/a&gt;React学习&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h3 id=&quot;1-React起源&quot;&gt;&lt;a href=&quot;#1-React起源&quot; class=&quot;headerlink&quot; title=&quot;1.React起源&quot;&gt;&lt;/a&gt;1.React起源&lt;/h3&gt;&lt;p&gt;React起源facebook内部项目，该公司对市场上的JavaScript MVC框架不满意，决定自己写一套，用于架设Instagram网站。做出来之后，发现很好用，就于2013年5月开源了&lt;/p&gt;
&lt;h3 id=&quot;2-React与传统MVC关系&quot;&gt;&lt;a href=&quot;#2-React与传统MVC关系&quot; class=&quot;headerlink&quot; title=&quot;2.React与传统MVC关系&quot;&gt;&lt;/a&gt;2.React与传统MVC关系&lt;/h3&gt;&lt;p&gt;轻量级视图层库。&lt;em&gt;A javascript library for building user interfaces&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;React是构建页面元素UI的库，可以简单理解为，React将页面分成各个独立的块，每一个块儿就是一个独立组件，各个组件之间可以进行组合、嵌套，就形成了我们的页面。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://github/zhuchong6.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://github/zhuchong6.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="react" scheme="https://github/zhuchong6.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>k8s学习</title>
    <link href="https://github/zhuchong6.github.io/2023/06/26/2023-02-02k8s%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github/zhuchong6.github.io/2023/06/26/2023-02-02k8s%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-06-26T13:16:30.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes学习"><a href="#Kubernetes学习" class="headerlink" title="Kubernetes学习"></a>Kubernetes学习</h1><h2 id="一、初识K8S"><a href="#一、初识K8S" class="headerlink" title="一、初识K8S"></a>一、初识K8S</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/">https://kubernetes.io/zh-cn/docs/concepts/overview/</a></p></blockquote><p><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”，简称k8s。</p><p><strong>Kubernetes</strong> 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 <strong>Kubernetes</strong> 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p><span id="more"></span><h3 id="为什么需要k8s"><a href="#为什么需要k8s" class="headerlink" title="为什么需要k8s"></a>为什么需要k8s</h3><blockquote><p>官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/">https://kubernetes.io/zh-cn/docs/concepts/overview/</a></p></blockquote><p>下图展示了部署的发展历程：</p><p><img src="/images/k8s01.svg" alt="部署方式发展历史"></p><p>容器是打包和运行应用程序的好方式。在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？</p><p>这就是 Kubernetes 要来做的事情！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。</p><h2 id="二、组件-amp-架构"><a href="#二、组件-amp-架构" class="headerlink" title="二、组件&amp;架构"></a>二、组件&amp;架构</h2><ul><li>集群组件</li><li>核心概念</li></ul><h3 id="1-集群组件"><a href="#1-集群组件" class="headerlink" title="1. 集群组件"></a>1. 集群组件</h3><ul><li>集群（cluster）：将同一个软件服务多个节点组织到一起共同为系统提供服务的过程称之为该软件的集群。redis集群、es集群、mongo集群等。</li><li>k8s集群：多个节点，至少三个 角色：1.master节点（control plane控制节点） 2.work node：工作节点（pod容器实际运行的节点）</li></ul><p>当你部署完 Kubernetes，便拥有了一个完整的集群。一组工作机器，称为 <a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>， 会运行容器化应用程序。每个集群至少有一个工作节点。工作节点会托管 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> ，而 Pod 就是作为应用负载的组件。 <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>管理集群中的工作节点和 Pod。</p><p><img src="/images/k8s02.svg" alt="k8s架构"></p><h4 id="1-1-控制平面组件（Contorl-Plane-Component）"><a href="#1-1-控制平面组件（Contorl-Plane-Component）" class="headerlink" title="1.1 控制平面组件（Contorl Plane Component）"></a>1.1 控制平面组件（Contorl Plane Component）</h4><p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 <code>replicas</code> 字段时， 要启动新的pod）</p><blockquote><p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器</p></blockquote><ul><li><p>kube-apiserver</p><p>API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。Kubernetes API 服务器的主要实现是 <code>kube-apiserver</code>。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量。</p></li><li><p>etcd</p><p>一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。</p></li><li><p>kube-scheduler</p><p><code>kube-scheduler</code> 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的Pods， 并选择节点来让 Pod 在上面运行。调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p></li><li><p>kube-controller-manager</p><p>kube-controller-manager是控制平面组件，负责运行控制器进程。从逻辑上讲， 每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p><p>有许多不同类型的控制器。以下是一些例子：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li><li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）</li></ul></li><li><p>cloud-controller-manager  </p><p>cloud-controller-manager是一个控制平面组件，嵌入了特定云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p></li></ul><h4 id="1-2-Node组件"><a href="#1-2-Node组件" class="headerlink" title="1.2. Node组件"></a>1.2. Node组件</h4><blockquote><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境</p></blockquote><h5 id="1-2-1-kubelet"><a href="#1-2-1-kubelet" class="headerlink" title="1.2.1 kubelet"></a>1.2.1 kubelet</h5><p><code>kubelet</code> 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h5 id="1-2-2-kube-proxy"><a href="#1-2-2-kube-proxy" class="headerlink" title="1.2.2 kube-proxy"></a>1.2.2 kube-proxy</h5><p>kube-proxy是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p><h5 id="1-2-3-容器运行时"><a href="#1-2-3-容器运行时" class="headerlink" title="1.2.3 容器运行时"></a>1.2.3 容器运行时</h5><p>容器运行环境是负责运行容器的软件。</p><p>Kubernetes 支持许多容器运行环境，例如 <a href="https://containerd.io/docs/">containerd</a>、 <a href="https://cri-o.io/#what-is-cri-o">CRI-O</a> 以及 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">Kubernetes CRI (容器运行环境接口)</a> 的其他任何实现。</p><h4 id="1-3-Addons（插件）"><a href="#1-3-Addons（插件）" class="headerlink" title="1.3. Addons（插件）"></a>1.3. Addons（插件）</h4><p>插件使用 Kubernetes 资源（DaemonSet、 Deployment 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 <code>kube-system</code> 命名空间。</p><p>下面描述众多插件中的几种。有关可用插件的完整列表，请参见 <a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/">插件（Addons）</a>。</p><h5 id="1-3-1-DNS"><a href="#1-3-1-DNS" class="headerlink" title="1.3.1 DNS"></a>1.3.1 DNS</h5><p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/">集群 DNS</a>， 因为很多示例都需要 DNS 服务。</p><p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p><p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p><h5 id="1-3-2-Web界面（仪表盘）"><a href="#1-3-2-Web界面（仪表盘）" class="headerlink" title="1.3.2 Web界面（仪表盘）"></a>1.3.2 Web界面（仪表盘）</h5><p><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/">Dashboard</a> 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。</p><h5 id="1-3-3-容器资源监控"><a href="#1-3-3-容器资源监控" class="headerlink" title="1.3.3 容器资源监控"></a>1.3.3 容器资源监控</h5><p><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。</p><h5 id="1-3-4-集群层面日志"><a href="#1-3-4-集群层面日志" class="headerlink" title="1.3.4 集群层面日志"></a>1.3.4 集群层面日志</h5><p><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/">集群层面日志</a>机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</p><h5 id="1-3-5-网络插件"><a href="#1-3-5-网络插件" class="headerlink" title="1.3.5 网络插件"></a>1.3.5 网络插件</h5><p><a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins">网络插件</a> 是实现容器网络接口（CNI）规范的软件组件。它们负责为 Pod 分配 IP 地址，并使这些 Pod 能在集群内部相互通信。</p><h3 id="2-集群架构详解"><a href="#2-集群架构详解" class="headerlink" title="2. 集群架构详解"></a>2. 集群架构详解</h3><p><img src="/images/k8sjiagou.png" alt="k8s集群详解"></p><p>总结：kubernetes集群由多个节点组成，节点通常分为两部分：一类属于管理平面的主节点&#x2F;控制节点（Masgter Node）；一类属于运行平面的工作节点（Work Node）。复杂的工作都交给控制节点去做了，工作节点负责提供稳定的操作接口和能力抽象即可。</p><h2 id="三、Pod-amp-Container"><a href="#三、Pod-amp-Container" class="headerlink" title="三、Pod &amp; Container"></a>三、Pod &amp; Container</h2><h3 id="1-什么是Pod"><a href="#1-什么是Pod" class="headerlink" title="1. 什么是Pod"></a>1. 什么是Pod</h3><blockquote><p>官网描述：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/</a></p></blockquote><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p><strong>Pod</strong> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><p><strong>Pod</strong>（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个）容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。<strong>简而言之，如果用docker的术语描述的话，pod类似共享名称空间和文件系统卷的一组容器</strong></p><p><code>Pod 就是用来管理一组(一个或多个)容器的集合，特点：共享网络、共享存储、共享上下文环境</code></p><h4 id="1-2-Pod怎么管理多个容器？"><a href="#1-2-Pod怎么管理多个容器？" class="headerlink" title="1.2 Pod怎么管理多个容器？"></a>1.2 Pod怎么管理多个容器？</h4><p>Pod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。 Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身。</p><p>例如，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的 “边车 (sidercar)” 容器负责从远端更新这些文件，如下图所示：</p><p><img src="/images/k8s03.svg" alt="side-car"></p><h4 id="1-3-如何使用Pod？"><a href="#1-3-如何使用Pod？" class="headerlink" title="1.3 如何使用Pod？"></a>1.3 如何使用Pod？</h4><p>通常你不需要直接创建Pod，甚至单实例Pod。相反，你会使用诸如Deployment或者Job这类负载资源来创建Pod。如果Pod需要状态追踪，可以考虑使用StatefulSet资源。</p><p>Kubernetes集群中的Pod主要有两种方法：</p><ul><li>运行单个容器的Pod：”每个Pod一个容器“模型是最常见的Kubernates用例；这种情况下，可以将Pod看作单个容器的包装器，并且Kubernetes直接管理Pod，而不是容器</li><li>运行多个协同工作的容器的Pod：Pod可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。这些位于同一位置的容器可能形成单个内聚的服务单元–一个容器将文件共享从共享卷提供给公众，而另一个单独的“边车”（sidecar）容器则刷新或者更新这些文件。Pod将这些容器和存储资源打包为一个可管理的实体。</li></ul><blockquote><p>说明：</p><ul><li>将多个并置、同管的容器组织到一个Pod中是一种相对高级的使用场景。只有在容器之间紧密关联时你才应该使用这种模式。</li><li>每个Pod都旨在运行给定应用程序单个实例，如果需要横向拓展该应用，则应该使用多个Pod，每个Pod一个实例。在Kubernetes中，这通常被称为副本（Replication）。</li></ul></blockquote><h3 id="2-Pod的基本操作"><a href="#2-Pod的基本操作" class="headerlink" title="2. Pod的基本操作"></a>2. Pod的基本操作</h3><h4 id="2-1-查看Pod"><a href="#2-1-查看Pod" class="headerlink" title="2.1 查看Pod"></a>2.1 查看Pod</h4><pre><code class="shell">#查看默认命名空间的podkubectl get pods|pod#查看所有命名空间的podkubectl get pods|pod -A#查看默认命名空间下pod的详情信息kubectl get pods -o wide#查看所有命名空间下pod的详情信息kubectl get pods -o wide -A#实时监控当前命名空间pod的状态kubectl get pods -w#实时监控所有命名空间pod的状态kubectl get pods -w -A</code></pre><h4 id="2-2-创建Pod"><a href="#2-2-创建Pod" class="headerlink" title="2.2 创建Pod"></a>2.2 创建Pod</h4><blockquote><p>官网链接：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#using-pods:~:text=simple%2Dpod.yaml-,apiVersion%3A%20v1,-kind%3A%20Pod">https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#using-pods:~:text=simple%2Dpod.yaml-,apiVersion%3A%20v1,-kind%3A%20Pod</a></p></blockquote><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginxspec:  containers:  - name: nginx    image: nginx:1.14.2    ports:    - containerPort: 80</code></pre><pre><code class="shell">#使用apply命令和create命令创建podkubectl create -f nginx-pod.ymlkubectl apply -f nginx-pod.yml</code></pre><blockquote><p>注意：</p><p>create是不存在pod时候创建，存在的时候报错。因此，更推荐使用apply，apply是不存在创建，存在更新</p></blockquote><p><em><strong>配置无需手写，可以借助IDEA中kubernetes插件生成</strong></em></p><h4 id="2-3-删除Pod"><a href="#2-3-删除Pod" class="headerlink" title="2.3 删除Pod"></a>2.3 删除Pod</h4><pre><code class="shell">#根据pod名称删除kubectl delete pod pod名称#根据pod配置文件删除kubectl delete -f nginx-pod.yml</code></pre><h4 id="2-4-进入Pod容器"><a href="#2-4-进入Pod容器" class="headerlink" title="2.4 进入Pod容器"></a>2.4 进入Pod容器</h4><pre><code class="shell">#类似docker exec#注意这种方式默认只会进入pod中的第一个容器kubectl exec -it nginx(pod名称) --(固定写死) bash(执行命令)#进入指定容器kubectl exec -it nginx(pod名称) -c nginx(指定进入容器名称) --(固定写死) bash(执行命令)</code></pre><h4 id="2-5-查看Pod日志"><a href="#2-5-查看Pod日志" class="headerlink" title="2.5 查看Pod日志"></a>2.5 查看Pod日志</h4><pre><code class="shell">#查看第一个容器日志kubectl logs -f(可选，加了查看实时日志) nginx(pod名称）#查看指定容器日志kubectl logs -f(可选，加了查看实时日志) nginx(pod名称）-c nginx(查看日志的容器名称)</code></pre><h4 id="2-6-查看Pod的描述信息"><a href="#2-6-查看Pod的描述信息" class="headerlink" title="2.6 查看Pod的描述信息"></a>2.6 查看Pod的描述信息</h4><pre><code class="shell">kubectl describe pod nginx(pod名称)</code></pre><h3 id="3-Pod运行多个容器"><a href="#3-Pod运行多个容器" class="headerlink" title="3. Pod运行多个容器"></a>3. Pod运行多个容器</h3><h4 id="3-1-创建Pod"><a href="#3-1-创建Pod" class="headerlink" title="3.1 创建Pod"></a>3.1 创建Pod</h4><pre><code class="yaml">#myapp.yamlapiVersion: v1kind: Podmetadata:  name: myapp  labels:    app: myappspec:  containers:    - name: nginx      image: nginx:1.21      ports:        - containerPort: 80      imagePullPolicy: IfNotPresent    - name: redis      image: redis:5.0.10      ports:        - containerPort: 6379      imagePullPolicy: IfNotPresent  restartPolicy: Always</code></pre><pre><code class="shell">#执行命令kubectl apply -f myapp.yaml</code></pre><h4 id="3-2-查看指定容器日志"><a href="#3-2-查看指定容器日志" class="headerlink" title="3.2 查看指定容器日志"></a>3.2 查看指定容器日志</h4><pre><code class="shell">#查看第一个容器日志kubectl logs -f(可选，加了查看实时日志) myapp(pod名称）#查看指定容器日志kubectl logs -f(可选，加了查看实时日志) myapp(pod名称）-c nginx(查看日志的容器名称)#查看指定容器日志kubectl logs -f(可选，加了查看实时日志) myapp(pod名称）-c redis(查看日志的容器名称)</code></pre><h4 id="3-3-进入容器"><a href="#3-3-进入容器" class="headerlink" title="3.3 进入容器"></a>3.3 进入容器</h4><pre><code class="shell">#默认进入第一个容器，这里会进入nginx中kubectl exec -it myapp(pod名称) --(固定写死) bash(执行命令)#进入指定容器kubectl exec -it myapp(pod名称) -c nginx(指定进入容器名称) --(固定写死) bash(执行命令)#进入指定容器kubectl exec -it myapp(pod名称) -c redis(指定进入容器名称) --(固定写死) bash(执行命令)</code></pre><h3 id="4-Pod的Labels（标签）"><a href="#4-Pod的Labels（标签）" class="headerlink" title="4. Pod的Labels（标签）"></a>4. Pod的Labels（标签）</h3><blockquote><p>标签不仅仅作用Pod上，可以作用在k8s所有对象上，这里以Pod举例</p></blockquote><p>标签（Labels）是附加到Kubernetes对象（比如Pod）上的键值对。标签旨在指定<strong>对用户有意义且相关</strong>的对象标识。标签可以在创建的时候附加到对象，随后可以随时添加和修改。每个对象都可以定义一组键（key）值（value）对，但是每个key对于给定对象（例如Pod）必须是唯一的。</p><p>标签作用：就是起别名，用于过滤或者筛选</p><h4 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h4><p>标签有键值对组成，其有效值：</p><ul><li>必须为63个字符或者更少（可以为空）</li><li>除非标签值为空，必须以字母数字字符（[a-z0-9A-Z]）开头和结尾</li><li>包含破折号（-）、下划线（_）、点（.）等特殊字符</li></ul><h4 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h4><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: myapp  labels:    app: myapp #创建时添加spec:  containers:    - name: nginx      image: nginx:1.21      ports:        - containerPort: 80      imagePullPolicy: IfNotPresent    - name: redis      image: redis:5.0.10      ports:        - containerPort: 6379      imagePullPolicy: IfNotPresent  restartPolicy: Always</code></pre><h4 id="4-3-标签基本操作"><a href="#4-3-标签基本操作" class="headerlink" title="4.3 标签基本操作"></a>4.3 标签基本操作</h4><pre><code class="shell">#查看标签kubectl get pods --show-labels#启动之后打标签,这句话意思是：给名称是myapp的pod打标签，标签内容是env=devkubectl label pod myapp(pod名称) env=dev(填要加入的标签)#--overwrite 代表修改#修改标签,这句话意思是：修改名称是myapp的pod中标签key是env的标签，修改值为testkubectl label --overwrite pod myapp env=test#-号代表删除#删除标签，这句话意思是：删除名称是myapp的pod中标签key是env的标签kubectl label pod myapp env-#根据label筛选，po是pods的缩写kubelctl get po -l env=testkubelctl get po -l envkubelctl get po -l &#39;!env&#39; #不包含envkubelctl get po -l &#39;env in (test,prod)&#39; #选择包含test 和prod的envkubelctl get po -l &#39;env notin (test,prod)&#39; #选择不包含test 和prod的env</code></pre><h3 id="5-Pod的生命周期"><a href="#5-Pod的生命周期" class="headerlink" title="5. Pod的生命周期"></a>5. Pod的生命周期</h3><blockquote><p>官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/">https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/</a></p></blockquote><p>Pod 遵循预定义的生命周期，起始于 <code>Pending</code> 阶段， 如果至少其中有一个主要容器正常启动，则进入 <code>Running</code>，之后取决于 Pod 中是否有容器以失败状态结束而进入 <code>Succeeded</code> 或者 <code>Failed</code> 阶段。</p><p>Pod 在其生命周期中只会被调度一次。 一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod 停止或者被终止。</p><h4 id="5-1-生命周期"><a href="#5-1-生命周期" class="headerlink" title="5.1 生命周期"></a>5.1 生命周期</h4><p>和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（UID）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。</p><p>如果一个节点死掉了，调度到该节点的 Pod 也被计划在给定超时期限结束后删除。</p><p>Pod 自身不具有自愈能力。如果 Pod 被调度到某节点而该节点之后失效， Pod 会被删除；类似地，Pod 无法在因节点资源耗尽或者节点维护而被驱逐期间继续存活。 Kubernetes 使用一种高级抽象来管理这些相对而言可随时丢弃的 Pod 实例， 称作控制器。</p><p>任何给定的 Pod （由 UID 定义）从不会被“重新调度（rescheduled）”到不同的节点； 相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。 如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。</p><p>如果某物声称其生命期与某 Pod 相同，例如存储卷， 这就意味着该对象在此 Pod （UID 亦相同）存在期间也一直存在。 如果 Pod 因为任何原因被删除，甚至某完全相同的替代 Pod 被创建时， 这个相关的对象（例如这里的卷）也会被删除并重建。</p><h4 id="5-2-Pod阶段"><a href="#5-2-Pod阶段" class="headerlink" title="5.2 Pod阶段"></a>5.2 Pod阶段</h4><p>Pod阶段的数量和含义是被严格定义的。除本文档列举的内容外，不应该在假定Pod有其他的phase值。</p><table><thead><tr><th>取值</th><th>描述</th></tr></thead><tbody><tr><td><code>Pending</code>（悬决）</td><td>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。</td></tr><tr><td><code>Running</code>（运行中）</td><td>Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</td></tr><tr><td><code>Succeeded</code>（成功）</td><td>Pod 中的所有容器都已成功终止，并且不会再重启。</td></tr><tr><td><code>Failed</code>（失败）</td><td>Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。</td></tr><tr><td><code>Unknown</code>（未知）</td><td>因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。</td></tr></tbody></table><blockquote><p><strong>说明：</strong></p><p>当一个 Pod 被删除时，执行一些 kubectl 命令会展示这个 Pod 的状态为 <code>Terminating</code>（终止）。 这个 <code>Terminating</code> 状态并不是 Pod 阶段之一。 Pod 被赋予一个可以体面终止的期限，默认为 30 秒。 你可以使用 <code>--force</code> 参数来强制终止 Pod。</p></blockquote><h3 id="6-Container特性"><a href="#6-Container特性" class="headerlink" title="6. Container特性"></a>6. Container特性</h3><h4 id="6-1-容器的生命周期"><a href="#6-1-容器的生命周期" class="headerlink" title="6.1 容器的生命周期"></a>6.1 容器的生命周期</h4><p>Kubernetes 会跟踪 Pod 中每个容器的状态，就像它跟踪 Pod 总体上的阶段一样。 你可以使用<strong>容器生命周期回调</strong>来在容器生命周期中的特定时间点触发事件。</p><p>一旦调度器将 Pod 分派给某个节点，<code>kubelet</code> 就通过容器运行时开始为 Pod 创建容器。容器的状态有三种：<code>Waiting</code>（等待）、<code>Running</code>（运行中）和 <code>Terminated</code>（已终止）。</p><p>要检查 Pod 中容器的状态，你可以使用 <code>kubectl describe pod &lt;pod 名称&gt;</code>。 其输出中包含 Pod 中每个容器的状态。</p><p>每种状态都有特定的含义：</p><h3 id="Waiting-（等待）"><a href="#Waiting-（等待）" class="headerlink" title="Waiting （等待）"></a><code>Waiting</code> （等待）</h3><p>如果容器并不处在 <code>Running</code> 或 <code>Terminated</code> 状态之一，它就处在 <code>Waiting</code> 状态。 处于 <code>Waiting</code> 状态的容器仍在运行它完成启动所需要的操作：例如， 从某个容器镜像仓库拉取容器镜像，或者向容器应用 Secret 数据等等。 当你使用 <code>kubectl</code> 来查询包含 <code>Waiting</code> 状态的容器的 Pod 时，你也会看到一个 Reason 字段，其中给出了容器处于等待状态的原因。</p><h3 id="Running（运行中）"><a href="#Running（运行中）" class="headerlink" title="Running（运行中）"></a><code>Running</code>（运行中）</h3><p><code>Running</code> 状态表明容器正在执行状态并且没有问题发生。 如果配置了 <code>postStart</code> 回调，那么该回调已经执行且已完成。 如果你使用 <code>kubectl</code> 来查询包含 <code>Running</code> 状态的容器的 Pod 时， 你也会看到关于容器进入 <code>Running</code> 状态的信息。</p><h3 id="Terminated（已终止）"><a href="#Terminated（已终止）" class="headerlink" title="Terminated（已终止）"></a><code>Terminated</code>（已终止）</h3><p>处于 <code>Terminated</code> 状态的容器已经开始执行并且或者正常结束或者因为某些原因失败。 如果你使用 <code>kubectl</code> 来查询包含 <code>Terminated</code> 状态的容器的 Pod 时， 你会看到容器进入此状态的原因、退出代码以及容器执行期间的起止时间。</p><p>如果容器配置了 <code>preStop</code> 回调，则该回调会在容器进入 <code>Terminated</code> 状态之前执行。</p><h4 id="6-2-容器生命周期回调"><a href="#6-2-容器生命周期回调" class="headerlink" title="6.2 容器生命周期回调"></a>6.2 容器生命周期回调</h4><p>类似于许多具有生命周期回调组件的编程语言框架，例如 Angular、Kubernetes 为容器提供了生命周期回调。 回调使容器能够了解其管理生命周期中的事件，并在执行相应的生命周期回调时运行在处理程序中实现的代码。</p><p>有两个回调暴露给容器：</p><ul><li><p><code>PostStart</code>： 这个回调在容器被创建之后立即被执行。 但是，不能保证回调会在容器入口点（ENTRYPOINT）之前执行。 没有参数传递给处理程序。</p></li><li><p><code>PreStop</code>：在容器因 API 请求或者管理事件（诸如存活态探针、启动探针失败、资源抢占、资源竞争等） 而被终止之前，此回调会被调用。 如果容器已经处于已终止或者已完成状态，则对 preStop 回调的调用将失败。 在用来停止容器的 TERM 信号被发出之前，回调必须执行结束。 Pod 的终止宽限周期在 <code>PreStop</code> 回调被执行之前即开始计数， 所以无论回调函数的执行结果如何，容器最终都会在 Pod 的终止宽限期内被终止。 没有参数会被传递给处理程序。</p></li><li><p>使用容器生命周期回调：</p><pre><code class="yaml">#nginx-container-lifecycle.yamlapiVersion: v1kind: Podmetadata:  name: nginxspec:  containers:  - name: nginx    image: nginx:1.14.2    lifecycle:      postStart: #容器创建过程中执行        exec:          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo postStart &gt;&gt; /start.txt&quot;]      preStop: #容器终止之前执行        exec: #执行命令之后，sleep 30s之后继续关闭容器，为了你能进入容器观察          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo preStop &gt;&gt; /stop.txt &amp;&amp; sleep 30&quot;]    ports:    - containerPort: 80</code></pre></li></ul><h4 id="6-3-容器重启策略"><a href="#6-3-容器重启策略" class="headerlink" title="6.3 容器重启策略"></a>6.3 容器重启策略</h4><p>Pod 的 <code>spec</code> 中包含一个 <code>restartPolicy</code> 字段，其可能取值包括 Always、OnFailure 和 Never。默认值是 Always。</p><p><code>restartPolicy</code> 适用于 Pod 中的所有容器。<code>restartPolicy</code> 仅针对同一节点上 <code>kubelet</code> 的容器重启动作。当 Pod 中的容器退出时，<code>kubelet</code> 会按指数回退方式计算重启的延迟（10s、20s、40s、…），其最长延迟为 5 分钟。 一旦某容器执行了 10 分钟并且没有出现问题，<code>kubelet</code> 对该容器的重启回退计时器执行重置操作。</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginxspec:  containers:  - name: nginx    image: nginx:1.14.2    ports:    - containerPort: 80  restartPolicy: Always</code></pre><h4 id="6-4-自定义容器启动命令"><a href="#6-4-自定义容器启动命令" class="headerlink" title="6.4 自定义容器启动命令"></a>6.4 自定义容器启动命令</h4><p>和Docker一样，k8s中容器也可以通过commad、args修改容器启动之后默认执行的命令以及传递相关参数。但是一般推荐使用command修改启动命令，使用args为启动命令传递参数</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: redis  labels:    app: redisspec:  containers:    - name: redis      image: redis:5.0.10      command:        - &quot;redis-server&quot; #用来指定启动命令      args:        - &quot;--appendonly yes&quot; #用来为启动命令传递参数#      args: [&quot;redis-server&quot;, &quot;--appendonly yes&quot;] 单独使用修改启动命令并传递参数#      args: 另一种语法#        - &quot;redis-server&quot;#        - &quot;--appendonly yes&quot;      imagePullPolicy: IfNotPresent  restartPolicy: Always</code></pre><h4 id="6-5-容器探针"><a href="#6-5-容器探针" class="headerlink" title="6.5 容器探针"></a>6.5 容器探针</h4><p><strong>probe</strong> 是由 kubelet 对容器执行的定期诊断。 要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。</p><h5 id="6-5-1-探针类型"><a href="#6-5-1-探针类型" class="headerlink" title="6.5.1 探针类型"></a>6.5.1 探针类型</h5><p>针对运行中的容器，<code>kubelet</code> 可以选择是否执行以下三种探针，以及如何针对探测结果作出反应：</p><ul><li><p><code>livenessProbe</code>：指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略决定未来。如果容器不提供存活探针， 则默认状态为 <code>Success</code>。</p></li><li><p><code>readinessProbe</code>：指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 <code>Failure</code>。 如果容器不提供就绪态探针，则默认状态为 <code>Success</code>。</p></li><li><p><code>startupProbe</code>：指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，<code>kubelet</code> 将杀死容器， 而容器依其重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 <code>Success</code>。</p></li></ul><h5 id="6-5-2-探针机制"><a href="#6-5-2-探针机制" class="headerlink" title="6.5.2 探针机制"></a>6.5.2 探针机制</h5><p>使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：</p><ul><li><p><code>exec</code>：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</p></li><li><p><code>grpc</code>：使用 <a href="https://grpc.io/">gRPC</a> 执行一个远程过程调用。 目标应该实现 <a href="https://grpc.io/grpc/core/md_doc_health-checking.html">gRPC 健康检查</a>。 如果响应的状态是 “SERVING”，则认为诊断成功。</p></li><li><p><code>httpGet</code>：对容器的 IP 地址上指定端口和路径执行 HTTP <code>GET</code> 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</p></li><li><p><code>tcpSocket</code>：对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</p></li></ul><h5 id="6-5-3-探针结果"><a href="#6-5-3-探针结果" class="headerlink" title="6.5.3 探针结果"></a>6.5.3 探针结果</h5><p>每次探测都将获得以下三种结果之一：</p><p><code>Success</code>（成功）</p><p>容器通过了诊断。</p><p><code>Failure</code>（失败）</p><p>容器未通过诊断。</p><p><code>Unknown</code>（未知）</p><p>诊断失败，因此不会采取任何行动。</p><h5 id="6-5-4-探针参数"><a href="#6-5-4-探针参数" class="headerlink" title="6.5.4 探针参数"></a>6.5.4 探针参数</h5><pre><code class="yaml">initialDelaySeconds: 5 #初始化时间5speriodSeconds: 4 #检测间隔时间4stimeoutSeconds: 1  #默认检测超时时间为1sfailureThreshold: 3  #默认失败次数为3，达到3次后重启podsuccessThreshold: 1  #默认成功次数为1，1次检测成功代表成功</code></pre><h5 id="6-5-5-使用探针"><a href="#6-5-5-使用探针" class="headerlink" title="6.5.5 使用探针"></a>6.5.5 使用探针</h5><ul><li><p>exec探针</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx-exec  labels:    app: nginxspec:  containers:    - name: nginx      image: nginx:1.14.2      ports:        - containerPort: 80      args:        - /bin/sh        - -c        - sleep 7;nginx -g &quot;daemon off;&quot; #这一步会和初始化同时开始运行，也就是初始化5秒后和7秒之间，会检测出一次失败，7秒后启动后检测正常，所以pod不会重启      imagePullPolicy: IfNotPresent      livenessProbe:        exec:          command:            - ls            - /var/run/nginx.pid #查看是否有pid文件        initialDelaySeconds: 5 #初始化时间5秒        periodSeconds: 4 #检测间隔时间为4秒        timeoutSeconds: 1 #默认检测超时时间为1秒        failureThreshold: 3 #默认失败次数为3次，达到3次后重启pod        successThreshold: 1 #默认成功次数为1次，1次代表成功  restartPolicy: Always</code></pre><blockquote><p>说明：</p><ol><li>如果sleep 7s，第一次检测发现失败，但是第二次检测发现成功后容器就一直处于健康状态不重启。</li><li>如果sleep 30s，第一次检测失败，超过3次检测同样失败，k8s就会杀死容器进行重启，反复循环这个过程。</li></ol></blockquote></li><li><p>tcp探针</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx-tcp  labels:    app: nginx-tcpspec:  containers:    - name: nginx      image: nginx:1.14.2      ports:        - containerPort: 80      args:        - /bin/sh        - -c        - sleep 7;nginx -g &quot;daemon off;&quot; #这一步会和初始化同时开始运行，也就是初始化5秒后和7秒之间，会检测出一次失败，7秒后启动后检测正常，所以pod不会重启      imagePullPolicy: IfNotPresent      livenessProbe:        tcpSocket:          port: 80        initialDelaySeconds: 5 #初始化时间5秒        periodSeconds: 4 #检测间隔时间为4秒        timeoutSeconds: 1 #默认检测超时时间为1秒        failureThreshold: 3 #默认失败次数为3次，达到3次后重启pod        successThreshold: 1 #默认成功次数为1次，1次代表成功  restartPolicy: Always</code></pre></li><li><p>http探针</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx-http  labels:    app: nginx-httpspec:  containers:    - name: nginx      image: nginx:1.14.2      ports:        - containerPort: 80      args:        - /bin/sh        - -c        - sleep 7;nginx -g &quot;daemon off;&quot; #这一步会和初始化同时开始运行，也就是初始化5秒后和7秒之间，会检测出一次失败，7秒后启动后检测正常，所以pod不会重启      imagePullPolicy: IfNotPresent      livenessProbe:        httpGet:          port: 80 #访问的端口          path: /index.html #访问路径        initialDelaySeconds: 5 #初始化时间5秒        periodSeconds: 4 #检测间隔时间为4秒        timeoutSeconds: 1 #默认检测超时时间为1秒        failureThreshold: 3 #默认失败次数为3次，达到3次后重启pod        successThreshold: 1 #默认成功次数为1次，1次代表成功  restartPolicy: Always</code></pre></li><li><p>gRPC探针</p></li></ul><h4 id="6-6-资源限制"><a href="#6-6-资源限制" class="headerlink" title="6.6 资源限制"></a>6.6 资源限制</h4><p>在k8s中对于容器资源限制主要分为以下两类：</p><ul><li>内存资源限制：内存请求（request）和内存限制（limit）分配给一个容器。我们保障容器拥有它请求数量的内存，但不允许使用超过限制数量的内存。</li><li>CPU资源限制：为容器设置CPU请求（request）和CPU限制（limit）。容器使用的CPU不能超过所配置的数量。如果系统有空闲的CPU时间，则可以保证给容器分配所请求的数量的CPU资源</li></ul><h5 id="6-6-1-metrics-server"><a href="#6-6-1-metrics-server" class="headerlink" title="6.6.1 metrics-server"></a>6.6.1 metrics-server</h5><blockquote><p>地址：<a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></p></blockquote><p>metrics-server是一个可拓展的、高效的容器资源度量源。简单来说就是一个，指标收集服务。</p><p>安装：</p><pre><code class="shell">#执行下面代码kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml#或者将https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml下载到本地kubectl apply -f components.yaml #推荐这种#注意下载下来的的yml文件需要进行修改，打开文件全文搜索&quot;- --metric-resolution=15s&quot;#然后在它下面，添加&quot;- --kubelet-insecure-tls&quot;即可</code></pre><p>查看：</p><pre><code class="shell">#执行下面命令，看有没有出现mertrics相关的服务即可kubectl get apiservices </code></pre><h5 id="6-6-2-指定cpu、内存请求和限制"><a href="#6-6-2-指定cpu、内存请求和限制" class="headerlink" title="6.6.2 指定cpu、内存请求和限制"></a>6.6.2 指定cpu、内存请求和限制</h5><blockquote><p>具体文档见官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu">https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu</a></p></blockquote><pre><code class="yaml">#resource-limit.yamlpiVersion: v1kind: Podmetadata:  name: resource-limit  labels:    name: resource-limitspec:  containers:  - name: nginx    image: nginx:1.14.2    resources:      requests:        memory: &quot;100Mi&quot;        cpu: &quot;0.5&quot;      limits:        memory: &quot;128Mi&quot;        cpu: &quot;1&quot;    ports:      - containerPort: 80</code></pre><h5 id="6-6-3-查看监控信息"><a href="#6-6-3-查看监控信息" class="headerlink" title="6.6.3 查看监控信息"></a>6.6.3 查看监控信息</h5><pre><code class="shell">kubectl top pod resource-limit(pod名称) </code></pre><h3 id="7-Pod中的init容器"><a href="#7-Pod中的init容器" class="headerlink" title="7. Pod中的init容器"></a>7. Pod中的init容器</h3><p>Init 容器是一种特殊容器，在 Pod 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。</p><h4 id="7-1-init容器的特点"><a href="#7-1-init容器的特点" class="headerlink" title="7.1 init容器的特点"></a>7.1 init容器的特点</h4><p>除开以下几点不同之外，init容器和普通容器非常像：</p><ul><li>它们总是运行到完成。如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 <code>restartPolicy</code> 值为 “Never”，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。</li><li>每个都必须在下一个启动之前成功完成。</li><li>同时 Init 容器不支持 <code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code> 和 <code>startupProbe</code>， 因为它们必须在 Pod 就绪之前运行完成。</li><li>如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。</li><li>Init 容器支持应用容器的全部字段和特性，包括资源限制、 数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同。</li></ul><h4 id="7-2-使用init容器"><a href="#7-2-使用init容器" class="headerlink" title="7.2 使用init容器"></a>7.2 使用init容器</h4><p>你可以在 Pod 的规约中与用来描述应用容器的 <code>containers</code> 数组平行的位置指定 Init 容器。</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: myapp-pod  labels:    app.kubernetes.io/name: MyAppspec:  containers:  - name: myapp-container    image: busybox:1.28    command: [&#39;sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;]  initContainers:  - name: init-myservice    image: busybox:1.28    command: [&#39;sh&#39;, &#39;-c&#39;, &quot;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&quot;]  - name: init-mydb    image: busybox:1.28    command: [&#39;sh&#39;, &#39;-c&#39;, &quot;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&quot;]</code></pre><h2 id="四、Controller控制器"><a href="#四、Controller控制器" class="headerlink" title="四、Controller控制器"></a>四、Controller控制器</h2><h3 id="1-controller控制器"><a href="#1-controller控制器" class="headerlink" title="1. controller控制器"></a>1. controller控制器</h3><blockquote><p>官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/</a></p></blockquote><h4 id="1-1-什么是controller"><a href="#1-1-什么是controller" class="headerlink" title="1.1 什么是controller"></a>1.1 什么是controller</h4><p>kubernetes通常不会直接创建pod，而是通过controller来管理pod。controller定义了pod的部署特性，比如有几个副本，在什么样的node上运行。</p><p>简单定义：controller可以管理pod让pod更具运维能力</p><h4 id="1-2-常见的controller"><a href="#1-2-常见的controller" class="headerlink" title="1.2 常见的controller"></a>1.2 常见的controller</h4><ul><li>Deployment 是最常用的controller，可以管理pod的多个副本，确保pod按照期望状态运行</li><li>Daemset 用于每个node最多只运行一个pod副本的场景，通常用于运行daemon。</li><li>Statefulset 能够保证pod的每个副本在整个生命周期中名称不变，其他controller不提供这个功能。当某个pod发生故障需要删除重启时，pod名称就会发生改变，同时statefulset会保证副本按照固定的顺序启动、更新或者删除。</li><li>Job 用于运行结束就删除的应用，而其他controller中pod通常时长期运行的</li></ul><h4 id="1-3-controller如何管理pod"><a href="#1-3-controller如何管理pod" class="headerlink" title="1.3 controller如何管理pod"></a>1.3 controller如何管理pod</h4><p>控制器通过标签（labels）控制pod</p><h3 id="2-Deployment"><a href="#2-Deployment" class="headerlink" title="2. Deployment"></a>2. Deployment</h3><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/</a></p></blockquote><p>一个Deployment为Pod和ReplicaSet提供声明式更新能力。</p><p>你负责描述Deployment中的目标状态，而Deployment控制器以受控速率更改实际状态，使其变为期望状态。你可以定义Deployment以创建新的ReplicaSet，或者删除现有的Deployment，并通过新的Deployment收养其资源。</p><h4 id="2-1-创建deployment"><a href="#2-1-创建deployment" class="headerlink" title="2.1 创建deployment"></a>2.1 创建deployment</h4><pre><code class="yaml">#deployment.yamlapiVersion: apps/v1 #版本信息kind: Deployment #Deployment控制器副本metadata:  name: nginx-deployment #deployment名称  labels:    app: nginx-deployment #deployment标签名称spec: #描述deployment的细节信息  replicas: 3 #默认有3个副本  selector: #用来告知deployment控制器选择对应标签的pod进行管理，和上面labels不是一个    matchLabels:      app: nginx  template: #描述deployment管理的pod的spec信息    metadata:      name: nginx      labels:        app: nginx #pod标签，和上面selector.matchLabels.app对应    spec:      containers:        - name: nginx-deployment          image: nginx:1.21          imagePullPolicy: IfNotPresent      restartPolicy: Always</code></pre><h4 id="2-2-查看deployment"><a href="#2-2-查看deployment" class="headerlink" title="2.2 查看deployment"></a>2.2 查看deployment</h4><pre><code class="shell">#部署应用kubectl apply -f deployment.yaml#查看deploymentkubectl get deployment#查看podkubectl get po#查看pod详情kubectl describe pod pod-name#查看deployment详情kubectl describe deployment deployment-name#查看pod日志kubectl logs pod-name#进入pod容器终端，-c container-name 可以指定哪个容器kubectl exec -it pod-name --bash#输出配置信息到文件kubectl get deployment nginx-deployment -o yaml &gt;&gt;test.yaml</code></pre><h4 id="2-3-扩缩deployment"><a href="#2-3-扩缩deployment" class="headerlink" title="2.3 扩缩deployment"></a>2.3 扩缩deployment</h4><pre><code class="shell">#查询副本kubectl get rs|replicatset#伸缩副本,replicas值最小值为0kubectl scale deployment deployment-name --replicas=5</code></pre><h4 id="2-4-回滚deployment"><a href="#2-4-回滚deployment" class="headerlink" title="2.4 回滚deployment"></a>2.4 回滚deployment</h4><blockquote><p>说明：</p><p>仅当deployment的pod模版（即.spec.template）发生改变的时候（例如模版的标签或者镜像被更新），才会触发deployment上线，其他更新（例如对deployment的扩容和缩容）不会触发上线动作</p></blockquote><pre><code class="shell">#查看上线状态kubectl rollout status [deployment deployment-name | deployment/deployment-name]#查看历史kubectl rollout history deployment deployment-name #查看某次历史的详情信息kubectl rollout history deployment deployment-name --revision=2#回到上一个版本kubectl rollout undo deployment deployment-name#回到指定版本kubectl rollout undo deployment deployment-name --to-revision=2#重新部署kubectl rollout restart deployment deployment-name#暂停运行，暂停后对deployment的修改不会立刻生效，恢复后才应用设置kubectl rollout pause deployment deployment-name#恢复运行kubectl rollout resume deployment deployment-name</code></pre><h4 id="2-5-删除deployment"><a href="#2-5-删除deployment" class="headerlink" title="2.5 删除deployment"></a>2.5 删除deployment</h4><pre><code class="shell">#删除deploymentkubectl delete [deployment deployment-name|deployment/deployment-name]#强烈推荐这种方式kubectl delete -f deployment.yaml#删除默认命名空间全部资源kubectl delete all --all#删除指定命名空间的全部资源kubectl delete all --all -n namespace-name</code></pre><h3 id="3-StatefulSet"><a href="#3-StatefulSet" class="headerlink" title="3. StatefulSet"></a>3. StatefulSet</h3><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/</a></p></blockquote><h4 id="3-1-什么是StatefulSet"><a href="#3-1-什么是StatefulSet" class="headerlink" title="3.1 什么是StatefulSet"></a>3.1 什么是StatefulSet</h4><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象。</p><blockquote><p>无状态应用：应用本身不存储任何数据的应用称之为无状态应用，比如普通的web程序</p><p>有状态应用：应用本身需要存储数据的应用称之为有状态应用，比如redis、mysql、es等应用</p></blockquote><p>StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p><p>和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p><p>如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p><h4 id="3-2-StatefulSet特点"><a href="#3-2-StatefulSet特点" class="headerlink" title="3.2 StatefulSet特点"></a>3.2 StatefulSet特点</h4><p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：</p><ul><li>稳定的、唯一的网络标识符。</li><li>稳定的、持久的存储。</li><li>有序的、优雅的部署和扩缩。</li><li>有序的、自动的滚动更新。</li></ul><p>在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 Deployment 或者 ReplicaSet 可能更适用于你的无状态应用部署需要。</p><h4 id="3-3-限制"><a href="#3-3-限制" class="headerlink" title="3.3 限制"></a>3.3 限制</h4><ul><li>给定 Pod 的存储必须由 <a href="https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md">PersistentVolume Provisioner</a> 基于所请求的 <code>storage class</code> 来制备，或者由管理员预先制备。</li><li>删除或者扩缩 StatefulSet 并<strong>不会</strong>删除它关联的存储卷。 这样做是为了保证数据安全，它通常比自动清除 StatefulSet 所有相关的资源更有价值。</li><li>StatefulSet 当前需要无头服务来负责 Pod 的网络标识。你需要负责创建此服务。</li><li>当删除一个 StatefulSet 时，该 StatefulSet 不提供任何终止 Pod 的保证。 为了实现 StatefulSet 中的 Pod 可以有序且体面地终止，可以在删除之前将 StatefulSet 缩容到 0。</li><li>在默认 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-management-policies">Pod 管理策略</a>(<code>OrderedReady</code>) 时使用<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#rolling-updates">滚动更新</a>， 可能进入需要<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#forced-rollback">人工干预</a>才能修复的损坏状态。</li></ul><h4 id="3-4-使用StatefulSet"><a href="#3-4-使用StatefulSet" class="headerlink" title="3.4 使用StatefulSet"></a>3.4 使用StatefulSet</h4><pre><code class="yaml">kind: Service #提供外部访问，后续会讲metadata:  name: nginx  labels:    app: nginxspec:  ports:  - port: 80    name: web  clusterIP: None  selector:    app: nginx---apiVersion: apps/v1kind: StatefulSet #StatefulSet控制器metadata:  name: web #StatefulSet控制器名称spec:  selector:    matchLabels:      app: nginx # 必须匹配 .spec.template.metadata.labels  serviceName: &quot;nginx&quot;  replicas: 3 # 默认值是 1  minReadySeconds: 10 # 默认值是 0  template:    metadata:      labels:        app: nginx # 必须匹配 .spec.selector.matchLabels    spec:      terminationGracePeriodSeconds: 10      containers:      - name: nginx        image: registry.k8s.io/nginx-slim:0.8        ports:        - containerPort: 80          name: web        volumeMounts:        - name: www          mountPath: /usr/share/nginx/html #外部卷绑定容器内部这个路径/usr/share/nginx/html  volumeClaimTemplates:  - metadata:      name: www #持久卷名称    spec:      accessModes: [ &quot;ReadWriteOnce&quot; ]      storageClassName: &quot;my-storage-class&quot;      resources:        requests:          storage: 1Gi</code></pre><h3 id="4-DaemonSet"><a href="#4-DaemonSet" class="headerlink" title="4. DaemonSet"></a>4. DaemonSet</h3><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/</a></p></blockquote><h4 id="4-1-什么是DaemonSet控制器"><a href="#4-1-什么是DaemonSet控制器" class="headerlink" title="4.1 什么是DaemonSet控制器"></a>4.1 什么是DaemonSet控制器</h4><p><strong>DaemonSet</strong> 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。</p><p>DaemonSet 的一些典型用法：</p><ul><li>在每个节点上运行集群守护进程</li><li>在每个节点上运行日志收集守护进程</li><li>在每个节点上运行监控守护进程</li></ul><p>一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。</p><h4 id="4-2-使用DaemonSet"><a href="#4-2-使用DaemonSet" class="headerlink" title="4.2 使用DaemonSet"></a>4.2 使用DaemonSet</h4><pre><code class="yaml">#nginx-daeon.yamlapiVersion: apps/v1 #版本信息kind: DaemonSet #DaemonSet控制器metadata:  name: nginx-deployment #DaemonSet名称  labels:    app: nginx-deployment #DaemonSet标签名称spec: #描述DaemonSet的细节信息  selector: #用来告知DaemonSet控制器选择对应标签的pod进行管理，和上面labels不是一个    matchLabels:      app: nginx  template: #描述DaemonSet管理的pod的spec信息    metadata:      name: nginx      labels:        app: nginx #pod标签，和上面selector.matchLabels.app对应    spec:      containers:        - name: nginx-container          image: nginx:1.21          imagePullPolicy: IfNotPresent          resources: &#123;&#125;      restartPolicy: Always</code></pre><h3 id="5-Job"><a href="#5-Job" class="headerlink" title="5. Job"></a>5. Job</h3><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/</a></p></blockquote><h4 id="5-1-什么是Job"><a href="#5-1-什么是Job" class="headerlink" title="5.1 什么是Job"></a>5.1 什么是Job</h4><p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p><p>一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。</p><p>你也可以使用 Job 以并行的方式运行多个 Pod。</p><p>如果你想按某种排期表（Schedule）运行 Job（单个任务或多个并行任务），请参阅 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a></p><h4 id="5-2-使用Job"><a href="#5-2-使用Job" class="headerlink" title="5.2 使用Job"></a>5.2 使用Job</h4><pre><code class="yaml">apiVersion: batch/v1kind: Jobmetadata:  name: pispec:  template:    spec:      containers:        - name: pi          image: perl:5.34.0          imagePullPolicy: IfNotPresent          command:            - perl            - -Mbignum=bpi            - -wle            - print bpi(2000)      restartPolicy: Never  backoffLimit: 4</code></pre><h4 id="5-3-自动清理完成的Job"><a href="#5-3-自动清理完成的Job" class="headerlink" title="5.3 自动清理完成的Job"></a>5.3 自动清理完成的Job</h4><p>完成的 Job 通常不需要留存在系统中。在系统中一直保留它们会给 API 服务器带来额外的压力。 如果 Job 由某种更高级别的控制器来管理，例如 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>， 则 Job 可以被 CronJob 基于特定的根据容量裁定的清理策略清理掉。</p><ul><li><p>已完成 Job 的 TTL 机制：自动清理已完成 Job （状态为 <code>Complete</code> 或 <code>Failed</code>）的另一种方式是使用由 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/">TTL 控制器</a>所提供的 TTL 机制。 通过设置 Job 的 <code>.spec.ttlSecondsAfterFinished</code> 字段，可以让该控制器清理掉已结束的资源。TTL 控制器清理 Job 时，会级联式地删除 Job 对象。 换言之，它会删除所有依赖的对象，包括 Pod 及 Job 本身。 注意，当 Job 被删除时，系统会考虑其生命周期保障，例如其 Finalizers。</p><pre><code class="yaml">apiVersion: batch/v1kind: Jobmetadata:  name: pi-with-ttlspec:  ttlSecondsAfterFinished: 100  template:    spec:      containers:      - name: pi        image: perl:5.34.0        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]      restartPolicy: Never</code></pre><p>Job <code>pi-with-ttl</code> 在结束 100 秒之后，可以成为被自动删除的对象。</p><p>如果该字段设置为 <code>0</code>，Job 在结束之后立即成为可被自动删除的对象。 如果该字段没有设置，Job 不会在结束之后被 TTL 控制器自动清除。</p></li></ul><h3 id="6-控制器无法解决的问题"><a href="#6-控制器无法解决的问题" class="headerlink" title="6. 控制器无法解决的问题"></a>6. 控制器无法解决的问题</h3><ul><li>如何为Pod服务提供网络</li><li>如何实现多个Pod之间的负载均衡</li></ul><h2 id="五、Service"><a href="#五、Service" class="headerlink" title="五、Service"></a>五、Service</h2><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/</a></p></blockquote><h3 id="1-什么是Service"><a href="#1-什么是Service" class="headerlink" title="1. 什么是Service"></a>1. 什么是Service</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>将运行在一个或一组Pod上的网络应用公开为网络服务的方法。</p><h4 id="1-2-为什么需要Service"><a href="#1-2-为什么需要Service" class="headerlink" title="1.2 为什么需要Service"></a>1.2 为什么需要Service</h4><p>问题：如果一组Pod（后端服务器）为集群内的其他Pod（前端服务器）提供功能，那么前端如何找出并跟踪要链接的IP地址，以便前端可以使用提供工作负载的后端服务？</p><p><img src="/images/k8s04.png" alt="noservice"></p><p>service定义的抽象能够解耦这种关联</p><p><img src="/images/k8s05.png" alt="service"></p><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h3><ul><li>Service通过label关联对应的Pod</li><li>Service生命周期不与Pod绑定，不会应为Pod重新创建而改变IP</li><li>提供了负载均衡的功能，自动转发流量到不同的Pod</li><li>可对集群外部提供访问端口</li><li>集群内部可通过服务名称访问</li></ul><h3 id="3-Service和Pod的关系"><a href="#3-Service和Pod的关系" class="headerlink" title="3. Service和Pod的关系"></a>3. Service和Pod的关系</h3><p><img src="/images/k8s06.png" alt="service-pod-relation"></p><h3 id="4-使用Service"><a href="#4-使用Service" class="headerlink" title="4. 使用Service"></a>4. 使用Service</h3><pre><code class="yaml">apiVersion: apps/v1kind: Deployment #定义一个deployment控制器metadata:  name: nginx-deployment #控制器名称  labels:    app: nginx-deployment #控制器标签spec:  replicas: 1 #创建副本数，如果是多个的话，service就具有负载均衡的功能  selector:    matchLabels:      app: nginx-pod #管理的pod的标签  template:    metadata:      name: nginx-pod #定义pod的名称      labels:        app: nginx-pod #定义pod的标签    spec:      containers:        - name: nginx-container          image: nginx:1.21          imagePullPolicy: IfNotPresent      restartPolicy: Always---apiVersion: v1kind: Service #定义一个servicemetadata:  name: nginx-service #service名称spec:  selector:    app: nginx-pod #service管理的pod的标签  ports:    - protocol: TCP #传输协议      port: 80 #对外暴露的端口      targetPort: 80 #绑定容器的端口  type: NodePort #一种service类型，既集群外部访问，又可以集群内部访问</code></pre><p>通过<code>kubectl get service</code>，查看服务信息，其中**PORT(S)**中的端口（80:30667&#x2F;TCP），80是在集群内部访问，30667可以在集群外部访问 。我本地使用的环境是docker内置的k8s单机环境，因此我可以直接访问<a href="http://localhost:30667，可以看到nginx的首页。">http://localhost:30667，可以看到nginx的首页。</a></p><h3 id="5-多端口"><a href="#5-多端口" class="headerlink" title="5. 多端口"></a>5. 多端口</h3><pre><code class="yaml">apiVersion: apps/v1kind: Deployment #定义一个deployment控制器metadata:  name: nginx-deployment #控制器名称  labels:    app: nginx-deployment #控制器标签spec:  replicas: 1 #创建副本数  selector:    matchLabels:      app: nginx-pod #管理的pod的标签  template:    metadata:      name: nginx-pod #定义pod的名称      labels:        app: nginx-pod #定义pod的标签    spec:      containers:        - name: nginx-container          image: nginx:1.21          imagePullPolicy: IfNotPresent      restartPolicy: Always---apiVersion: v1kind: Service #定义一个servicemetadata:  name: nginx-service #service名称spec:  selector:    app: nginx-pod #service管理的pod的标签  ports:    - name: write #端口名称，多端口必须指定，相当于端口唯一标识      protocol: TCP      port: 80 #对外暴露的端口      targetPort: 80 #绑定容器的端口      nodePort: 31001 #node 节点端口固定在30000-32767之间    - name: read #端口名称，多端口必须指定，相当于端口唯一标识      protocol: TCP      port: 80      targetPort: 80 #绑定容器的端口      nodePort: 31002 #node 节点端口固定在30000-32767之间  type: NodePort #一种service类型，既集群外部访问，又可以集群内部访问</code></pre><h3 id="6-类型"><a href="#6-类型" class="headerlink" title="6. 类型"></a>6. 类型</h3><p>对一些应用的某些部分（如前端），可能希望将其暴露给 Kubernetes 集群外部的 IP 地址。</p><p>Kubernetes <code>ServiceTypes</code> 允许指定你所需要的 Service 类型。</p><ul><li><strong>ClusterIP</strong>：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是你没有为服务显式指定 <code>type</code> 时使用的默认值。 你可以使用 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress</a> 或者 <a href="https://gateway-api.sigs.k8s.io/">Gateway API</a> 向公众暴露服务。</li><li><strong>NodePort</strong>：通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 为了让节点端口可用，Kubernetes 设置了集群 IP 地址，这等同于你请求 <code>type: ClusterIP</code> 的服务。</li><li><strong>LoadBalancer</strong>：使用云提供商的负载均衡器向外部暴露服务。 Kubernetes 不直接提供负载均衡组件；你必须提供一个，或者将你的 Kubernetes 集群与云提供商集成。</li><li><strong>ExternalName</strong>：将服务映射到 <code>externalName</code> 字段的内容（例如，映射到主机名 <code>api.foo.bar.example</code>）。 该映射将集群的 DNS 服务器配置为返回具有该外部主机名值的 <code>CNAME</code> 记录。 无需创建任何类型代理。</li></ul><h4 id="6-1-ClusterIP类型"><a href="#6-1-ClusterIP类型" class="headerlink" title="6.1 ClusterIP类型"></a>6.1 ClusterIP类型</h4><p><strong>这是最常用的Service类型之一</strong>。在集群内部创建一个虚拟IP地址，它可以被其他在同一集群内的pod访问，但不能被集群外部的请求访问。这种类型的服务通常用于内部服务的暴露，例如数据库或者缓存服务。比如在一个web服务中，你可能需要连接到数据库，但是这个数据库并不需要在应用之外暴露。这个时候，你可以使用ClusterIP类型的Service，让应用可以访问到数据库。</p><h4 id="6-2-NodePort类型"><a href="#6-2-NodePort类型" class="headerlink" title="6.2 NodePort类型"></a>6.2 NodePort类型</h4><p>这种类型的Service会创建一个端口，并绑定到每个集群的节点上，从而允许外部流量访问Service。这个类型通常用于公共服务的暴露，例如web应用或者API。</p><p>如果你将type类型字段设置为NodePort，则Kubernetes控制平面将在–service-node-port-range标志指定的范围内分配端口（默认值：30000-32767）。</p><h4 id="6-3-LoadBalancer类型"><a href="#6-3-LoadBalancer类型" class="headerlink" title="6.3 LoadBalancer类型"></a>6.3 LoadBalancer类型</h4><p>这种类型Service类似于NodePort，但是会在云厂商中创建一个负载均衡器。这个类型通常用在云平台上部署应用。云平台的负载均衡器将流量分发到集群节点。这个类型的Serivice只能在云平台使用，并且需要云厂商提供支持。</p><h4 id="6-4-ExternalName类型"><a href="#6-4-ExternalName类型" class="headerlink" title="6.4 ExternalName类型"></a>6.4 ExternalName类型</h4><p>这种类型的Serivce允许Service到任何需要访问的CNAME DNS条目转发。与其他类型不同的是，它并不会代理请求到任何Pod。相反，它将请求转发到配置的外部地址。这种类型的Service通常用于将服务代理到集群外部的其他服务。比如你有一个外部网络上的服务，你希望在kubernetes集群中使用该服务，这个时候你可以创建一个ExternalName类型的服务，将服务的DNS解析到kubernetes集群中。</p><h3 id="7-内部通信"><a href="#7-内部通信" class="headerlink" title="7. 内部通信"></a>7. 内部通信</h3><p>通过serivce名称+端口号访问，例子：<a href="http://nginx-service/">http://nginx-service:80</a></p><h2 id="六、存储"><a href="#六、存储" class="headerlink" title="六、存储"></a>六、存储</h2><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/storage/">https://kubernetes.io/zh-cn/docs/concepts/storage/</a></p></blockquote><h3 id="1-卷"><a href="#1-卷" class="headerlink" title="1 卷"></a>1 卷</h3><p>容器中的文件在磁盘上是临时存放的，这给在容器中运行较重要的应用带来一些问题。 当容器崩溃或停止时会出现一个问题。此时容器状态未保存， 因此在容器生命周期内创建或修改的所有文件都将丢失。 在崩溃期间，kubelet 会以干净的状态重新启动容器。 当多个容器在一个 Pod 中运行并且需要共享文件时，会出现另一个问题。 跨所有容器设置和访问共享文件系统具有一定的挑战性。</p><p>Kubernetes 卷（Volume）这一抽象概念能够解决这两个问题。</p><h3 id="2-卷的类型"><a href="#2-卷的类型" class="headerlink" title="2 卷的类型"></a>2 卷的类型</h3><p>Kubernetes 支持很多类型的卷。 Pod 可以同时使用任意数目的卷类型。 [、临时卷类型的生命周期与 Pod 相同， 但持久卷可以比 Pod 的存活期长。 当 Pod 不再存在时，Kubernetes 也会销毁临时卷；不过 Kubernetes 不会销毁持久卷。 对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。</p><p>卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。 所采用的特定的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。常用类型的卷有：configMap、emptyDir、local、nfs、secret等。</p><ul><li>ConfigMap：可以将配置文件以键值对的方式保存到ConfigMap中，并且可以在Pod中以文件或者环境变量的形式使用。ConfigMap可以用来存储不敏感的配置信息，如应用程序的配置文件</li><li>EmptyDir：是一个空目录，可以在Pod中存放临时数据，当Pod被删除时，该目录也会被删除。</li><li>Local：将本地文件系统的目录或者文件映射到Pod中的一个Volume中，可以用来在Pod中共享文件或者数据。</li><li>NFS：能将网络上一个或者多个NFS共享目录挂在到Pod中的Volumn中，可以用来在多个Pod之间共享数据。</li><li>Secret：将敏感信息以密文的形式保存到Secret中，并且可以在Pod中以文件或者环境变量的形式使用。Secret可以用来存储敏感信息，比如：用户名密码、证书等。</li></ul><h3 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3 使用方式"></a>3 使用方式</h3><p>使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在 <code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。 容器中的进程看到的文件系统视图是由它们的容器镜像的初始内容以及挂载在容器中的卷（如果定义了的话）所组成的。 其中根文件系统同容器镜像的内容相吻合。 任何在该文件系统下的写入操作，如果被允许的话，都会影响接下来容器中进程访问文件系统时所看到的内容。</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx  labels:    app: nginxspec:  volumes:    ***  containers:    - name: nginx-container      image: nginx:1.21      imagePullPolicy: IfNotPresent      volumeMounts:        ***  restartPolicy: Always</code></pre><h3 id="4-常见类型"><a href="#4-常见类型" class="headerlink" title="4 常见类型"></a>4 常见类型</h3><h4 id="4-1-EmptyDir"><a href="#4-1-EmptyDir" class="headerlink" title="4.1 EmptyDir"></a>4.1 EmptyDir</h4><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginx-deploymentspec:  replicas: 1  selector:    matchLabels:      app: nginx-pod  template:    metadata:      name: nginx-pod      labels:        app: nginx-pod    spec:      containers:        - name: writer          image: busybox          command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo &#39;hello world&#39; &gt; /data/hello.txt; sleep 3600&quot; ]          volumeMounts:            - mountPath: /data              name: shared-data          imagePullPolicy: IfNotPresent        - name: reader          image: busybox          command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;cat /data/hello.txt; sleep 3600&quot; ]          volumeMounts:            - mountPath: /data              name: shared-data #指定要绑定的volume          imagePullPolicy: IfNotPresent      volumes:        - name: shared-data #定一个volume          emptyDir: &#123;&#125; #指定volume的类型      restartPolicy: Always</code></pre><h4 id="4-2-HostPath"><a href="#4-2-HostPath" class="headerlink" title="4.2 HostPath"></a>4.2 HostPath</h4><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  labels:    app: nginxspec:  replicas: 1  selector:    matchLabels:      app: nginx  template:    metadata:      name: nginx      labels:        app: nginx    spec:      containers:        - name: busybox          image: busybox          command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo &#39;hello world&#39; &gt; /data/hello.txt&quot; ]          volumeMounts:            - mountPath: /data              name: shared-data          imagePullPolicy: IfNotPresent      volumes:        - name: shared-data          hostPath:            path: /root/data      restartPolicy: Always</code></pre><h4 id="4-3-NFS"><a href="#4-3-NFS" class="headerlink" title="4.3 NFS"></a>4.3 NFS</h4><p>NFS （ network filesystem:网络文件存储系统）</p><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  labels:    app: nginxspec:  replicas: 1  selector:    matchLabels:      app: nginx  template:    metadata:      name: nginx      labels:        app: nginx    spec:      containers:        - name: busybox          image: busybox          command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo &#39;hello world&#39; &gt; /data/hello.txt&quot; ]          volumeMounts:            - mountPath: /data              name: shared-data          imagePullPolicy: IfNotPresent      volumes:        - name: shared-data          nfs:              server: [服务器ip]            path: /root/data #映射地址      restartPolicy: Always</code></pre><h3 id="5-PV-amp-PVC"><a href="#5-PV-amp-PVC" class="headerlink" title="5. PV &amp; PVC"></a>5. PV &amp; PVC</h3><h4 id="5-1-问题"><a href="#5-1-问题" class="headerlink" title="5.1 问题"></a>5.1 问题</h4><p>Volume提供了非常好的数据持久化方案，不过在可管理性上还有不足。拿前面nfs例子说，要使用volume，Pod必须要知道以下信息：</p><ul><li>当前的volumn类型，并且明确volumn已经创建好了</li><li>必须知道volumn的具体地址信息</li></ul><p>但是Pod通常是由开发人员维护，Volumn则通常由存储系统的管理员维护。开发人员要获得上面的信息，要么询问管理员，要么自己就是管理员。这样问题就来了，开发人员和系统管理人员职责耦合。如果系统比较小或者是开发环境，是可以接受的，但是当集群规模变大，特别是对于生产环境，考虑到事故和安全性，这就成了必须要解决的问题。</p><h4 id="5-2-PV-amp-PVC"><a href="#5-2-PV-amp-PVC" class="headerlink" title="5.2 PV &amp; PVC"></a>5.2 PV &amp; PVC</h4><p><strong>持久卷（PersistentVolume，PV）</strong> 是集群中的一块存储，可以由管理员事先制备， 或者使用存储类（Storage Class）来动态制备。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样， 也是使用卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。</p><p><strong>持久卷申领（PersistentVolumeClaim，PVC）</strong> 表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式 </p><h4 id="5-3-基本使用"><a href="#5-3-基本使用" class="headerlink" title="5.3 基本使用"></a>5.3 基本使用</h4><ul><li><p>创建pv</p><pre><code class="yaml">apiVersion: v1kind: PersistentVolumemetadata:  name: nfs-pvspec:  capacity:    storage: 1Gi #指定容量大小  accessModes:    - ReadWriteMany  persistentVolumeReclaimPolicy: Retain  storageClassName: nfs  nfs:    path: /&#123;nfs-目录名称&#125;    server: &#123;nfs-server IP 地址&#125;</code></pre></li><li><p>accessModes：支持的访问模式有3种：</p><ul><li>ReadWriteOnce表示PV能以readwrite模式mount到单个节点。这个PV只能被某个节点以读写的方式挂在，意味着这个PV只能被一个Pod挂在到某个节点上，并且这个Pod可以对这个PV进行读写操作。如果尝试在其他节点上挂载这个PV，就会失败</li><li>ReadOnlyMany表示PV能以read-only的方式mount到多个节点。这个PV能被多个节点以只读的方式挂载，意味着这个PV可以被多个Pod挂载到多个节点上。</li><li>ReadWriteMany表示PV能以read-write模式mount到多个节点。这个PV能被多个节点以读写的方式挂载，意味着这个PV可以被多个Pod挂载到多个节点上。</li></ul></li><li><p>persistentVolumeReclaimPolicy：指定PV的回收策略，支持三种策略</p><ul><li><p>Retain：在PVC被删除后，保留PV和其数据，手动清理PV中的数据</p></li><li><p>Delete：在PVC被删除后，自动删除PV和其数据</p></li><li><p>Recycle：在PVC被删除后，通过删除PV中的数据来准备PV以供重新使用</p><blockquote><p>注意：persistentVolumeReclaimPolicy只适用于一些类型的PV，如NFS、HostPath等。对于一些云平台提供的存储，如AWS EBS和Azure Disk，由于地层提供商会自充处理PV的回收问题，因此该属性不适用。</p></blockquote></li></ul></li><li><p>storageClassName：指定PV的class为nfs。相当于为PV设置一个分类，PVC可以指定class申请相应class的PV。</p></li><li><p>创建PVC</p><pre><code class="yaml">apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: nfs-pvcspec:  accessModes:    - ReadWriteMany  resources:    requests:      storage: 1Gi  storageClassName: nfs #通过名称选择PV</code></pre></li><li><p>使用PVC</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: pvc-pod  labels:    app: pvc-podspec:  containers:    - name: pvc-pod      image: busybox      command: [&quot;/bin/sh&quot;]      args: [&quot;-c&quot;, &quot;while true; do echo &#39;Hello NFS!&#39; &gt;&gt;/data/index.html; sleep 1; done&quot;]      volumeMounts:        - mountPath: /data          name: nfs-volume      imagePullPolicy: IfNotPresent  volumes:    - name: nfs-volume      persistentVolumeClaim:        claimName: nfs-pvc #使用我们上面定义的pvc  restartPolicy: Always</code></pre></li></ul><h2 id="七、ConfigMap-amp-Secret"><a href="#七、ConfigMap-amp-Secret" class="headerlink" title="七、ConfigMap &amp; Secret"></a>七、ConfigMap &amp; Secret</h2><h3 id="1-ConfigMap"><a href="#1-ConfigMap" class="headerlink" title="1. ConfigMap"></a>1. ConfigMap</h3><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/">https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/</a></p></blockquote><h4 id="1-1-简介-1"><a href="#1-1-简介-1" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p>在kubernetes中，ConfigMap是一种用于存储非敏感信息的kubernetes对象。它用于存储配置数据，如键值对、整个配置文件或者JSON数据等。ConfigMap通常用于容器镜像的配置文件、命令行参数和环境变量。</p><p>ConfigMap可以通过三种方式进行配置数据的注入：</p><ol><li>环境变量注入：将配置数据注入到Pod中的容器环境变量中</li><li>配置文件注入：将配置数据注入到Pod中的容器文件系统中，容器可以读取这些文件。</li><li>命令行参数注入：将配置数据注入到容器的命令行参数中。</li></ol><h4 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h4><ol><li>避免硬编码，将配置数据与应用代码分离</li><li>便于维护和更新，可以单独修改ConfigMap而不需要重新构建镜像</li><li>可以通过多种方式注入配置数据，更加灵活</li><li>可以通过kubernetes的自动化机制对ConfigMap进行版本控制和回滚</li><li>ConfigMap可以被多个Pod共享，减少了配置数据的重复存储</li></ol><h4 id="1-3-定义ConfigMap"><a href="#1-3-定义ConfigMap" class="headerlink" title="1.3 定义ConfigMap"></a>1.3 定义ConfigMap</h4><ul><li><p>基本操作</p><pre><code class="shell">#查看configmapkubectl get cm/configmap#查看详情kubectl describe cm my-config#删除kubectl delete cm my-config</code></pre></li><li><p>命令行创建</p><p>可以使用<code>kubectl create configmap</code>命令来创建configMap，具体命令如下：</p><pre><code class="shel">kubectl create configmap my-config --from-literal=key1=value1  --from-literal=key2=value2</code></pre></li><li><p>通过配置文件创建（推荐）</p><p>可以通过创建YAML文件的方式来定义ConfigMap。例如创建一个名为my-config的configMap，内容如下：</p><pre><code class="yaml">apiVersion: v1kind: ConfigMapmetadata:  name: my-configdata:  key1: &quot;v1&quot;  key2: &quot;v2&quot;  key3: &quot;v3&quot;  key4: &quot;v4&quot;</code></pre></li><li><p>通过文件创建</p><pre><code class="shell">echo -n admin &gt; ./usernameecho -n 123456 &gt; ./passwordkubectl create configmap my-config --from-file=./username --from-file=./password</code></pre></li><li><p>通过文件夹创建</p><p>可以将多个配置文件当道同一个文件夹下，然后使用<code>kubectl create configmap</code>命令创建</p><pre><code class="shell">kubectl create configmap my-config --from-file=config-files/</code></pre></li><li><p>通过环境变量创建 </p><p>可以将环境变量的值转换成configMap。例如，使用如下命令将当前环境变量的值转成configmap。</p><pre><code class="shell">kubectl create configmap my-config --from-env-file=env</code></pre></li></ul><h4 id="1-4-使用configmap"><a href="#1-4-使用configmap" class="headerlink" title="1.4 使用configmap"></a>1.4 使用configmap</h4><ul><li><p>环境变量中使用</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: mypod  labels:    app: mypodspec:  containers:    - name: mypod      image: busybox      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $BUSY_NAME; sleep 3600; &quot;]      env:        #name:代表容器中需要的环境变量名称        - name: BUSY_NAME          #valueFrom:上面环境变量的值来源于哪          valueFrom:            configMapKeyRef: #值来源于configMap              name: my-config #来源于哪个configMap              key: name #来源于configMap中的哪个key#下面这种方式是一次性整个configmap值都注入#      envFrom:#        - configMapRef:#            name: my-config      imagePullPolicy: IfNotPresent  restartPolicy: Always</code></pre><p><code>注意：env是指定configmap中的某个key， envFrom是整个configmap都注入</code></p></li><li><p>volume中使用</p><pre><code class="yaml">#创建一个configmapapiVersion: v1kind: ConfigMapmetadata:  name: my-config2data:  application.yml: | #将｜后面参数加入到configmap中    name: &quot;asda&quot;    age: &quot;1231&quot;</code></pre><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: mypod  labels:    app: mypodspec:  containers:    - name: mypod      image: busybox      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot; sleep 3600; &quot;]      volumeMounts: #通过volumnmount挂载配置文件        - mountPath: /data #挂载容器内路径          name: config-volume #绑定的volumn名称  volumes:    - name: config-volume #创建一个volumn卷      configMap:        name: my-config2 #来源是名字是my-config2的configmap#进入容器，可以看到一个/data/application.yml 文件</code></pre></li></ul><h3 id="2-Secret"><a href="#2-Secret" class="headerlink" title="2. Secret"></a>2. Secret</h3><blockquote><p>官网地址：<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/">https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/</a></p></blockquote><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。 这样的信息可能会被放在 Pod 规约中或者镜像中。 使用 Secret 意味着你不需要在应用程序代码中包含机密数据。</p><p>在kubernetes中，secrets通常被用于以下场景：</p><ul><li>作为卷挂载到pod中，用于存储证书、密钥等敏感文件</li><li>在pod中使用环境变量，用于存储用户名和密码等敏感信息</li><li>用于存储Dokcer镜像仓库的登录信息</li><li>用于存储外部服务的API密钥</li></ul><blockquote><p>注意⚠️：</p><p>secret并不提供强大的安全验证，只是将数据简单存储在base64编码下，并不提供加密或者其他安全措施，因此不要将高度敏感的信息存储在secret中。在处理高度敏感的信息时，需要使用更高级别的保护机制，如使用加密数据的Volume类型，或者使用第三方加密方案。</p></blockquote><h4 id="2-2-定义secret"><a href="#2-2-定义secret" class="headerlink" title="2.2 定义secret"></a>2.2 定义secret</h4><ul><li><p>使用命令行创建</p><pre><code class="shell">kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password=admin123 </code></pre></li><li><p>使用YAML创建</p><pre><code class="yaml">apiVersion: v1kind: Secretmetadata:  name: my-secretdata:  username: YWRtaW4= #admin的base64编码  password: YWRtaW4xMjM= #admin123的base64编码</code></pre></li><li><p>使用文件创建</p><pre><code class="shell">echo -n admin &gt; ./usernameecho -n 123456 &gt; ./passwordkubectl create secret generic my-secret --from-file=./username --from-file=./password</code></pre></li><li><p>通过环境变量创建</p><pre><code class="shell">kubectl create secret generic my-secret --from-env-file=env</code></pre></li></ul><h4 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h4><p>  参考configmap，基本一样。</p><h2 id="八、Ingress"><a href="#八、Ingress" class="headerlink" title="八、Ingress"></a>八、Ingress</h2><blockquote><p>官网：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/</a></p></blockquote><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Ingress 是一种kubernetes资源类型，它允许在kubernetes集群中暴露http和https服务。通过ingress，你可以将流量转发到不同的服务和端点，而无需使用不同的负载均衡器。ingress通常使用Ingress Controller实现。它是一个运行在kubernetes集群中的负载均衡器，它根据ingress规则配置路由规则，并将流量转发到相应的服务器。</p><p>在kubernetes中，一个ingress资源定义了一组规则，这些规则用于指定外部流量如何达到集群中的服务。Ingress资源定义包括域名、服务、路径和其他信息。通过这些信息，Ingress Controller就能将请求路由到正确的服务。同时，Ingress还提供tls选项，可以使用ssl&#x2F;tls来加密传输数据。</p><p>Ingress简单示例：</p><p><img src="/images/k8s07.svg" alt="ingress"></p><h3 id="2-Ingress-和-Service区别"><a href="#2-Ingress-和-Service区别" class="headerlink" title="2. Ingress 和 Service区别"></a>2. Ingress 和 Service区别</h3><p>Ingress 和 Service都是kubernetes中用于将流量路由到应用程序的机制，但它门在路由层面上有所不同：</p><ul><li>Service是kubernetes中抽象的应用程序服务，它公开了一个单一的IP地址和端口，可以用在kubernetes集群内部的Pod之间进行流量路由</li><li>Ingress是kubernetes资源对象，它提供了对集群外部流量路由的规则。Ingress通过一个公共IP地址和端口将流量路由到一个或多个Service</li></ul><h3 id="3-Ingress-Controller"><a href="#3-Ingress-Controller" class="headerlink" title="3. Ingress Controller"></a>3. Ingress Controller</h3><p>Ingress Controller是kubernetes中的一种资源，它负责将外部请求转发到集群内部的Service中，并提供负载均衡、SSL终止等功能。</p><p>Ingress Controller通常会运行在kubernetes集群中，作为一组Deployment和Service的形式部署。</p><p>常见的Ingress Controller包括：</p><ol><li>Nginx Ingress Controller是有kubernetes社区维护的另一个Ingress Controller，它也是使用Nginx作为反向代理实现的，可以支持HTTP和HTTPS等协议，支持负载均衡、路由、HTTPS证书管理等功能</li><li>Ingress Nginx Controller是官方维护的一个Ingress Controller，它是使用Nginx作为反向代理实现的，可以支持HTTP和HTTPS等协议，支持负载均衡、路由、HTTPS证书管理等功能</li><li>Traefik Ingress Controller：基于go开发的Ingress Controller，支持多种路由匹配方式和多种后端服务发现方式。</li><li>Istio Ingress Controller：基于Istio Service Mesh实现的Ingress Controller，提供了更丰富的负载均衡、流量控制和安全功能。</li><li>Kong Ingress Controller：使用Kong作为反向代理实现Ingress功能，支持API管理和gateway功能。</li></ol><h3 id="4-使用Traefik-Ingress-Controller"><a href="#4-使用Traefik-Ingress-Controller" class="headerlink" title="4. 使用Traefik Ingress Controller"></a>4. 使用Traefik Ingress Controller</h3><blockquote><p>地址：<a href="https://doc.traefik.io/">https://doc.traefik.io/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Kubernetes学习&quot;&gt;&lt;a href=&quot;#Kubernetes学习&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes学习&quot;&gt;&lt;/a&gt;Kubernetes学习&lt;/h1&gt;&lt;h2 id=&quot;一、初识K8S&quot;&gt;&lt;a href=&quot;#一、初识K8S&quot; class=&quot;headerlink&quot; title=&quot;一、初识K8S&quot;&gt;&lt;/a&gt;一、初识K8S&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/overview/&quot;&gt;https://kubernetes.io/zh-cn/docs/concepts/overview/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt; 这个名字源于希腊语，意为“舵手”或“飞行员”，简称k8s。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt; 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 &lt;strong&gt;Kubernetes&lt;/strong&gt; 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。&lt;/p&gt;</summary>
    
    
    
    <category term="k8s" scheme="https://github/zhuchong6.github.io/categories/k8s/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="k8s" scheme="https://github/zhuchong6.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Nacos学习</title>
    <link href="https://github/zhuchong6.github.io/2023/02/09/2023-02-09nacos%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github/zhuchong6.github.io/2023/02/09/2023-02-09nacos%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-02-09T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>nacos作为配置中心以及注册和发现中心，是我们常用的一个中间件。在微服务生态中，它取代了spring-cloud-config和eureka的位置。本文，就是简单学习这个中间件。</p><span id="more"></span><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><h3 id="隔离方式"><a href="#隔离方式" class="headerlink" title="隔离方式"></a>隔离方式</h3><p>nacos中有三种方式来隔离配置：<strong>namespace</strong>、<strong>group</strong>和<strong>dataId</strong></p><ul><li>namespace：用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 <strong>group</strong> 或 <strong>dataId</strong> 的配置。<strong>namespace</strong> 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</li><li>group：简单理解为多个配置文件的集合</li><li>dataId：简单理解为一个配置文件。</li></ul><p>他们之间的关系可以简单用下图表示：</p><p><img src="/images/nacos1.png" alt="nacos隔离方式"></p><h3 id="dataId的文件扩展名方式"><a href="#dataId的文件扩展名方式" class="headerlink" title="dataId的文件扩展名方式"></a>dataId的文件扩展名方式</h3><p>nacos支持properties和yaml的拓展名方式，默认是properties，如果需要修改需配置bootstrap.properties</p><pre><code class="properties">#修改文件拓展名为yamlspring.cloud.nacos.config.file-extension=yaml</code></pre><h3 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h3><p>nacos支持动态刷新配置，默认开启，需要关闭的时候请修改配置：</p><pre><code class="properties">#关闭动态刷新pring.cloud.nacos.config.refresh.enabled=false </code></pre><h3 id="支持profile粒度的配置"><a href="#支持profile粒度的配置" class="headerlink" title="支持profile粒度的配置"></a>支持profile粒度的配置</h3><p>nacos在加载配置的时候不仅仅加载了以 dataId 为 <code>$&#123;spring.application.name&#125;.$&#123;file-extension:properties&#125;</code> 为前缀的基础配置，还加载了dataId为 <code>$&#123;spring.application.name&#125;-$&#123;profile&#125;.$&#123;file-extension:properties&#125;</code> 的基础配置。在日常开发中如果遇到多套环境下的不同配置，可以通过Spring 提供的 <code>$&#123;spring.profiles.active&#125;</code> 这个配置项来配置</p><h3 id="自定义namespace"><a href="#自定义namespace" class="headerlink" title="自定义namespace"></a>自定义namespace</h3><p>默认Public这个namespace，可以通过如下指定配置：</p><pre><code class="properties">#b3404bc0-d7dc-4855-b519-570ed34b62d7 namespace idspring.cloud.nacos.config.namespace=b3404bc0-d7dc-4855-b519-570ed34b62d7</code></pre><h3 id="自定义group"><a href="#自定义group" class="headerlink" title="自定义group"></a>自定义group</h3><p> 默认使用的是 DEFAULT_GROUP，可以通过如下指定配置：</p><pre><code class="properties">spring.cloud.nacos.config.group=DEVELOP_GROUP</code></pre><h3 id="自定义扩展的dataId配置"><a href="#自定义扩展的dataId配置" class="headerlink" title="自定义扩展的dataId配置"></a>自定义扩展的dataId配置</h3><p>这里只是为了解决通用配置不重复创建的问题，我们通常把一个通用的配置单独列出来，因此会产生以下两种方案。</p><h4 id="共享dataId的方式"><a href="#共享dataId的方式" class="headerlink" title="共享dataId的方式"></a>共享dataId的方式</h4><pre><code class="properties">spring.cloud.nacos.shared.dataids=global.yaml,app-common.yaml,app-local-common.yaml#或者# 配置支持共享的 Data Idspring.cloud.nacos.config.shared-configs[0].data-id=common.yaml# 配置 Data Id 所在分组，缺省默认 DEFAULT_GROUPspring.cloud.nacos.config.shared-configs[0].group=GROUP_APP1# 配置Data Id 在配置变更时，是否动态刷新，缺省默认 falsespring.cloud.nacos.config.shared-configs[0].refresh=true</code></pre><p>为了更加清晰的在多个应用间配置共享的dataId，可以采用上面的方式。</p><blockquote><p>注意：</p><p>为了尽可能的和Nacos使用方式(即dataId 是一个带有额外文件扩展名的)保持一致，这里配置的dataId是一定需要带上文件扩展名的。</p></blockquote><h4 id="通过类似面向对象方式的自定义配置"><a href="#通过类似面向对象方式的自定义配置" class="headerlink" title="通过类似面向对象方式的自定义配置"></a>通过类似面向对象方式的自定义配置</h4><pre><code class="properties">spring.application.name=opensource-service-providerspring.cloud.nacos.config.server-addr=127.0.0.1:8848# config external configuration# 1、Data Id 在默认的组 DEFAULT_GROUP,不支持配置的动态刷新spring.cloud.nacos.config.extension-configs[0].data-id=ext-config-common01.properties# 2、Data Id 不在默认的组，不支持动态刷新spring.cloud.nacos.config.extension-configs[1].data-id=ext-config-common02.propertiesspring.cloud.nacos.config.extension-configs[1].group=GLOBALE_GROUP# 3、Data Id 既不在默认的组，也支持动态刷新spring.cloud.nacos.config.extension-configs[2].data-id=ext-config-common03.propertiesspring.cloud.nacos.config.extension-configs[2].group=REFRESH_GROUPspring.cloud.nacos.config.extension-configs[2].refresh=true</code></pre><p>可以看到：</p><ul><li>通过 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的配置方式来支持多个dataId的配置。</li><li>通过 <code>spring.cloud.nacos.config.extension-configs[n].group</code> 的配置方式自定义dataId所在的组，不明确配置的话，默认是 DEFAULT_GROUP。</li><li>通过 <code>spring.cloud.nacos.config.extension-configs[n].refresh</code> 的配置方式来控制该dataId在配置变更时，是否支持应用中可动态刷新， 感知到最新的配置值。默认是不支持的。</li></ul><blockquote><p>注意：</p><ol><li>多个dataId同时配置时，他的优先级关系是 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 其中 n 的值越大，优先级越高。</li><li><code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的值必须带文件扩展名，文件扩展名既可支持 properties，又可以支持 yaml&#x2F;yml。 此时 <code>spring.cloud.nacos.config.file-extension</code> 的配置对自定义扩展配置的dataId文件扩展名没有影响。</li></ol></blockquote><p><strong>这种方式既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个配置文件</strong></p><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><p>Spring Cloud Alibaba Nacos Config 目前提供了三种配置能力从 Nacos 拉取相关的配置：</p><ol><li>通过内部相关规则(应用名、应用名+ Profile )自动生成相关的dataId配置</li><li>通过 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的方式支持多个扩展dataId的配置</li><li>通过 <code>spring.cloud.nacos.config.shared-configs[n].data-id</code> 支持多个共享dataId的配置</li></ol><p>当三种方式共同使用时，他们的一个优先级关系是： <strong>1&gt;2&gt;3</strong></p><h3 id="关闭配置"><a href="#关闭配置" class="headerlink" title="关闭配置"></a>关闭配置</h3><pre><code class="properties">#完全关闭 Spring Cloud Nacos Configspring.cloud.nacos.config.enabled = false</code></pre><h2 id="注册发现中心"><a href="#注册发现中心" class="headerlink" title="注册发现中心"></a>注册发现中心</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li><p>导入依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>修改配置文件</p><pre><code class="properties">server.port=9093spring.application.name=nacos-discoverymanagement.endpoints.web.exposure.include=*spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848spring.cloud.nacos.discovery.service=nacos-discovery01spring.cloud.nacos.discovery.group=nacos-discoveryspring.cloud.nacos.discovery.namespace=fda084d1-c822-4e79-98da-913f4e1591a5</code></pre></li><li><p>启动类加上注解</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClientpublic class App&#123;    public static void main( String[] args )    &#123;        SpringApplication.run(App.class, args);    &#125;&#125;</code></pre></li></ol><p>完成，启动后就会注册到nacos上，在对应的地方可以看到服务已经注册成功了。</p><h3 id="注册中心配置项目"><a href="#注册中心配置项目" class="headerlink" title="注册中心配置项目"></a>注册中心配置项目</h3><table><thead><tr><th>配置项</th><th>Key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>服务端地址</code></td><td><code>spring.cloud.nacos.discovery.server-addr</code></td><td><code>无</code></td><td><code>Nacos Server 启动监听的ip地址和端口</code></td></tr><tr><td><code>服务名</code></td><td><code>spring.cloud.nacos.discovery.service</code></td><td><code>$&#123;spring.application.name&#125;</code></td><td><code>给当前的服务命名</code></td></tr><tr><td><code>服务分组</code></td><td><code>spring.cloud.nacos.discovery.group</code></td><td><code>DEFAULT_GROUP</code></td><td><code>设置服务所处的分组</code></td></tr><tr><td><code>权重</code></td><td><code>spring.cloud.nacos.discovery.weight</code></td><td><code>1</code></td><td><code>取值范围 1 到 100，数值越大，权重越大</code></td></tr><tr><td><code>网卡名</code></td><td><code>spring.cloud.nacos.discovery.network-interface</code></td><td><code>无</code></td><td><code>当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址</code></td></tr><tr><td><code>注册的IP地址</code></td><td><code>spring.cloud.nacos.discovery.ip</code></td><td><code>无</code></td><td><code>优先级最高</code></td></tr><tr><td><code>注册的端口</code></td><td><code>spring.cloud.nacos.discovery.port</code></td><td><code>-1</code></td><td><code>默认情况下不用配置，会自动探测</code></td></tr><tr><td><code>命名空间</code></td><td><code>spring.cloud.nacos.discovery.namespace</code></td><td><code>无</code></td><td><code>常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</code></td></tr><tr><td><code>AccessKey</code></td><td><code>spring.cloud.nacos.discovery.access-key</code></td><td><code>无</code></td><td><code>当要上阿里云时，阿里云上面的一个云账号名</code></td></tr><tr><td><code>SecretKey</code></td><td><code>spring.cloud.nacos.discovery.secret-key</code></td><td><code>无</code></td><td><code>当要上阿里云时，阿里云上面的一个云账号密码</code></td></tr><tr><td><code>Metadata</code></td><td><code>spring.cloud.nacos.discovery.metadata</code></td><td><code>无</code></td><td><code>使用Map格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息</code></td></tr><tr><td><code>日志文件名</code></td><td><code>spring.cloud.nacos.discovery.log-name</code></td><td><code>无</code></td><td></td></tr><tr><td><code>集群</code></td><td><code>spring.cloud.nacos.discovery.cluster-name</code></td><td><code>DEFAULT</code></td><td><code>配置成Nacos集群名称</code></td></tr><tr><td><code>接入点</code></td><td><code>spring.cloud.nacos.discovery.enpoint</code></td><td><code>UTF-8</code></td><td><code>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</code></td></tr><tr><td><code>是否集成Ribbon</code></td><td><code>ribbon.nacos.enabled</code></td><td><code>true</code></td><td><code>一般都设置成true即可</code></td></tr><tr><td><code>是否开启Nacos Watch</code></td><td><code>spring.cloud.nacos.discovery.watch.enabled</code></td><td><code>true</code></td><td><code>可以设置成false来关闭 watch</code></td></tr><tr><td><code>注册的IP地址类型</code></td><td><code>spring.cloud.nacos.discovery.ip-type</code></td><td><code>IPv4</code></td><td><code>可以配置IPv4和IPv6两种类型</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;nacos作为配置中心以及注册和发现中心，是我们常用的一个中间件。在微服务生态中，它取代了spring-cloud-config和eureka的位置。本文，就是简单学习这个中间件。&lt;/p&gt;</summary>
    
    
    
    <category term="Nacos" scheme="https://github/zhuchong6.github.io/categories/Nacos/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Nacos" scheme="https://github/zhuchong6.github.io/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="https://github/zhuchong6.github.io/2023/02/08/2023-02-08linux%E5%9F%BA%E7%A1%80/"/>
    <id>https://github/zhuchong6.github.io/2023/02/08/2023-02-08linux%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-08T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为一名工程师，linux服务器是无法绕过的一道门槛。这里简单的介绍并使用吧linux，希望能给刚入行的新人一些帮助，在就是作为自己的笔记。</p><span id="more"></span><h2 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h2><p>区别于windows系统，linux中没有盘符的概念，只有一个根目录&#96;&#x2F;，所有的文件都在它的下面，以文件树形态组织。</p><p>在linux系统中，使用<code>/</code>（windows使用<code>\</code>）来表示路径之间的层级关系，例如：</p><pre><code class="bash">#这里表示根目录下有一个root文件夹，root文件夹下面有个hello文件夹，hello文件夹下面有hello.tx文件#这里表示出了，hello.txt文件所在的位置/root/hello/hello.txt</code></pre><h2 id="2-linux命令的入门"><a href="#2-linux命令的入门" class="headerlink" title="2. linux命令的入门"></a>2. linux命令的入门</h2><h3 id="2-1-什么是命令行、命令"><a href="#2-1-什么是命令行、命令" class="headerlink" title="2.1 什么是命令行、命令"></a>2.1 什么是命令行、命令</h3><p>命令行：一般表示Linux终端(Terminal)，就是一个用户操作的界面（影视剧里黑客的敲大黑色框框），用于对linux系统发送命令</p><p>命令：即Linux程序，由linux提供的程序，可以类比为一些系统内置软件。</p><blockquote><p>无论什么命令，下面是它的通用格式：</p><p><code>command [-options] [parameter]</code></p><p>command：必选，命令本身，可以类比播放音乐命令</p><p>[-options]：可选，命令的一些选项，可以通过选项控制命令的行为细节，可以类比为音量调节的按钮就是一个选项</p><p>[parameter]：可选，命令的参数，多数用于命令的指向目标，类比为使用什么设备播放音乐</p><p>案例：</p><p>ls -l &#x2F;home&#x2F;hello这条命令，ls是命令本身，-l是选项，表示以列表的形式，&#x2F;home&#x2F;hello是参数，表示显示这个目录下的内容</p></blockquote><h3 id="2-2-ls显示文件命令"><a href="#2-2-ls显示文件命令" class="headerlink" title="2.2 ls显示文件命令"></a>2.2 ls显示文件命令</h3><p>语法：<code>ls [-a -l -h] [linux路径]</code> </p><ul><li><p>-a：表示列出全部文件，包括隐藏文件</p></li><li><p>-l：表示以列表形式展示内容，并展示更多信息</p></li><li><p>-h：表示以更加人性化的方式显示文件大小，必须于-l一起使用</p></li></ul><blockquote><p>三个命令可以组合使用，例如： ls -al    ls -alh</p></blockquote><h3 id="2-3-cd-x2F-pwd目录切换命令"><a href="#2-3-cd-x2F-pwd目录切换命令" class="headerlink" title="2.3 cd&#x2F;pwd目录切换命令"></a>2.3 cd&#x2F;pwd目录切换命令</h3><p><code>cd /root</code>：表示切换到根目录下面的root目录中</p><p><code>cd </code>或者<code>cd ~</code>：表示切换到&#x2F;home目录下，<code>~</code>这个世Esc键上的符号</p><p><code>pwd</code>：打印工作目录，其实就是打印出你当前所在的目录</p><h3 id="2-4-相对路径和绝对路径"><a href="#2-4-相对路径和绝对路径" class="headerlink" title="2.4 相对路径和绝对路径"></a>2.4 相对路径和绝对路径</h3><p><code>cd /home/hello</code>绝对路径写法，以根路径作为起点</p><p><code>cd hello</code>相对路径写法，以当前目录为起点</p><blockquote><p>特殊路径符</p><p><code>.</code>：表示当前目录</p><p><code>..</code>：表示上一级目录</p><p><code>~</code>：表示HOME目录</p></blockquote><h3 id="2-5-mkdir创建新目录"><a href="#2-5-mkdir创建新目录" class="headerlink" title="2.5 mkdir创建新目录"></a>2.5 mkdir创建新目录</h3><p>语法：<code>mkdir [-p] linux路径</code></p><ul><li>-p：可选，表示自动创建不存在的目录，适用于连续创建多层级目录</li></ul><h3 id="2-6-touchcatmore"><a href="#2-6-touchcatmore" class="headerlink" title="2.6 touchcatmore"></a>2.6 touchcatmore</h3><p>touch语法：<code>touch linux路径</code>,案例：<code>touch /home/hello.txt</code>，用于创建一个文件</p><p>cat语法：<code>cat linu路径</code>，案例：<code>cat /home/hello.txt</code>，用于查看文件内容，相对路径、绝对路径都可以</p><p>more语法：<code>more linux路径</code>同样用于查看文件内容，与cat不同的是，more支持翻页，一般用于查看大文件，案例：<code>more /home/hello.txt</code></p><h3 id="2-7-cp复制文件或者文件夹"><a href="#2-7-cp复制文件或者文件夹" class="headerlink" title="2.7 cp复制文件或者文件夹"></a>2.7 cp复制文件或者文件夹</h3><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li><p>-r：可选，用于复制文件夹使用，表示递归</p></li><li><p>参数1：linux路径，表示被复制文件或者文件夹</p></li><li><p>参数2：linux路径，表示要复制去的地方</p></li></ul><blockquote><p>案例：</p><p>cp test1 test2 表示复制test1到test2，如果test2没有回创建一个</p><p>cp -r folder1 folder2 表示复制文件夹folder1内容到folder2中去</p></blockquote><h3 id="2-8-mv移动文件或者文件夹"><a href="#2-8-mv移动文件或者文件夹" class="headerlink" title="2.8 mv移动文件或者文件夹"></a>2.8 mv移动文件或者文件夹</h3><p>语法：<code>mv 参数1 参数2</code></p><ul><li><p>参数1：被移动的文件或者文件夹</p></li><li><p>参数2：表示要移动到的地方，如果目标不存在，则修改名称为目标名称</p></li></ul><blockquote><p>案例：</p><p>mv &#x2F;home&#x2F;text.txt &#x2F;home&#x2F;ccc&#x2F;aa.txt</p></blockquote><h3 id="2-9-rm删除文件或者文件夹"><a href="#2-9-rm删除文件或者文件夹" class="headerlink" title="2.9 rm删除文件或者文件夹"></a>2.9 rm删除文件或者文件夹</h3><p>语法：<code>rm [-r -f] 参数1 参数2 ... 参数n</code></p><ul><li>-f：表示force，强制删除（不会弹出确认信息）</li><li>-r：同cp命令一样，用于删除文件夹</li></ul><blockquote><p>案例：</p><p>rm text.txt 表示删除当前目录下的text.txt文件</p><p>rm -r &#x2F;home&#x2F;user 表示删除home目录下user文件夹下所有内容</p></blockquote><p><strong>rm支持通配符</strong></p><ul><li>*表示通配符，表示任意内容</li><li>test*，表示匹配任意以test开头的内容</li><li>*test，表示匹配任意以test结尾的内容</li><li>*test*，表示匹配任意包含test的内容</li></ul><h3 id="2-10-which查看命令的存放位置"><a href="#2-10-which查看命令的存放位置" class="headerlink" title="2.10 which查看命令的存放位置"></a>2.10 which查看命令的存放位置</h3><p>语法：<code>which 命令</code></p><blockquote><p>案例：</p><p>which cp    输出：&#x2F;bin&#x2F;cp</p></blockquote><h3 id="2-11-find按照文件名查找文件"><a href="#2-11-find按照文件名查找文件" class="headerlink" title="2.11 find按照文件名查找文件"></a>2.11 find按照文件名查找文件</h3><p>语法：<code>find 起始路径 -name &quot;被查找的文件名&quot;</code></p><blockquote><p>案例：<br>find &#x2F;etc -name “hello”</p></blockquote><p><strong>find支持通配符</strong></p><ul><li>*表示通配符，表示任意内容</li><li>test*，表示匹配任意以test开头的内容</li><li>*test，表示匹配任意以test结尾的内容</li><li>*test*，表示匹配任意包含test的内容</li></ul><h3 id="2-12-find按照文件大小查找文件"><a href="#2-12-find按照文件大小查找文件" class="headerlink" title="2.12 find按照文件大小查找文件"></a>2.12 find按照文件大小查找文件</h3><p>语法：<code>find 起始路径 -size +|-n[kMG]</code></p><ul><li>+、-表示大于和小于</li><li>n表示数字大小</li><li>kMG表示大小单位，k（小写字母）表示KB，M表示MB，G表示GB</li></ul><blockquote><p>案例：</p><p>find .&#x2F;Downloads -size +1G</p></blockquote><h3 id="2-13-grep关键字过滤文件行"><a href="#2-13-grep关键字过滤文件行" class="headerlink" title="2.13 grep关键字过滤文件行"></a>2.13 grep关键字过滤文件行</h3><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>-n：可选，表示在结果中显示匹配行的行号</li><li>关键字：表示过来的关键字，建议使用**””**包裹起来</li><li>文件路径：表示要过滤的内容的文件路径，<strong>可作为内容输入端</strong></li></ul><blockquote><p>案例：</p><p>grep “hello” hello.txt 过滤出hello.txt中包含hello的行</p></blockquote><h3 id="2-14-wc统计文件的行数、单词数量等"><a href="#2-14-wc统计文件的行数、单词数量等" class="headerlink" title="2.14 wc统计文件的行数、单词数量等"></a>2.14 wc统计文件的行数、单词数量等</h3><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>-c：可选，统计bytes数量</li><li>-m：可选，统计字符数量</li><li>-l：可选，统计行数</li><li>-w：可选，统计单词数量</li></ul><blockquote><p>案例：</p><p>wc -c xx.log</p></blockquote><h3 id="2-15-管道符-｜"><a href="#2-15-管道符-｜" class="headerlink" title="2.15 管道符 ｜"></a>2.15 管道符 ｜</h3><p>语法：<code>|</code></p><p>管道符的含义是：<strong>将管道左边的命令的结果作为右边命令的输入</strong></p><blockquote><p>案例：</p><p>cat hello.txt | grep “hello”   将cat hello.txt的结果，放到grep “hello”的右边，grep命令参数右边原本是填一个路径，但是我们上面强调了也可以作为内容输入端，一般这种形式我们查日志比较常用。</p></blockquote><h3 id="2-16-echo"><a href="#2-16-echo" class="headerlink" title="2.16 echo"></a>2.16 echo</h3><p>语法：<code>echo 输出的内容</code></p><ul><li>输出内容：建议使用**””**包围，如果使用`（反引号，esc按键上的）包裹，那么直接执行命令</li></ul><blockquote><p>案例：</p><p>echo “hello world”  输出hello world</p><p>echo `pwd` 等价于执行pwd命令</p></blockquote><h3 id="2-17-重定向符-gt-、-gt-gt"><a href="#2-17-重定向符-gt-、-gt-gt" class="headerlink" title="2.17 重定向符 &gt;、&gt;&gt;"></a>2.17 重定向符 &gt;、&gt;&gt;</h3><ul><li>&gt;：一个表示将左侧命令的结果，<em><strong>覆盖</strong></em>写入到符号右侧指定的文件中</li><li>&gt;&gt;：两个表示将左侧命令的结果，<em><strong>追加</strong></em>写入的符号右侧执行的文件中</li></ul><blockquote><p>案例：</p><p>echo “hellow ada” &gt; hello.txt</p><p>echo “hellow ada” &gt;&gt; hello.txt</p></blockquote><h3 id="2-18-tail查看文件尾部内容，查看文件最新更改"><a href="#2-18-tail查看文件尾部内容，查看文件最新更改" class="headerlink" title="2.18 tail查看文件尾部内容，查看文件最新更改"></a>2.18 tail查看文件尾部内容，查看文件最新更改</h3><p>语法：<code>tail [-f -num] linux路径</code></p><ul><li>-f：表示持续追踪，表示不退出终端一直刷</li><li>-num：表示查看尾部多少行，不写默认10</li></ul><blockquote><p>案例：</p><p>tail -f hello.txt</p><p>tail -20 hello.txt</p></blockquote><h2 id="3-linux用户"><a href="#3-linux用户" class="headerlink" title="3. linux用户"></a>3. linux用户</h2><p>linux中有用户权限管理，一般分配给我们的都是普通用户，普通用户权限在home目录下权限不受限制。出了home目录只有只读和执行权限，无其他权限。因此，需要切换到root用户执行操作，执行<code>su -root</code>然后输入密码即可。</p><h3 id="3-1-切换用户"><a href="#3-1-切换用户" class="headerlink" title="3.1 切换用户"></a>3.1 切换用户</h3><p>语法：<code>su [-] 用户名</code></p><ul><li>-：可选，表示是否在切换用户的时候加载环境变了，建议带上</li><li>切换用户之后，使用exit退回上一个用户</li></ul><h3 id="3-2-sudo为普通命令授权root权限"><a href="#3-2-sudo为普通命令授权root权限" class="headerlink" title="3.2 sudo为普通命令授权root权限"></a>3.2 sudo为普通命令授权root权限</h3><p>一般我们不建议使用root命令，因为失误的话可能会造成严重后果。因此，使用sudo命令为一些我们需要执行的命令，零时提升到root权限去执行。</p><h3 id="3-3-用户和用户组"><a href="#3-3-用户和用户组" class="headerlink" title="3.3 用户和用户组"></a>3.3 用户和用户组</h3><p>linux中可以：</p><ul><li>配置多个用户</li><li>配置多个用户组</li><li>用户可以加入多个用户组</li></ul><p>linux中权限管控级别有2个，分别是：</p><ul><li>针对用户的权限控制</li><li>针对用户组的权限控制</li></ul><p>比如：对于一个文件，可以控制用户的权限，也可以控制用户组的权限</p><h4 id="3-3-1-用户组"><a href="#3-3-1-用户组" class="headerlink" title="3.3.1 用户组"></a>3.3.1 用户组</h4><ul><li><p>查看所有用户组<code>groups</code></p></li><li><p>创建用户组<code>groupadd 用户组名</code></p></li><li><p>删除用户组<code>groupdel 用户组名</code></p></li></ul><h4 id="3-3-2-用户"><a href="#3-3-2-用户" class="headerlink" title="3.3.2 用户"></a>3.3.2 用户</h4><ul><li><p>创建用户</p><p>user add [-g -d] 用户名</p><ul><li>-g：指定用户的组，不指定会创建同名用户组并加入，如果已存在同名用户组必须指定-g</li><li>-d：指定用户HOME路径，不指定默认在：&#x2F;HOME&#x2F;用户名</li></ul></li><li><p>删除用户</p><p>userdel [-r] 用户名</p><ul><li>-r：删除用户的home目录，不指定删除用户HOME保留</li></ul></li><li><p>查看用户所属组</p><p>id [用户名]</p><ul><li>用户名：被查看的用户，如果不提供查看自己</li></ul></li></ul><h3 id="3-4-权限信息"><a href="#3-4-权限信息" class="headerlink" title="3.4 权限信息"></a>3.4 权限信息</h3><p>我们通过ls -l可以查看权限信息，案例如下:</p><pre><code class="bash">#这一列表示权限信息，d开头表示文件夹，-开头表示文件                                #这列表示所属用户                                                #这列表示所属用户组drwx------   5 knight  staff   160  6 28 00:01 Applicationsdrwxr-xr-x   4 knight  staff   128 12 18  2022 Blogsdrwx------  12 knight  staff   384  7 16 00:16 Desktop</code></pre><p>我们来解析下权限的信息：</p><pre><code>drwxr-xr-x第1列：-（文件）、d（目录）、l（软连接）第2，3，4列：表示所属用户权限，r（读权限）w（写权限）x(执行权限)，-（无权限）第5，6，7列：表示所属用户组权限，r（读权限）w（写权限）x(执行权限)，-（无权限）第8，9，10列：表示其他用户权限，r（读权限）w（写权限）x(执行权限)，-（无权限）所以上面的权限解释为：这是一个文件夹所属用户对其权限是：读、写、执行的权限所属用户组对其权限是：读、执行的权限其他用户对其权限是：读、执行的权限</code></pre><p><strong>权限的数字序号</strong></p><p>权限可以用3位数字表示，第一位数字表示用户权限，第二位数字表示用户组权限，第三位数字表示其他用户权限。</p><blockquote><p>数字细节如下，r记为4，w记为2，x记为1：</p><ul><li>0：无任何权限，即—</li><li>1：仅有x权限，即–x</li><li>2：仅有w权限，即-w-</li><li>3：有w和x权限，即-wx</li><li>4：仅有r权限，即r–</li><li>5：有r和x权限，即r-x</li><li>6：有r和w权限，即rw-</li><li>7：有全部权限，即rwx</li></ul></blockquote><p>所以751表示，rwx(7)r-x(5)–x(1)，<strong>一般记得777就行</strong></p><h3 id="3-5-chmod修改权限信息"><a href="#3-5-chmod修改权限信息" class="headerlink" title="3.5 chmod修改权限信息"></a>3.5 chmod修改权限信息</h3><p>注意⚠️：只有文件、文件夹的所属用户或者root用户可以修改</p><p>语法：<code>chmod [-R] 权限 文件或者文件夹</code></p><ul><li>-R：对文件夹内全部内容应用同样的操作</li></ul><blockquote><p>案例：</p><p>chmod u&#x3D;rwx, g&#x3D;rx, o&#x3D;x hello.txt 将文件权限修改为：rwxr-x–x</p><p>其中：u代表user所属权限，g代表group组所属权限，o代表other其他用户权限</p></blockquote><h3 id="3-6-chown修改文件文件夹所属用户和用户组"><a href="#3-6-chown修改文件文件夹所属用户和用户组" class="headerlink" title="3.6 chown修改文件文件夹所属用户和用户组"></a>3.6 chown修改文件文件夹所属用户和用户组</h3><p>注意⚠️：此命令只适合root用户执行</p><p>语法：<code>chown [-R] [用户名][:][用户组名] 文件或文件夹</code></p><ul><li>-R：可选，表示对文件夹内全部内容应用相同规则</li><li>用户：可选，修改所属用户</li><li>用户组：可选，修改所属用户组</li><li>：可选，用于分割用户用户组</li></ul><blockquote><p>案例：</p><p>chown root hello.txt</p><p>chown :root hello.txt</p><p>chown root:user_group hello.txt</p><p>chown -R root hello</p></blockquote><h3 id="4-systemctl命令"><a href="#4-systemctl命令" class="headerlink" title="4. systemctl命令"></a>4. systemctl命令</h3><p>linux系统很多软件均支持使用systemctl命令控制软件启动、停止、开机自启。</p><p>能被systemctl管理的软件，一般我们称之为服务。</p><p>语法：<code>systemctl start|stop|status|enable|disable 服务名</code></p><ul><li>start：启动</li><li>stop：关闭</li><li>status：查看状态</li><li>enable：启用开机自启</li><li>disable：关闭开机自启</li></ul><h3 id="5-软连接"><a href="#5-软连接" class="headerlink" title="5. 软连接"></a>5. 软连接</h3><p>在系统中创建软链接，可以将文件或者文件夹链接到其他地方，只是一个指向并不是物理上的移动，可以看作windows的快捷方式。</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>-s：创建软链接</li><li>参数1：被链接的文件或者文件夹</li><li>参数2：要链接去的目的地</li></ul><blockquote><p>案例：</p><p>ln -s &#x2F;etc&#x2F;yum.conf  ~&#x2F;yum.confg</p></blockquote><h3 id="6-时间"><a href="#6-时间" class="headerlink" title="6. 时间"></a>6. 时间</h3><p>linux中时间同步问题，一般使用ntp服务来做时间同步。</p><ol><li>yum install ntp 这里是centos的方式，其他Linux发行版自己google一下</li><li>systemctl start ntpd 启动服务</li><li>systemctl enable ntpd</li></ol><h3 id="7-ps进程管理"><a href="#7-ps进程管理" class="headerlink" title="7. ps进程管理"></a>7. ps进程管理</h3><p>语法：<code>ps [-e -f]</code></p><ul><li>-e：显示全部进程</li><li>-f：格式化信息</li></ul><p>一般来说，固定用法就是ps -ef列出全部进程全部信息,还可以加上grep过滤名称或者端口<code>ps -ef | grep &quot;java&quot;</code></p><p>杀掉进程，一般使用<code>kill -9 进程id号</code></p><h3 id="8-top监控主机状态"><a href="#8-top监控主机状态" class="headerlink" title="8. top监控主机状态"></a>8. top监控主机状态</h3><p>语法：<code>top</code></p><p>默认每5秒刷新一次，按ctl+c退出</p><h3 id="9-环境变量"><a href="#9-环境变量" class="headerlink" title="9. 环境变量"></a>9. 环境变量</h3><p>直接执行<strong>env</strong>命令，即可查看环境变量</p><p>PATH环境变量，PATH中记录了系统执行任何命令的搜索路径，路径之间用**:**隔开，使用env |grep “PATH”可以得到环境变量。</p><p>linux系统中**$**符号可以用来取变量的值，所以，<code>echo $PATH</code>也可以找到环境变量</p><h4 id="设置环境变量（这个非常重要）"><a href="#设置环境变量（这个非常重要）" class="headerlink" title="设置环境变量（这个非常重要）"></a>设置环境变量（这个非常重要）</h4><ul><li>临时设置：<code>export 变量名=变量值</code></li><li>永久生效：<ul><li>针对当前用户生效，配置<code>export 变量名=变量值</code>在当前用户的：<code>~/.bashrc</code>文件中，并执行<code>source ~/.bashrc </code></li><li>针对所有用户生效，配置<code>export 变量名=变量值</code>在系统的：<code>/etc/profile</code>文件中，并执行<code>source /etc/profile</code> &#96;</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;作为一名工程师，linux服务器是无法绕过的一道门槛。这里简单的介绍并使用吧linux，希望能给刚入行的新人一些帮助，在就是作为自己的笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://github/zhuchong6.github.io/categories/linux/"/>
    
    
    <category term="devops" scheme="https://github/zhuchong6.github.io/tags/devops/"/>
    
    <category term="linux" scheme="https://github/zhuchong6.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习之初探二</title>
    <link href="https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty%E5%AD%A6%E4%B9%A004/"/>
    <id>https://github/zhuchong6.github.io/2023/01/24/2023-01-22netty%E5%AD%A6%E4%B9%A004/</id>
    <published>2023-01-24T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面我们学了Netty的组件及其设计，这次我们深入一下它的各个环节。</p><span id="more"></span><p>本文代码可以通过这里查看<a href="https://github.com/zhuchong6/netty-learn">地址</a></p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>channel翻译为传输，我们所说的传输就是数据在网络的流动，一般是以字节形式流动的。但是，用户其实不关心这些细节的，他们只关心他们的字节被可靠的发送和接收。</p><p>在上述代码地址中，有Java API版本的传输的例子，包含NIO和BIO。然后在Netty版本中，我们发现NIO和BIO（Netty叫OIO）的版本如此简洁一致，只需要<strong>EventLoopGroup</strong>和channel传入的方法即可轻松切换；而Java版本的却十分复杂。这就是Netty的优点之一，api一致性。</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p>传输API的核心是Channel接口，它处理所有的IO操作，下面是它的接口层次结构：</p><p><img src="/images/netty4.png" alt="channel接口层次图"></p><p>我们可以看到，每个Channel都会生成一个ChannelPipeline和ChannelConfig。ChannelPipeline持有所有将应用于入站和出站数据以及事件的ChannelHandler实 例，这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑；ChannelConfig包含了该Channel的所有配置设置，并且支持热更新。</p><blockquote><p>ChannelPipeline实现了拦截过滤模式，有点类似Java中拦截器和过滤器的作用，持有的ChannelHandler有以下几个作用：</p><ul><li>将数据从一种格式转换成另一种格式</li><li>提供异常通知</li><li>提供Channel变为active或者非active通知</li><li>提供当 Channel 注册到 EventLoop 或者从 EventLoop 注销时的通知</li><li>提供有关用户自定义事件的通知</li></ul></blockquote><h2 id="内置的Channel"><a href="#内置的Channel" class="headerlink" title="内置的Channel"></a>内置的Channel</h2><p>Netty内置了一些可以开箱即用的Channel，参见下表：</p><p></p><table><thead><tr><th>名称</th><th>包</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>使用java.nio.channels包作为基础——基于 选择器的方式</td></tr><tr><td>Epoll</td><td>io.netty.channel.epoll</td><td>由 JNI 驱动的 epoll()和非阻塞 IO。这个传输支持 只有在 Linux 上可用的多种特性，如 SO_REUSEPORT， 比 NIO 传输更快，而且是完全非阻塞的</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>使用java.net包作为基础——使用阻塞流</td></tr><tr><td>Local</td><td>io.netty.channel.local</td><td>可以在 VM 内部通过管道进行通信的本地传输</td></tr><tr><td>Embedded</td><td>io.netty.channel.embedded</td><td>Embedded 传输，允许使用 ChannelHandler 而又 不需要一个真正的基于网络的传输。这在测试你的 ChannelHandler 实现时非常有用</td></tr></tbody></table><h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><p>之前提到网络数据的基本单位总是字节，Java NIO提供了ByteBuffer作为它的字节容器，但是使用起来极其复杂，难用。因此，Netty实现了自己的数据容器-ByteBuf,一个强大的实现，既解决了 JDK API 的局限性， 又为网络应用程序的开发者提供了更好的 API。</p><h2 id="API介绍-1"><a href="#API介绍-1" class="headerlink" title="API介绍"></a>API介绍</h2><p>Netty数据处理的API主要依赖抽象类ByteBuf和ByteBufHolder接口,它具有以下优点：</p><ul><li>它可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝</li><li>容量可以按需增长(类似于 JDK 的 StringBuilder)</li><li>在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法</li><li>读和写使用了不同的索引</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持池化</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>ByteBuf是一个由不同的索引分别控制读访问和写访问的字节数组。它维护了两个不同的索引，一个用于读，一个用于写。当你从ByteBuf读的时候，它的readerIndex将会递增已被读取的字节数；当你向ByteBuf写入的时候，它的writeIndex也会递增；当readerIndex达到writeIndex的时候，就会达到可读数据的末尾，试图读取超出该点的数据会出发数组越界，抛出异常IndexOutOfBoundsExcetption，下图是ByteBuf的简单结构：</p><p><img src="/images/netty5.png" alt="ByteBuf基础结构"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="堆缓冲区"><a href="#堆缓冲区" class="headerlink" title="堆缓冲区"></a>堆缓冲区</h3><p>最常用的方式是将将数据存储在JVM堆区中，这种模式叫做支撑数组，它能在没有池化的情况下提供快速分配和释放，适合有遗留的数据需要处理的情况，可见代码：</p><pre><code class="java">ByteBuf buf = ...//检查ByteBuf是否有一个支撑数组if(buf.hasArray())&#123;  //如果有获取数组的引用  byte[] array = buf.array();  int firstIndex = buf.arrayOffset() + buf.readerIndex(); //计算第一个字节的偏移  int length = buf.readableBytes();//获取可读字节数  handleArray(array, firstIndex, length);//使用数组&#125;</code></pre><h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p>将数据存储在JVM堆外。这样做的好处在于，如果是在对上分配的数据，那么在发送到Socket之前，JVM会把你的数据复制到堆外的缓存区中，在把这个缓存区发送到Socket里。</p><p>缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵；如果你在处理历史代码的时候，因为数据不是在JVM堆上，你需要进行额外的处理(处理代码如下)。如果说你知道ByteBuf容器中的数据是作为数组来访问的，建议使用</p><pre><code class="java">ByteBuf buf = ...;//检查ByteBuf是否有一个支撑数组if(!buf.hasArray())&#123;  //没有支撑数组，证明是一个直接缓冲区  int length = buf.readableBytes();//获取可读字节数  byte[] array = new byte[length];//分配一个新数组来保存堆外数据  buf.getBytes(buf.readerIndex(), array);//将堆外数据复制到堆内  handleArray(array, 0, length);//使用数组&#125;</code></pre><h3 id="复合缓冲区"><a href="#复合缓冲区" class="headerlink" title="复合缓冲区"></a>复合缓冲区</h3><p>简单来说就是多个ByteBuf聚合在一起，可以根据需要添加或者删除ByteBuf实例，这个功能JDK没有。Netty通过一个ByteBuf子类—-CompositeByteBuf实现这个模式。</p><p>为什么需要这个？</p><p>假设一个消息由头部和主体组成，这两个部分分别由不同程序产生，会在消息被发送的时候组装到一起。问题来了，如果发送多条消息，消息头部一致，只是内容不一样。传统方案处理方式是每发送一条消息就创建一个新的头部和主体的缓冲区，这样就导致了内存的占用。</p><p>使用CompositeByteBuf的话就只需要为主体创建缓冲区，头部复用之前的缓冲区即可，消除了没有必要的复制，并且提供了和ByteBuf一致的API。</p><p>下面代码显示两个处理方式之间的区别：</p><h4 id="使用ByteBuffer"><a href="#使用ByteBuffer" class="headerlink" title="使用ByteBuffer"></a>使用<strong>ByteBuffer</strong></h4><pre><code class="java">// Use an array to hold the message partsByteBuffer[] message = new ByteBuffer[] &#123; header, body &#125;;// Create a new ByteBuffer and use copy to merge the header and body ByteBuffer message2 =ByteBuffer.allocate(header.remaining() + body.remaining()); message2.put(header);message2.put(body);message2.flip();</code></pre><h4 id="使用CompositeByteBuf"><a href="#使用CompositeByteBuf" class="headerlink" title="使用CompositeByteBuf"></a>使用<strong>CompositeByteBuf</strong></h4><pre><code class="java">CompositeByteBuf messageBuf = Unpooled.compositeBuffer(); ByteBuf headerBuf = ...; // can be backing or direct ByteBuf bodyBuf = ...; // can be backing or direct messageBuf.addComponents(headerBuf, bodyBuf);  .....messageBuf.removeComponent(0); // remove the header for (ByteBuf buf : messageBuf) &#123;    System.out.println(buf.toString());&#125;//访问 CompositeByteBuf 中的数据int length = messageBuf.readableBytes();//获得可读字节数byte[] array = new byte[length];//根据length分配数组messageBuf.getBytes(compBuf.readerIndex(), array);//将字节读到该数组中去handleArray(array, 0, array.length);//使用数组</code></pre><h2 id="字节级操作"><a href="#字节级操作" class="headerlink" title="字节级操作"></a>字节级操作</h2><p>ByteBuf 提供了许多超出基本读、写操作的方法用于修改它的数据，接下来我们研究一下。</p><h3 id="随机访问索引"><a href="#随机访问索引" class="headerlink" title="随机访问索引"></a>随机访问索引</h3><p>ByteBuf索引是从0开始的，最后一个字节的索引总是capacity()-1，所以可以这样遍历：</p><pre><code class="java">ByteBuf buffer = ...;for (int i = 0; i &lt; buffer.capacity(); i++) &#123;byte b = buffer.getByte(i); //注意，这里不回改变读写指针的位置System.out.println((char)b); &#125;</code></pre><h3 id="访问索引顺序"><a href="#访问索引顺序" class="headerlink" title="访问索引顺序"></a>访问索引顺序</h3><p>JDK中的ByteBuffer只有一个索引，这就是为什么它读写的时候需要flip()方法来切换读写模式。对于Nett，ByteBuf有两个索引，更易操作和理解。如图：</p><p><img src="/images/netty6.png" alt="bytebuf内部分段"></p><h3 id="可丢弃字节"><a href="#可丢弃字节" class="headerlink" title="可丢弃字节"></a>可丢弃字节</h3><p>在上图标记的可丢弃字节中，表示已经被读取过的字节。通过调用discardReadBytes()方法，丢弃并回收空间，此时可读部分（content标记）必须移动到缓存区前面，如图：</p><p><img src="/images/netty7.png" alt="可丢弃部分合并"></p><p>所以，建议只有在<strong>真正需要的时候（内存很宝贵的时候）</strong>这样做，因为会导致内存复制影响性能。</p><h3 id="可读字节"><a href="#可读字节" class="headerlink" title="可读字节"></a>可读字节</h3><p>ByteBuf可读字节分段存储了实际数据，默认readerIndex是0，read或者skip开头的方法会检索或者跳过当前readerIndex数据，并且将它增加已读字节数。</p><p>如果read开头的方法（<code>readBytes(ByteBuf byteBuf)</code>）需要一个ByteBuf作为参数，那么此时writeIndex也会增加。</p><p>下面代码展示如何读取所有数据：</p><pre><code class="java">ByteBuf buf = Unpooled.buffer();while (buf.isReadable())&#123;        ...&#125;</code></pre><h3 id="可写字节"><a href="#可写字节" class="headerlink" title="可写字节"></a>可写字节</h3><p>可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域，默认的writeIndex是0，write开头的方法会从当前的writeIndex开始写数据，并将它增加已写入的字节数。</p><p>如果write开头的方法（<code>writeBytes(ByteBuf dest)</code>）需要传递一个ByteBuf参数，那么此时readIndex也会增加同样大小。</p><p>下面代码展示用随机整数值填充缓冲区，直到它空间不足为止：</p><pre><code class="java">ByteBuf buf = Unpooled.buffer();//方法返回可写字节数，等效于this.capacity - this.writerIndexwhile (buf.writableBytes()&gt;4)&#123;  buf.writeInt(new Random().nextInt());&#125;</code></pre><h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>JDK中InputStream定义了mark(int readlimit)和reset()方法用于将流中的当前位置标记为指定的值，以及将流重置到该位置。</p><p>同样的，ByteBuf可以通过调用 markReaderIndex()、markWriterIndex()、resetWriterIndex() 和 resetReaderIndex()来标记和重置 ByteBuf 的 readerIndex 和 writerIndex。</p><p>也可以通过调用 readerIndex(int)或者 writerIndex(int)来将索引移动到指定位置。试图将任何一个索引设置到一个无效的位置都将导致一个 IndexOutOfBoundsException。</p><p>可以通过调用 clear()方法来将 readerIndex 和 writerIndex 都设置为 0。<strong>注意，这并不会清除内存中的内容</strong></p><p>因此，比discardReadBytes()轻量很多，没有内存复制。</p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>最简单的就是indexOf方法查找，稍微复杂的可以使用<strong>ByteProcessor</strong>。举个例子：</p><pre><code class="java">ByteBuf buf = Unpooled.buffer();int index = buf.forEachByte(ByteProcessor.FIND_LF);</code></pre><h3 id="派生缓冲区"><a href="#派生缓冲区" class="headerlink" title="派生缓冲区"></a>派生缓冲区</h3><p>以下几个方法可以创建派生缓冲区：</p><ul><li>duplicate()</li><li>slice()</li><li>slice(int, int)</li><li>Unpooled.unmodifiableBuffer(…)</li><li>order(ByteOrder);</li><li>readSlice(int)</li></ul><p>每个这些方法都将返回一个新的 ByteBuf 实例，它具有自己的读索引、写索引和标记索引。</p><p>其内部存储和 JDK 的 ByteBuffer 一样也是共享的。</p><p>这使得派生缓冲区的创建成本是很低廉的，但是这也意味着，如果你修改了它的内容，也同时修改了其对应的源实例，所以要小心。</p><blockquote><p><strong>ByteBuf</strong> 复制 </p><p>如果需要一个现有缓冲区的真实副本，请使用 copy()或者 copy(int, int)方法。不同于派生缓冲区，由这个调用所返回的 ByteBuf 拥有独立的数据副本。</p></blockquote><p>我们来看看派生和复制带案例：</p><pre><code class="java">//派生缓冲区Charset utf8 = Charset.forName(&quot;UTF-8&quot;);//创建一个ByteBufByteBuf buf = Unpooled.copiedBuffer(&quot;Netty in Action rocks!&quot;, utf8);//创建一个切片ByteBuf sliced = buf.slice(0, 15);//打印 Netty in ActionSystem.out.println(sliced.toString(utf8));//更新原来ByteBuf 索引0位置的字节buf.setByte(0, (byte)&#39;J&#39;);//因为数据是共享的，改一个另一个也会改，结果是trueSystem.out.println(buf.getByte(0) == sliced.getByte(0));</code></pre><pre><code class="java">//复制Charset utf8 = Charset.forName(&quot;UTF-8&quot;);ByteBuf buf = Unpooled.copiedBuffer(&quot;Netty in Action rocks!&quot;, utf8);//复制一份ByteBufByteBuf copy = buf.copy(0, 15);//打印 Netty in ActionSystem.out.println(copy.toString(utf8));//更新原来ByteBuf 索引0位置的字节buf.setByte(0, (byte) &#39;J&#39;);//因为数据不是共享的，改一个另一个不拜年，结果是falseSystem.out.println(buf.getByte(0) == copy.getByte(0));</code></pre><h2 id="ByteBufHolder接口"><a href="#ByteBufHolder接口" class="headerlink" title="ByteBufHolder接口"></a>ByteBufHolder接口</h2><p>除了实际数据之外，我们还需要存储各种属性值，HTTP响应便是一个很好的例子，除了表示为字节的内容，还包括状态码、cookie 等。</p><p>为了处理这种常见的用例，Netty 提供了 ByteBufHolder</p><p>ByteBufHolder 只有几种用于访问底层数据和引用计数的方法，见下表：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>content()</td><td>返回由这个 ByteBufHolder 所持有的 ByteBuf</td></tr><tr><td>copy()</td><td>返回这个 ByteBufHolder 的一个深拷贝，包括一个其所包含的 ByteBuf 的非共享拷贝</td></tr><tr><td>duplicate()</td><td>返回这个ByteBufHolder的一个浅拷贝，包括一个其所包含的ByteBuf的共享拷贝</td></tr></tbody></table><h2 id="ByteBuf分配"><a href="#ByteBuf分配" class="headerlink" title="ByteBuf分配"></a>ByteBuf分配</h2><ol><li><p>按需分配：ByteBufAllocator</p><p>为了节省内存分配和释放的压力，Netty通过ByteBufAllocator实现了ByteBuf的池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。下面列出一些api：</p><table><thead><tr><th>名称</th><th align="left">描述</th></tr></thead><tbody><tr><td>buffer() <br />buffer(int initialCapacity);<br />buffer(int initialCapacity, int maxCapacity);</td><td align="left">返回一个基于堆或者直接内存 存储的 ByteBuf</td></tr><tr><td>heapBuffer() <br />heapBuffer(int initialCapacity) <br />heapBuffer(int initialCapacity, int maxCapacity)</td><td align="left">返回一个基于堆内存存储的ByteBuf</td></tr><tr><td>directBuffer() <br />directBuffer(int initialCapacity) <br />directBuffer(int initialCapacity, int maxCapacity)</td><td align="left">返回一个基于直接内存存储的ByteBuf</td></tr><tr><td>compositeBuffer() <br />compositeBuffer(int maxNumComponents) <br />compositeDirectBuffer() <br />compositeDirectBuffer(int maxNumComponents)<br />compositeHeapBuffer() <br />compositeHeapBuffer(int maxNumComponents)</td><td align="left">返回一个可以通过添加最大到指定数目的基于堆的或者直接内存存储的缓冲区来扩展的 CompositeByteBuf</td></tr><tr><td>ioBuffer()</td><td align="left">返回一个用于套接字的 I&#x2F;O 操 作的 ByteBuf</td></tr></tbody></table><p>Netty提供了两种ByteBufAllocator的实现:<strong>PooledByteBufAllocator</strong>和<strong>UnpooledByteBufAllocator</strong>，前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。</p></li><li><p>Unpooled 缓冲区</p><p>可能某些情况下，你未能获取一个到 ByteBufAllocator 的引用。对于这种情况，Netty 提 供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf 实例。下面是一些api：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer() <br />buffer(int initialCapacity) <br />buffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于堆内存存储的</td></tr><tr><td>directBuffer()<br/>directBuffer(int initialCapacity) <br />directBuffer(int initialCapacity, int maxCapacity)</td><td>返回一个未池化的基于直接内存存储 的 ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的 ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的 ByteBuf</td></tr></tbody></table><p>Unpooled 类还使得 ByteBuf 同样可用于那些并不需要 Netty 的其他组件的非网络项目， 使得其能得益于高性能的可扩展的缓冲区 API。</p></li><li><p>ByteBufUtil 类</p><p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。因为这个 API 是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。</p><p>这些静态方法中最有价值的可能就是 hexdump()方法，它以十六进制的表示形式打印 ByteBuf 的内容。这在各种情况下都很有用，例如，出于调试的目的记录 ByteBuf 的内容。十六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。</p><p>另一个有用的方法是 boolean equals(ByteBuf, ByteBuf)，它被用来判断两个 ByteBuf 实例的相等性。如果你实现自己的 ByteBuf 子类，你可能会发现 ByteBufUtil 的其他有用方法。</p></li></ol><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</p><p>引用计数背后的想法并不是特别的复杂;它主要涉及跟踪到某个特定对象的活动引用的数量。一个 ReferenceCounted 实现的实例将通常以活动的引用计数为 1 作为开始。只要引用 数大于 0，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。注意， 虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。</p><p>引用释放的代码示例：</p><pre><code class="java">ByteBufAllocator alloc = ByteBufAllocator.DEFAULT;ByteBuf buf = alloc.directBuffer();System.out.println(&quot;buf.refCnt() = &quot; + buf.refCnt());//1//releasebuf.release();System.out.println(&quot;buf.refCnt() = &quot; + buf.refCnt());//0</code></pre><blockquote><p>谁负责释放</p><p>一般来说，是由最后访问(引用计数)对象的那一方来负责将它释放。</p></blockquote><h1 id="ChannelHandler和ChannelPipeline"><a href="#ChannelHandler和ChannelPipeline" class="headerlink" title="ChannelHandler和ChannelPipeline"></a>ChannelHandler和ChannelPipeline</h1><p>ChannelPipeline中将ChannelHandler连接组织在一起以处理逻辑，以及ChannelHandlerContext的作用。</p><h2 id="ChannelHander家族"><a href="#ChannelHander家族" class="headerlink" title="ChannelHander家族"></a>ChannelHander家族</h2><h3 id="Channel的生命周期"><a href="#Channel的生命周期" class="headerlink" title="Channel的生命周期"></a>Channel的生命周期</h3><p>Channel定义了一组和ChannelInboundHandler API密切相关的简单但是功能强大的状态模型，以下是Channel的这4个状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel 已经被创建，但还未注册到 EventLoop</td></tr><tr><td>ChannelRegistered</td><td>Channel 已经被注册到了 EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel 处于活动状态(已经连接到它的远程节点)。它现在可以接收和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table><p>Channel的正常生命周期如下图所示，当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应。</p><p><img src="/images/netty8.png" alt="channel状态流转"></p><h3 id="ChannelHandler的生命周期"><a href="#ChannelHandler的生命周期" class="headerlink" title="ChannelHandler的生命周期"></a>ChannelHandler的生命周期</h3><p>下表列出了ChannelHandler定义的生命周期操作，在ChannelHandler被添加到ChannelPipeline中或者被从ChannelPipeline中移除会调用这些操作，这些方法都接收一个ChannelHandlerContext参数。</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把 ChannelHandler 添加到 ChannelPipeline 中时被调用</td></tr><tr><td>handlerRemoved</td><td>当从 ChannelPipeline 中移除 ChannelHandler 时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在 ChannelPipeline 中有错误产生时被调用</td></tr></tbody></table><p>Netty定义了下面两个最重要的ChannelHandler接口：</p><ul><li>ChannelInboundHandler—处理入站数据以及各种状态变化</li><li>ChannelOutboundHandler—处理出站数据并且允许拦截所有的操作</li></ul><h3 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h3><p>下表列出ChannelInboundHandler的生命周期方法，这些方法会在数据被接收或者与其对应的Channel状态发生改变时被调用。</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>channelRegistered</td><td>当 Channel 已经注册到它的 EventLoop 并且能够处理 I&#x2F;O 时被调用</td></tr><tr><td>channelUnregistered</td><td>当 Channel 从它的 EventLoop 注销并且无法处理任何 I&#x2F;O 时被调用</td></tr><tr><td>channelActive</td><td>当 Channel 处于活动状态时被调用;Channel 已经连接&#x2F;绑定并且已经就绪</td></tr><tr><td>channelInactive</td><td>当 Channel 离开活动状态并且不再连接它的远程节点时被调用</td></tr><tr><td>channelReadComplete</td><td>当Channel上的一个读操作完成时被调用</td></tr><tr><td>channelRead</td><td>当从 Channel 读取数据时被调用</td></tr><tr><td>ChannelWritabilityChanged</td><td>当Channel的可写状态发生改变时被调用</td></tr><tr><td>userEventTriggered</td><td>当 ChannelnboundHandler.fireUserEventTriggered()方法被调 用时被调用，因为一个 POJO 被传进了 ChannelPipeline</td></tr></tbody></table><p>当某个ChannelInboundHandler的实现重写了channelRead()方法时，它将负责显式地释放与池化ByteBuf实例相关的内存，为此Netty提供了一个实用方法ReferenceCountUtil.release(),代码如下：</p><pre><code class="java">@Sharablepublic class DiscardHandler extends ChannelInboundHandlerAdapter &#123;  @Override  public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;    ReferenceCountUtil.release(msg);   &#125;&#125;</code></pre><p>但是以这种方式管理资源可能很繁琐，一个更加简单的方式是使用SimpleChannelInboundHandler，具体代码如下：</p><pre><code class="java">@Sharablepublic class SimpleDiscardHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123;   @Override  public void channelRead0(ChannelHandlerContext ctx,Object msg) &#123;          // No need to do anything special  &#125; &#125;</code></pre><p>由于 SimpleChannelInboundHandler 会自动释放资源，所以你不应该存储指向任何消息的引用供将来使用，因为这些引用都将会失效。</p><h3 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h3><p>ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求，下面显示 ChannelOutboundHandler 本身所定义的方法：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>bind(ChannelHandlerContext,<br />SocketAddress,ChannelPromise)</td><td>当请求将 Channel 绑定到本地地址时被调用</td></tr><tr><td>connect(ChannelHandlerContext, SocketAddress,SocketAddress,ChannelPromise)</td><td>当请求将 Channel 连接到远程节点时被调用</td></tr><tr><td>disconnect(ChannelHandlerContext, ChannelPromise)</td><td>当请求将 Channel 从远程节点断开时被调用</td></tr><tr><td>close(ChannelHandlerContext,ChannelPromise)</td><td>当请求关闭 Channel 时被调用</td></tr><tr><td>deregister(ChannelHandlerContext, ChannelPromise)</td><td>当请求将 Channel 从它的 EventLoop 注销 时被调用</td></tr><tr><td>read(ChannelHandlerContext)</td><td>当请求从 Channel 读取更多的数据时被调用</td></tr><tr><td>flush(ChannelHandlerContext)</td><td>当请求通过 Channel 将入队数据冲刷到远程</td></tr><tr><td>write(ChannelHandlerContext,Object, ChannelPromise)</td><td>当请求通过 Channel 将数据写到远程节点时 被调用</td></tr></tbody></table><blockquote><p><strong>ChannelPromise</strong>与<strong>ChannelFuture</strong> </p><p>ChannelOutboundHandler中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。</p><p>ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess()和setFailure()，从而使ChannelFuture不可变 。</p></blockquote><h3 id="ChannelHandler-适配器"><a href="#ChannelHandler-适配器" class="headerlink" title="ChannelHandler 适配器"></a>ChannelHandler 适配器</h3><p>你可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 类作为自己的 ChannelHandler 的起始点。</p><p>这两个适配器分别提供了 ChannelInboundHandler 和 ChannelOutboundHandler 的基本实现。通过扩展抽象类 ChannelHandlerAdapter，它们 获得了它们共同的超接口 ChannelHandler 的方法。</p><p>具体类图如下：</p><p><img src="/images/netty9.png" alt="适配器结构图"></p><h2 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h2><p>每一个新创建的 Channel 都将会被分配一个新的 ChannelPipeline。这项关联是永久性 的;Channel 既不能附加另外一个 ChannelPipeline，也不能分离其当前的。在 Netty 组件 的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。</p><p>根据事件的起源，事件将会被 ChannelInboundHandler 或者 ChannelOutboundHandler处理。随后，通过调用 ChannelHandlerContext 实现，它将被转发给同一超类型的下一个ChannelHandler。</p><blockquote><p>ChannelHandlerContext</p><p>ChannelHandlerContext使得ChannelHandler能够和它的ChannelPipeline以及其他的 ChannelHandler 交 互 。 ChannelHandler 可 以 通 知 其 所 属 的 ChannelPipeline 中 的 下 一 个 ChannelHandler，甚至可以动态修改它所属的ChannelPipeline1。</p><p>ChannelHandlerContext 具有丰富的用于处理事件和执行 I&#x2F;O 操作的 API。6.3 节将提供有关 ChannelHandlerContext 的更多内容。</p></blockquote><p>下图是传播流程：</p><p><img src="/images/netty10.png" alt="适配器结构图"></p><p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该 ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p><h3 id="修改ChannelPipeline"><a href="#修改ChannelPipeline" class="headerlink" title="修改ChannelPipeline"></a>修改ChannelPipeline</h3><p>ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改 ChannelPipeline 的布局。(它也可以将它自己从 ChannelPipeline 中移除。)这是 Channel- Handler 最重要的能力之一，所以我们将仔细地来看看它是如何做到的。下表列出了相关方法：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>addFirstaddBefore<br />addAfteraddLast</td><td>将一个ChannelHandler添加到ChannelPipeline中</td></tr><tr><td>remove</td><td>将一个 ChannelHandler 从 ChannelPipeline 中移除</td></tr><tr><td>replace</td><td>将 ChannelPipeline 中的一个 ChannelHandler 替换为另一个 ChannelHandler</td></tr></tbody></table><blockquote><p><strong>ChannelHandler 的执行和阻塞</strong></p><p>通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop(I&#x2F;O 线程)来处</p><p>理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I&#x2F;O 处理产生负面的影响。</p><p>但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。</p><p>对于这种情况，ChannelPipeline 有一些 接受一个 EventExecutorGroup 的 add()方法。</p><p>如果一个事件被传递给一个自定义的 EventExecutorGroup，它将被包含在这个 EventExecutorGroup 中的某个 EventExecutor 所处理，从而被从该 Channel 本身的 EventLoop 中移除。</p><p>对于这种用例，Netty 提供了一个叫 DefaultEventExecutor- Group 的默认实现。</p></blockquote><h2 id="ChannelHandlerContext接口"><a href="#ChannelHandlerContext接口" class="headerlink" title="ChannelHandlerContext接口"></a>ChannelHandlerContext接口</h2><p>ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关系，每当有ChannelHandler添加到ChannelPipeline中，都会创建ChannelHandlerContext，主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。</p><p>通过观察api发现，ChannelHandlerContext很多方法，Channel和ChannelPipeline都有，区别就是： <strong>Channel 或者 ChannelPipeline 上的这 些方法，它们将沿着整个 ChannelPipeline 进行传播；ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该 ChannelPipeline 中的下一个能够处理该事件的 ChannelHandler</strong></p><blockquote><p>注意：</p><ul><li>ChannelHandlerContext 和 ChannelHandler 之间的关联(绑定)是永远不会改变的，所以缓存对它的引用是安全的</li><li>相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能</li></ul></blockquote><h3 id="使用ChannelHandlerContext"><a href="#使用ChannelHandlerContext" class="headerlink" title="使用ChannelHandlerContext"></a>使用ChannelHandlerContext</h3><p>先观察图片,可以看出ChannelHandlerContext、ChannelHandler、Channel和ChannelPipeline之间的关系：</p><p><img src="/images/netty11.png" alt="关系图"></p><p>我们看下面一段代码：</p><pre><code class="java">//利用Channel写入缓冲区ChannelHandlerContext ctx = ..;Channel channel = ctx.channel();//ctx获取关联的Channel//channel写入缓冲区channel.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));//利用ChannelPipeline写入缓冲区ChannelHandlerContext ctx = ..;ChannelPipeline pipeline = ctx.pipeline();//ctx获取关联的ChannelPipeline//pipeline写入缓冲区pipeline.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));</code></pre><p>代码的调用流程图如下所示：</p><p><img src="/images/netty12.png" alt="关系图"></p><blockquote><p>为什么会想要从 ChannelPipeline 中的某个特定点开始传播事件呢?</p><ul><li><p>为了减少将事件传经对它不感兴趣的 ChannelHandler 所带来的开销</p></li><li><p>为了避免将事件传经，那些可能会对它感兴趣的 ChannelHandler</p></li></ul></blockquote><p>如果想要从特定的某个ChannelHandler开始处理问题，必须获取这个handler之前的ChannelHandler，并获取其关联的ChannelHandlerContext，这个ChannelHandlerContext将调用和它所关联的ChannelHandler之后的 ChannelHandler，具体代码和调用流程如下图：</p><pre><code class="java">ChannelHandlerContext ctx = ..;ctx.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));</code></pre><p><img src="/images/netty13.png" alt="关系图"></p><h3 id="ChannelHandler和ChannelHandlerContext的高级用法"><a href="#ChannelHandler和ChannelHandlerContext的高级用法" class="headerlink" title="ChannelHandler和ChannelHandlerContext的高级用法"></a>ChannelHandler和ChannelHandlerContext的高级用法</h3><ol><li><p>可以通过ctx的pipeline方法获取ChannelPipeline的引用，可以在运行时操作ChannelHandler，比如可以实现动态的协议切换</p></li><li><p>将ChannelHandlerContext的引用缓存起来，可以在ChannelHandler方法之外，甚至不同线程使用，具体代码可以看下面：</p><pre><code class="java">public class WriteHandler extends ChannelHandlerAdapter &#123;    private ChannelHandlerContext ctx;  @Override  public void handlerAdded(ChannelHandlerContext ctx) &#123;    this.ctx = ctx;//存储到 ChannelHandlerContext 的引用以供稍后使用  &#125;  public void send(String msg) &#123;      ctx.writeAndFlush(msg);// 使用之前存储的到 ChannelHandlerContext 的引用来发送消息    &#125;&#125;</code></pre><p>由于ChannelHandler可以属于多个ChannelPipeline，所以它会绑定多个ChannelHandlerContext。因此，对于那些希望在多个ChannelPipeline中共享同一个个ChannelHandler的用法，需要使用**@Sharable**注解，具体如下：</p><pre><code class="java">@Sharablepublic class SharableHandler extends ChannelInboundHandlerAdapter &#123;  //这里不要加状态，否则会线程不安全  @Override  public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;    System.out.println(&quot;Channel read message: &quot; + msg);    ctx.fireChannelRead(msg);  &#125;&#125;</code></pre><blockquote><p>为啥要共享一个<strong>ChannelHandler</strong>？</p><p>在多个ChannelPipeline中安装同一个ChannelHandler的一个常见的原因是用于收集跨越多个 Channel 的统计信息。</p></blockquote></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常处理是程序的重要组成部分，Netty提供了几种方式用于处理入站或者出站过程中发生的异常。</p><h3 id="入站异常处理"><a href="#入站异常处理" class="headerlink" title="入站异常处理"></a>入站异常处理</h3><p>入站的异常遵循以下事实：</p><ol><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline中的下一个 ChannelHandler。</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理。</li><li>要想定义自定义的处理逻辑，你需要重写 exceptionCaught()方法。然后你需要决定是否需要将该异常传播出去。</li></ol><p>具体处理代码如下：</p><pre><code class="java">public class InboundExceptionHandler extends ChannelInboundHandlerAdapter &#123;   @Override  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;    cause.printStackTrace();    ctx.close();  &#125; &#125;</code></pre><h3 id="出站异常处理"><a href="#出站异常处理" class="headerlink" title="出站异常处理"></a>出站异常处理</h3><p>用于处理出站操作中的正常完成以及异常的选项，都基于以下的通知机制：</p><ol><li>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了</li><li>几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。</li></ol><p>代码如下：</p><pre><code class="java">ChannelFuture future = channel.write(someMessage);   future.addListener(new ChannelFutureListener() &#123;    @Override    public void operationComplete(ChannelFuture f) &#123;        if (!f.isSuccess()) &#123;         f.cause().printStackTrace();        f.channel().close();      &#125;&#125;); </code></pre><pre><code class="java">public class OutboundExceptionHandler extends ChannelOutboundHandlerAdapter &#123; @Override  public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;    promise.addListener(new ChannelFutureListener() &#123;      @Override      public void operationComplete(ChannelFuture f) &#123;        if (!f.isSuccess()) &#123;           f.cause().printStackTrace();          f.channel().close();        &#125;      &#125;);     &#125;   &#125;&#125;</code></pre><h1 id="EventLoop和线程模型"><a href="#EventLoop和线程模型" class="headerlink" title="EventLoop和线程模型"></a>EventLoop和线程模型</h1><p>本节我们探讨下Netty的线程模型，简化应用程序代码，同时最大限度提高性能。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能，与之相应的编程上的构造通常被称为<strong>事件循环</strong>（Netty 使用了 interface io.netty.channel. EventLoop 来适配的术语）。</p><p>可以看下下面的伪代码，理解EventLoop的思想：</p><pre><code class="java">while (!terminated) &#123;    List&lt;Runnable&gt; readyEvents = blockUntilEventsReady();   for (Runnable ev: readyEvents) &#123;//循环遍历，处理所有的事件        ev.run();   &#125;&#125;</code></pre><p>在这个模型中，一个EventLoop将由一个永远都不会改变的Thread绑定，同时任务 (Runnable 或者 Callable)可以直接提交给EventLoop实现，以立即执行或者调度执行。</p><p>因此，我们可以把EventLoop看作一个包含了Channel的线程。</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>我们需要调度任务延迟执行或者周期性执行，例如：心跳检测就需要周期性执行。</p><p>下面代码展示了EventLoop如何调度任务：</p><ul><li><p>延迟调度</p><pre><code class="java">Channel ch = ...ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule(new Runnable() &#123;    @Override    public void run() &#123;      System.out.println(&quot;60 seconds later&quot;);     &#125;&#125;, 60, TimeUnit.SECONDS);</code></pre></li><li><p>周期性调度</p><pre><code class="java">Channel ch = ...ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(new Runnable() &#123;    @Override    public void run() &#123;      System.out.println(&quot;Run every 60 seconds&quot;);     &#125;&#125;, 60, 60, TimeUnit.Seconds);</code></pre></li><li><p>取消调度</p><pre><code class="java">ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(...); // Some other code that runs...boolean mayInterruptIfRunning = false; future.cancel(mayInterruptIfRunning);</code></pre></li></ul><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><p><img src="/images/netty14.png" alt="netty线程管理"></p><p>就看当前调度线程和EventLoop绑定的线程是不是一样的，如果一致会立马执行；否则，放入EventLoop的<strong>任务队列（每个EventLoop都有自己的任务队列）</strong>等待下一次调度执行。</p><blockquote><p>注意：</p><p>不要把一个长时间的任务放到任务队列中，会阻塞当前线程；如果必须要进行阻塞调用或者执行长时间的任务，那么请将其放到专门的任务线程池中执行。</p></blockquote><h4 id="线程分配"><a href="#线程分配" class="headerlink" title="线程分配"></a>线程分配</h4><p>分为两种情况，NIO和BIO，具体如图：</p><p><img src="/images/netty15.png" alt="NIO线程分配"></p><p><img src="/images/netty16.png" alt="BIO线程分配"></p><h1 id="自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。"><a href="#自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。" class="headerlink" title="自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。"></a>自此，Netty中的几个组件我们基本已经了解完毕。下一次，我们就需要自己实践一下。</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面我们学了Netty的组件及其设计，这次我们深入一下它的各个环节。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Netty" scheme="https://github/zhuchong6.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习之初探</title>
    <link href="https://github/zhuchong6.github.io/2023/01/23/2023-01-22netty%E5%AD%A6%E4%B9%A003/"/>
    <id>https://github/zhuchong6.github.io/2023/01/23/2023-01-22netty%E5%AD%A6%E4%B9%A003/</id>
    <published>2023-01-23T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Netty是一款用于创建<strong>高性能</strong>网络应用程序的高级框架，它的优势在于：</p><ul><li>不必精通网络编程，已经为你预置大量细节</li><li>比直接使用Java本地API要简单的多</li><li>有良好的设计实践，将应用程序逻辑和网络层解耦</li></ul><span id="more"></span><p>本文代码可以通过这里查看<a href="https://github.com/zhuchong6/netty-learn">地址</a></p><h1 id="Netty特性"><a href="#Netty特性" class="headerlink" title="Netty特性"></a>Netty特性</h1><table><thead><tr><th>分类</th><th>Netty特性</th></tr></thead><tbody><tr><td>设计</td><td>统一的 API，支持多种传输类型，阻塞的和非阻塞的 <br />简单而强大的线程模型 <br />真正的无连接数据报套接字支持 <br />链接逻辑组件以支持复用</td></tr><tr><td>易于使用</td><td>详实的Javadoc和大量的示例集<br/>不需要超过JDK 1.6+3的依赖。(一些可选的特性可能需要Java 1.7+和&#x2F;或额外的依赖)</td></tr><tr><td>性能</td><td>拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟<br />得益于池化和复用，拥有更低的资源消耗 <br />最少的内存复制</td></tr><tr><td>健壮性</td><td>不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError <br />消除在高速网络中 NIO 应用程序常见的不公平读&#x2F;写比率</td></tr><tr><td>安全性</td><td>完整的 SSL&#x2F;TLS 以及 StartTLS 支持 <br />可用于受限环境下，如 Applet 和 OSGI</td></tr><tr><td>社区驱动</td><td>发布快速且频繁</td></tr></tbody></table><h2 id="第一个简单的Netty程序"><a href="#第一个简单的Netty程序" class="headerlink" title="第一个简单的Netty程序"></a>第一个简单的Netty程序</h2><p>我们将要创建一个简单netty的程序，包含客户端和服务器端，其功能很简单就是<strong>客户端连接到服务器端，服务器端收到并返回给客户端一个消息</strong>。</p><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a><strong>Server端</strong></h3><pre><code class="java">public class EchoServer &#123;    private final int port;    public EchoServer(int port) &#123;        this.port = port;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        if( args.length != 1)&#123;            //提示设置端口值            System.err.println(&quot;Usage: &quot;+ EchoServer.class.getSimpleName()+&quot; &lt;port&gt;&quot;);        &#125;        int port = Integer.parseInt(args[0]);        new EchoServer(port).start();    &#125;    public void start() throws InterruptedException &#123;        final EchoServerHandler echoServerHandler = new EchoServerHandler();        //创建EventLoopGroup        EventLoopGroup group = new NioEventLoopGroup();        try &#123;            //创建ServerBootstrap            ServerBootstrap serverBootstrap = new ServerBootstrap();            //因为你正在使用的是 NIO 传输，所以你指定了NioEventLoopGroup来接受和处理新的连接            serverBootstrap.group(group)                    //指定所使用的NIO传输channel，这里就是父Channel                    .channel(NioServerSocketChannel.class)                    //使用指定的端口设置套接字地址                    .localAddress(new InetSocketAddress(port))                    //添加一个echoServerHandler到子Channel的ChannelPipeline，                    // 当一个新的连接被接受时，一个新的子Channel将会被创建，用于处理入站消息通知                    // 而ChannelInitializer将会把一个你的EchoServerHandler的实例添加到该Channel的ChannelPipeline中                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            //echoServerHandler 中@Sharable表示我们可以使用同样的实例                            ch.pipeline().addLast(echoServerHandler);                        &#125;                    &#125;);            //异步绑定服务器，调用sync方法阻塞等待直到绑定完成            ChannelFuture channelFuture = serverBootstrap.bind().sync();            //获取Channel的closeFuture，并且阻塞当前线程直到它完成            channelFuture.channel().closeFuture().sync();        &#125;finally &#123;            //关闭EventLoopGroup释放所有资源            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre><pre><code class="java">@ChannelHandler.Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        ByteBuf in = (ByteBuf) msg;        System.out.println(&quot;Server receive :&quot;+ in.toString(CharsetUtil.UTF_8));        ctx.write(in);    &#125;    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)                .addListener(ChannelFutureListener.CLOSE);    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a><strong>Client端</strong></h3><pre><code class="java">public class EchoClient &#123;    private final String host;    private final int port;    public EchoClient(String host, int port) &#123;        this.host = host;        this.port = port;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        if (args.length != 2) &#123;            System.err.println(                    &quot;Usage: &quot; + EchoClient.class.getSimpleName() + &quot; &lt;host&gt; &lt;port&gt;&quot;);            return;        &#125;        String host = args[0];        int port = Integer.parseInt(args[1]);        new EchoClient(host, port).start();    &#125;    public void start() throws InterruptedException &#123;        EventLoopGroup group = new NioEventLoopGroup();        try &#123;            Bootstrap bootstrap = new Bootstrap();            bootstrap.group(group)                    .channel(NioSocketChannel.class)                    .remoteAddress(new InetSocketAddress(host, port))                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            ch.pipeline().addLast(new EchoClientHandler());                        &#125;                    &#125;);            ChannelFuture f = bootstrap.connect().sync();            f.channel().closeFuture().sync();        &#125;finally &#123;            group.shutdownGracefully().sync();        &#125;    &#125;&#125;</code></pre><pre><code class="java">@ChannelHandler.Sharablepublic class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        //当被通知Channel是活跃的时候，发送一条消息        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Netty rocks!&quot;,                CharsetUtil.UTF_8));    &#125;    @Override    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;        //记录已接收消息的转储        System.out.println(                &quot;Client received: &quot; + in.toString(CharsetUtil.UTF_8));    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p>我们可以看出，使用Netty构建的程序远比Java API的要简单多了，而且最终要的是它将网络处理和业务处理进行了分离，使我们更加专注于业务构建，这一点我觉得在大型程序中非常有优势。</p><h1 id="Netty的组件和设计"><a href="#Netty的组件和设计" class="headerlink" title="Netty的组件和设计"></a>Netty的组件和设计</h1><h2 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h2><p>Channel、EventLoop和ChannelFuture这三个接口，被认为是netty网络抽象的代表，其中每个负责的职责如下：</p><ul><li>Channel：Socket</li><li>EventLoop：控制流、多线程处理、并发</li><li>ChannelFuture：异步通知</li></ul><h3 id="Channel接口"><a href="#Channel接口" class="headerlink" title="Channel接口"></a>Channel接口</h3><p>基本的IO操作（bind(),connect(),read()和write()）依赖于底层网络传输所提供的原语。对于Java网络编程，可以类比为Socket类。</p><h3 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h3><p>EventLoop定义了Netty的核心抽象，<strong>用于处理连接的生命周期中所发生的事件</strong>，下图在高层次上说明了Channel、EventLoop、Thread以及EventLoopGroup之间的关系。</p><p><img src="/images/netty1.png" alt="关系图"></p><ol><li>一个EventLoopGroup包含一个或者多个EventLoop</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定</li><li>所有由EventLoop处理的IO事件都将在它专有的Thread上被处理</li><li>一个Channel在它的生命周期内只注册一个EventLoop</li><li>一个EventLoop可能会被分配给一个或者多个Channel</li></ol><h3 id="ChannelFuture接口"><a href="#ChannelFuture接口" class="headerlink" title="ChannelFuture接口"></a>ChannelFuture接口</h3><p>Netty中所有操作都是异步的，因为一个操作不回立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。可以将ChannelFuture看作一个将来要执行的操作的结果的占位符，无法确定什么时候执行，可以确定的是它一定会执行。并且，<strong>所有属于同一个Channel的操作都被保证其将以它们被调用的顺序被执行</strong>。</p><h2 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h2><p>ChannelHandler和ChannelPipeline用于管理数据流和处理应用程序业务逻辑。</p><h3 id="ChannelHandler接口"><a href="#ChannelHandler接口" class="headerlink" title="ChannelHandler接口"></a>ChannelHandler接口</h3><p>对于程序开发人员来说，接触的最多的就是ChannelHandler了，它充当了所有处理入站和出站数据的业务逻辑的容器。举个例子，ChannelInbounudHandler是以后会经常实现的子接口，接收入站数据和事件，这些数据稍后会被你自己的业务代码处理，当需要发送给客户端响应的时候，也可以直接冲ChannelInbounudHandler冲刷数据。</p><h3 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h3><p>ChannelPipeline是一个容器，用于存储ChannelHandler接口，我们先看一段代码：</p><pre><code class="java">....childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            System.out.println(&quot;连接2&quot;);                            //echoServerHandler 中@Sharable表示我们可以使用同样的实例                            ch.pipeline().addLast(echoServerHandler);                        &#125;                    &#125;)</code></pre><p>这是上面EchoServer截取的一段代码，当Channel被创建的时候会分配到它专属的ChannelPipeline中，ChannelHandler安装到ChannelPipeline中的过程如下：</p><ul><li>一个ChannelInitializer的实现被注册到ServerBootstrap中</li><li>当ChannelInitializer.initChannel()方法被调用的时候，ChannelInitializer将在ChannelPipeline安装一组自定义的ChannelHandler</li><li>ChannelInitializer将自己从ChannelPipeline中移除</li></ul><p>ChannelPipeline实际上是一个双向链表，内部是由序的，具体可以看下图：<br><img src="/images/netty2.png" alt="ChannelPipeline顺序"></p><h3 id="深入ChannelHandler"><a href="#深入ChannelHandler" class="headerlink" title="深入ChannelHandler"></a>深入ChannelHandler</h3><p>ChannelHandler有不同类型，它的功能取决于它的超类。Netty以适配器的形式提供了大量的ChannelHandler默认实现，目的是为了简化开发，下面这些是编写自定义 ChannelHandler 时经常会用到的适配器类：</p><blockquote><ul><li><p>ChannelHandlerAdapter</p></li><li><p>ChannelInboundHandlerAdapter </p></li><li><p>ChannelOutboundHandlerAdapter</p></li><li><p>ChannelDuplexHandler</p></li></ul></blockquote><h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p>数据在网络之中传输的是字节的形式，入站的时候消息会被<strong>解码</strong>，即消息从字节转换成另一种格式，通常是Java对象；如果是出站消息，则会发生相反方向的转换，它将从当前的格式被<strong>编码</strong>为字节。</p><p>Netty为了编码器和解码器提供了不同类型的抽象，通常来说这些基类的名称类似于ByteToMessageDecoder或者ByteToByteEncoder。对于特殊的类型，会发现类似于 ProtobufEncoder 和 ProtobufDecoder 这样的名称——预置的用来支持 Google 的 Protocol Buffers。</p><p>所有Netty内置的编码和解码器适配器类都实现了ChannelOutboundHandler 或者 ChannelInboundHandler 接口，所以编码器解码器也是一种特殊的ChannelHandler。</p><h3 id="抽象类SimpleChannelInboundHandler"><a href="#抽象类SimpleChannelInboundHandler" class="headerlink" title="抽象类SimpleChannelInboundHandler"></a>抽象类SimpleChannelInboundHandler</h3><p>假如我们需要利用一个ChannelHandler来接收解码消息，并对该数据进行业务处理，只需要继承<code>SimpleChannelInboundHandler&lt;T&gt;</code>，其中T代表需要处理消息的Java类型。在这个 ChannelHandler 中， 你将需要重写基类的一个或者多个方法，并且获取一个到 ChannelHandlerContext 的引用， 这个引用将作为输入参数传递给 ChannelHandler 的所有方法</p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>就是启动类，Netty为应用程序配置了两个容器，<strong>Bootstrap（用于客户端）</strong>和 <strong>ServerBootstrap（用于服务端）</strong>，下面简单比较了两个类型：</p><table><thead><tr><th>类型</th><th><strong>Bootstrap</strong></th><th>ServerBootstrap</th></tr></thead><tbody><tr><td>网络编程中的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup 的数目</td><td>1</td><td>2</td></tr></tbody></table><p>我们可以看出引导客户端只需要质一个EventLoopGroup，而服务端需要两个EventLoopGroup。</p><p>为什么呢？</p><p>因为服务器需要两组不同的Channel，第一组只包含一个ServerChannel，<strong>代表服务器自身已经绑定到某个本地端口的正在监听套接字</strong>；第二组包含所有已创建的用来处理传入客户端连接的Channel。下图可以作为一个简单的说明：<br><img src="/images/netty3.png" alt="具有两个EventLoopGroup的服务器"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前为止，我们使用Netty写了一个简单的小程序。然后介绍了，netty的一些组件和设计。大家看下来，其实应该有一点点感觉了。别急，我们先自己回忆并练习一下，然后在开始后面的学习。</p><p>加油！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Netty是一款用于创建&lt;strong&gt;高性能&lt;/strong&gt;网络应用程序的高级框架，它的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不必精通网络编程，已经为你预置大量细节&lt;/li&gt;
&lt;li&gt;比直接使用Java本地API要简单的多&lt;/li&gt;
&lt;li&gt;有良好的设计实践，将应用程序逻辑和网络层解耦&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Netty" scheme="https://github/zhuchong6.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>手写tomcat2</title>
    <link href="https://github/zhuchong6.github.io/2023/01/20/2023-1-9mini-tomcat2/"/>
    <id>https://github/zhuchong6.github.io/2023/01/20/2023-1-9mini-tomcat2/</id>
    <published>2023-01-20T16:00:00.000Z</published>
    <updated>2023-08-07T00:18:37.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前，我们完成了tomcat解析Http请求，并将其封装成HttpServelet。这次，我们补全剩余的工作，支持动态加载自定义的servlet文件。</p><span id="more"></span><p>这个项目主要是为了学习，所以我们也只需要模拟这个主流程，<a href="https://github.com/zhuchong6/mini-tomcat">项目地址</a></p><p>首先回忆一下我们如何部署我们的代码到tomcat上的，将项目打包成war包（例如app.war），放到tomcat中的webapps的文件夹下，然后启动就可以了。启动之后，我们发现tomcat会将app.war自动解压成一个文件夹&#x2F;app，文件夹里面有个classes目录放着所有的servlet文件。</p><p>那么问题不就很简单了吗？我们需要首先定位到我们的webapps目录下，然后加载里面的类就行了。</p><h2 id="加载servlet"><a href="#加载servlet" class="headerlink" title="加载servlet"></a>加载servlet</h2><p>首先看下项目结构，和上次相比增加了一个webapps目录，然后在里面添加了一些文件，模拟用户部署的场景。</p><p><img src="/images/mini-tomcat.png" alt="mini-tomcat"></p><ol><li><p>我们需要在tomcat启动之前进行加载的过程，因此在tomcat启动类前加入一个部署的过程。</p><pre><code class="java">    public static void main(String[] args) &#123;        Tomcat tomcat = new Tomcat();        tomcat.deployApps();        tomcat.start();    &#125;    private void deployApps() &#123;        //user.dir获取当前的工作目录，在进入其子目录webapps        File webapps = new File(System.getProperty(&quot;user.dir&quot;), &quot;webapps&quot;);        for (String appName : webapps.list()) &#123;            deployApp(webapps, appName);        &#125;    &#125;/**     * 部署app     * @param webapps webapps目录     * @param appName webapps下面的目录     */private void deployApp(File webapps, String appName) &#123;                //创建一个项目的上下文，用于保存这个项目下url和servlet的映射关系        Context context = new Context(appName);        System.out.println(webapps.toString());        //1.找到当前目录下有哪些servlet        File appDirectory = new File(webapps, appName);        File classesDirectory = new File(appDirectory, &quot;classes&quot;);        System.out.println(classesDirectory);                //找到所有的class文件        List&lt;File&gt; allFiles = getAllFileFromAbsolutePath(classesDirectory);        for (File file : allFiles) &#123;            //加载servlet类            //将/com/zz/t.class---&gt; com.zz.t            String name = file.getPath();            //当前系统的文件分割符号            String separator = File.separator;            name = name.replace(classesDirectory.getPath()+separator, &quot;&quot;);            name = name.replace(&quot;.class&quot;, &quot;&quot;);            name = name.replace(separator, &quot;.&quot;);            System.out.println(name);            //使用类加载器加载类            Class&lt;?&gt; servletClazz = null;            try &#123;                //注意不能使用当前线程的类加载器，因为我们要加载的文件不属于tomcat的工程，所以会提示找不到，这个时候只能使用自定义的类加载器                //servletClazz = Thread.currentThread().getContextClassLoader().loadClass(name);                WebAppClassLoader webAppClassLoader = new WebAppClassLoader(new URL[]&#123;classesDirectory.toURL()&#125;);                servletClazz = webAppClassLoader.loadClass(name);                System.out.println(servletClazz);                                //判断类是否继承HttpServlet                if(HttpServlet.class.isAssignableFrom(servletClazz))&#123;                    System.out.println(servletClazz);                      //判断是否有WebServlet注解                    if(servletClazz.isAnnotationPresent(WebServlet.class))&#123;                        WebServlet annotation = servletClazz.getAnnotation(WebServlet.class);                        String[] strings = annotation.urlPatterns();                        for (String urlPattern : strings) &#123;                              //将满足条件的servlet加入映射                            context.addUrlPatternMapping(urlPattern, (Servlet) servletClazz.newInstance());                        &#125;                    &#125;                &#125;            &#125; catch (MalformedURLException e) &#123;                throw new RuntimeException(e);            &#125; catch (ClassNotFoundException e) &#123;                throw new RuntimeException(e);            &#125; catch (InstantiationException e) &#123;                throw new RuntimeException(e);            &#125; catch (IllegalAccessException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;        contextMap.put(appName, context);    &#125;</code></pre><p>部署过程非常简单，具体可以看下代码。我这里简单解释下，就是寻找在webapps下面的所有的servlet，然后将他们加载进来；然后，在更加app名称，url地址进行一个分类，建立url和servlet的映射着一点非常重要。</p></li><li><p>部署完成之后，我们就需要修改我们之前的代码，将原来的硬编码创建servlet修改成使用加载的servlet在执行接受请求和发送响应。</p><pre><code class="java">...  //            //这里自定义Servlet模拟用户写的servlet，暂时没写到tomcat加载webapps的servlet出此下策//            SelfServlet selfServlet = new SelfServlet();//            selfServlet.service(request, response);            //通过url 找到对应的servlet            String requestUrl = request.getRequestURL().toString();            System.out.println(&quot;requestUrl = &quot; + requestUrl);            requestUrl = requestUrl.substring(1);            String[] part = requestUrl.split(&quot;/&quot;);            String appName = part[0];            if(part.length&gt;1)&#123;                String urlPattern = part[1];                Context context = tomcat.getContextMap().get(appName);                if(context != null)&#123;                    Servlet servlet = context.getByUrlPattern(urlPattern);                    if(servlet != null)&#123;                        servlet.service(request, response);                        //发送响应                        response.complete();                    &#125;else&#123;                        //servlet为空，搞一个默认的servlet                        DefaultServlet defaultServlet = new DefaultServlet();                        defaultServlet.service(request,response);                        //发送响应                        response.complete();                    &#125;                &#125;            &#125;...</code></pre><p>这里很简单了，通过我们请求的url查找到相应的servelt，如果找不到就用默认的servlet处理。</p></li><li><p>测试一下，发现能够正常的返回。然后，我们还可以在webapps下重新部署一个工程在进行测试，看能不能正常返回。</p></li></ol><p>自此，项目完结。实际上的tomcat比这个复杂很多，我这里只是为了学习做的一个toy project，能够让我理清脉络，不用迷失在繁杂的细节中。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;之前，我们完成了tomcat解析Http请求，并将其封装成HttpServelet。这次，我们补全剩余的工作，支持动态加载自定义的servlet文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Tomcat" scheme="https://github/zhuchong6.github.io/categories/Tomcat/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Tomcat" scheme="https://github/zhuchong6.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习之NIO入门</title>
    <link href="https://github/zhuchong6.github.io/2023/01/19/2023-01-19netty%E5%AD%A6%E4%B9%A002/"/>
    <id>https://github/zhuchong6.github.io/2023/01/19/2023-01-19netty%E5%AD%A6%E4%B9%A002/</id>
    <published>2023-01-19T13:39:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文回忆一下Java中的io编程，看一下目前Java提供的网络编程库的演进过程。</p><span id="more"></span><p>本文所有的代码都在这类<a href="https://github.com/zhuchong6/netty-learn">代码地址</a></p><h2 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a>BIO编程</h2><p>采用BIO通信模型的服务端，由独立的Acceptor线程负责监听客户端连接，它接收到客户端连接后为每一个客户创建一个新的线程模型进行业务处理，处理完成之后，通过输出流返回给客户端，然后线程就销毁了，基本流程图可以看下图：</p><p><img src="/images/BIO-DEMO.png" alt="BIO"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>BIODemoClient</strong></p><pre><code class="java">public class BIODemoClient &#123;    public static void main(String[] args) throws IOException &#123;        int port  = 8080;        final Socket socket = new Socket(&quot;localhost&quot;, port);        final BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));        final PrintWriter out = new PrintWriter(socket.getOutputStream(), true);        System.out.println(&quot;查询时间&quot;);        out.println(&quot;QUERY TIME ORDER&quot;);        final String resp = in.readLine();        System.out.println(&quot;服务器返回时间是：&quot;+ resp);    &#125;&#125;</code></pre><p><strong>BIODemoServer</strong></p><pre><code class="java">public class BIODemoServer &#123;    public static void main(String[] args) throws IOException &#123;        int port = 8080;        ServerSocket serverSocket = null;        try &#123;            serverSocket = new ServerSocket(port);            System.out.println(&quot;服务器启动,端口：&quot;+8080);            Socket socket = null;            while(true)&#123;                socket = serverSocket.accept();                new Thread(new TimeServerHandler(socket)).start();            &#125;        &#125; finally &#123;            if(serverSocket != null)&#123;                System.out.println(&quot;服务器关闭&quot;);                serverSocket.close();                serverSocket = null;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>TimeServerHandler</strong></p><pre><code class="java">public class TimeServerHandler implements Runnable&#123;    private  Socket socket;    public TimeServerHandler(Socket socket) &#123;        this.socket = socket;    &#125;    @Override    public void run() &#123;        BufferedReader in = null;        PrintWriter out = null;        try &#123;            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));            out = new PrintWriter(socket.getOutputStream(), true);            String body = null;            String currentTime = null;            while (true)&#123;               body = in.readLine();               if(body == null)&#123;                   break;               &#125;               System.out.println(&quot;时间服务器接收命令：&quot;+body);               currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body)? new Date(System.currentTimeMillis()).toString(): &quot;BAD ORDER&quot;;               out.println(currentTime);            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            //关闭资源            if(in !=null)&#123;                try &#123;                    in.close();                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            if(out != null)&#123;                out.close();            &#125;            if(socket != null)&#123;                try &#123;                    socket.close();                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;                socket = null;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="BIO编程的优化"><a href="#BIO编程的优化" class="headerlink" title="BIO编程的优化"></a>BIO编程的优化</h2><p>完成上面的demo之后我们发现，每次请求都对应一次线程的创建，大家都知道在Java中线程资源十分昂贵，自然而然我们就想到用线程池去优化。所以，我们的编程模型做了一点稍微的改动，具体如下图：</p><p><img src="/images/BIO_DEMO2.png" alt="BIO"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>只需要简单修改下服务端的代码即可</p><pre><code class="java">public class BIODemoServer2 &#123;    public static void main(String[] args) throws IOException &#123;        int port = 8080;        ServerSocket serverSocket = null;        try &#123;            serverSocket = new ServerSocket(port);            System.out.println(&quot;服务器启动,端口：&quot;+8080);            //增加一个线程池            final ExecutorService executorService = Executors.newFixedThreadPool(2);            Socket socket = null;            while(true)&#123;                socket = serverSocket.accept();                executorService.execute(new TimeServerHandler(socket));//                new Thread(new TimeServerHandler(socket)).start();            &#125;        &#125; finally &#123;            if(serverSocket != null)&#123;                System.out.println(&quot;服务器关闭&quot;);                serverSocket.close();                serverSocket = null;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h2><p>NIO编程，也叫非阻塞编程。是JDK在1.4引入，祢补了同步IO的不足，为Java提供了高速的，面向块的IO（BIO是流模型）。</p><p>NIO这一套IO其核心思想就是<strong>通过事件通知的方式告诉select哪些连接已经就绪可以进行IO操作</strong>，这种模型提供了更好的资源管理：</p><ul><li>是用较少的线程可以处理许多连接，因此也减少了内存管理和上下文切换所带来开销</li><li>当没有 I&#x2F;O 操作需要处理的时候，线程也可以被用于其他任务</li></ul><p>下面是IO模型图：</p><p><img src="/images/NIO-DEMO.png" alt="NIO"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><strong>TimeServerHandler</strong></p><pre><code class="java">public class TimeServerHandler implements Runnable&#123;    private  Socket socket;    public TimeServerHandler(Socket socket) &#123;        this.socket = socket;    &#125;    @Override    public void run() &#123;        BufferedReader in = null;        PrintWriter out = null;        try &#123;            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));            out = new PrintWriter(socket.getOutputStream(), true);            String body = null;            String currentTime = null;            while (true)&#123;               body = in.readLine();               if(body == null)&#123;                   break;               &#125;               System.out.println(&quot;时间服务器接收命令：&quot;+body);               currentTime = &quot;QUERY TIME ORDER&quot;.equalsIgnoreCase(body)? new Date(System.currentTimeMillis()).toString(): &quot;BAD ORDER&quot;;               out.println(currentTime);            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; finally &#123;            //关闭资源            if(in !=null)&#123;                try &#123;                    in.close();                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            if(out != null)&#123;                out.close();            &#125;            if(socket != null)&#123;                try &#123;                    socket.close();                &#125; catch (IOException e) &#123;                    throw new RuntimeException(e);                &#125;                socket = null;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>TimeClientHandle</strong></p><pre><code class="java">public class TimeClientHandle implements Runnable &#123;    private String host;    private int port;    private Selector selector;    private SocketChannel socketChannel;    private volatile boolean stop;    public TimeClientHandle(String host, int port) &#123;        this.host = host == null ? &quot;127.0.0.1&quot; : host;        this.port = port;        try &#123;            //1.打开SocketChannel            socketChannel = SocketChannel.open();            //2.设置SocketChannel为非阻塞模式            socketChannel.configureBlocking(false);            //4.创建多路复用器            selector = Selector.open();        &#125; catch (Exception e) &#123;            e.printStackTrace();            System.exit(1);        &#125;    &#125;    public void run() &#123;        try &#123;            doConnect();        &#125; catch (IOException e) &#123;            e.printStackTrace();            System.exit(1);        &#125;        while (!stop) &#123;            try &#123;                //5.轮询准备就绪的key                selector.select(1000);                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();                SelectionKey key = null;                while (iterator.hasNext()) &#123;                    key = iterator.next();                    iterator.remove();                    try &#123;                        handleInput(key);                    &#125; catch (Exception e) &#123;                        if (key != null) &#123;                            key.cancel();                            if (key.channel() != null)                                key.channel().close();                        &#125;                    &#125;                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();                System.exit(1);            &#125;        &#125;        //多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去注册并关闭，所以不需要重复释放资源        if (selector != null) &#123;            try &#123;                selector.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    private void handleInput(SelectionKey key) throws IOException &#123;        if (key.isValid()) &#123;            SocketChannel sc = (SocketChannel) key.channel();            //6.接收connect事件进行处理            if (key.isConnectable()) &#123;                //7.连接成功，注册读事件到多路复用器                if (sc.finishConnect()) &#123;                    sc.register(selector, SelectionKey.OP_READ);                    doWrite(sc);                &#125; else &#123;                    System.exit(1);                &#125;            &#125;            //8.异步读服务器返回消息到缓冲区            if (key.isReadable()) &#123;                ByteBuffer readBuffer = ByteBuffer.allocate(1024);                int readBytes = sc.read(readBuffer);                if (readBytes &gt; 0) &#123;                    readBuffer.flip();                    byte[] bytes = new byte[readBuffer.remaining()];                    readBuffer.get(bytes);                    String body = new String(bytes, &quot;UTF-8&quot;);                    System.out.println(&quot;Now is:&quot; + body);                    this.stop = true;                &#125; else if (readBytes &lt; 0) &#123;                    key.cancel();                    sc.close();                &#125; else &#123;                    System.out.println(&quot;0 size bytes.&quot;);                &#125;            &#125;        &#125;    &#125;    private void doConnect() throws IOException &#123;        //3.异步连接服务器        //成功，注册        if (socketChannel.connect(new InetSocketAddress(host, port))) &#123;            socketChannel.register(selector, SelectionKey.OP_READ);            doWrite(socketChannel);        &#125; else &#123;//注册，监听服务器的ack            socketChannel.register(selector, SelectionKey.OP_CONNECT);        &#125;    &#125;    private void doWrite(SocketChannel sc) throws IOException &#123;        //9.调用SocketChannel的异步write接口，将消息异步发送给服务器        byte[] req = &quot;QUERY TIME ORDER&quot;.getBytes();        ByteBuffer writeBuffer = ByteBuffer.allocate(req.length);        writeBuffer.put(req);        writeBuffer.flip();        sc.write(writeBuffer);        if (!writeBuffer.hasRemaining()) &#123;            System.out.println(&quot;Send order 2 server succeed.&quot;);        &#125;    &#125;&#125;</code></pre><p>我们可以看出，使用Java NIO API开发的程序过程十分繁琐，API设计的一点都不易用，最关键的是臭民昭著的<strong>epoll bug</strong>至今还没有完善，这就是为什么netty会诞生。Netty设计的更加合理易于使用，性能比原生的NIO还要好，并且占用资源更加低，还有什么理由不去使用呢？</p><p>ok，这次先聊到这，下一篇应该是进入正题了，开始学习netty的开发。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;本文回忆一下Java中的io编程，看一下目前Java提供的网络编程库的演进过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Netty" scheme="https://github/zhuchong6.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习之IO基础</title>
    <link href="https://github/zhuchong6.github.io/2023/01/18/2023-01-19netty%E5%AD%A6%E4%B9%A001/"/>
    <id>https://github/zhuchong6.github.io/2023/01/18/2023-01-19netty%E5%AD%A6%E4%B9%A001/</id>
    <published>2023-01-18T13:39:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Netty是一个网络开发的库，它在Java网络开发中的地位相当于Spring之于Java。</p><p>Netty是基于Java NIO开发的一套网络库，在其基础上提升了API的易用性，修复了Java NIO存在的一些bug。</p><span id="more"></span><h1 id="IO基础"><a href="#IO基础" class="headerlink" title="IO基础"></a>IO基础</h1><h2 id="Linux网络IO模型简介"><a href="#Linux网络IO模型简介" class="headerlink" title="Linux网络IO模型简介"></a>Linux网络IO模型简介</h2><p>Linux内核将所有外部设施都看作一个文件进行操作，对一个文件的读写操作会执行内核提供的系统调用（可以理解为操作系统提供的api），返回一个文件描述符(fd,文件描述符)。同理，对于socket的读写也有相应的描述符，成为socketfd（socket描述符）。描述符就是一个数字，指向内核的一个结构体（文件路径，数据区等一些属性）</p><p>UNIX网络编程提供了5种IO模型，分别如下：</p><h3 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h3><p>最常用的IO模型，默认情况下，所有文件操作都是阻塞的。在进程空间中调用recvfrom，其系统调用<strong>直到数据包到达且被复制到应用进程的缓冲区中或者发生错误</strong>才返回。在此期间，会一直等待，进程在调用recvfrom开始到它返回数据整段时间内都是阻塞的，因此被称为阻塞IO模型。具体调用流程如下图：</p><p><img src="/images/BIO.png" alt="BIO"></p><h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>recvfrom从应用层到内核的时候，如果缓存区没有数据，直接返回一个EWOULDBLOCK错误，一般对非阻塞IO模型轮询这个状态，检查数据是否到来。具体调用流程如下图：</p><p><img src="/images/NonBlockIO.png" alt="BIO"></p><h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>Linux提供select&#x2F;poll，进程通过将一个或者多个fd传递给select或者poll系统调用，阻塞在select上，这样select&#x2F;poll可以帮我侦测多个fd是否处于就绪状态。select&#x2F;poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到一些限制。同时，Linux还提供一个epoll系统调用，epoll使用基于事件驱动的方式代替顺序扫描，因此性能更高。当有fd就绪，立即回调函数rollback。具体调用流程如下：</p><p><img src="/images/FYIO.png" alt="BIO"></p><h3 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h3><p>首先开启套接字接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立刻返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用用recvfrom来读取数据，并通知主循环处理数据。具体调用流程如下：</p><p><img src="/images/sigIO.png" alt="BIO"></p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>告知内核启用某个操作，并让内核在整个操作系统完成后（包括将数据从内核复制到用户自己的缓存区）通知我们。这种模型和信号量驱动模型有点类似，区别是：信号驱动IO由内核通知我们什么时候可以开始一个IO操作；异步IO由内核通知我们IO操作合适已经完成。具体调用流程如下：</p><p><img src="/images/AIO.png" alt="BIO"></p><p>了解这些网络IO模型之后，会对于理解Java的NIO类库有帮助。</p><h2 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h2><p>在IO编程中，如果需要同时处理多个客户端的接入请求时，可以利用多线程或者IO多路复用技术处理。IO多路复用是将多个IO阻塞复用到一个select阻塞上去，使得系统在单线程的情况下可以同时处理多个客户端的请求。于传统多线程多进程模型相比，IO多路复用的优势就是<strong>系统开销小</strong>，系统不需要创建新的额外的进程或者线程，也不需要维护这些进程和线程的运行，降低了系统维护的工作量，节省了系统的资源，IO多路复用的场景：</p><ol><li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字</li><li>服务器需要处理多种网络协议的套接字</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;Netty是一个网络开发的库，它在Java网络开发中的地位相当于Spring之于Java。&lt;/p&gt;
&lt;p&gt;Netty是基于Java NIO开发的一套网络库，在其基础上提升了API的易用性，修复了Java NIO存在的一些bug。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Netty" scheme="https://github/zhuchong6.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>手写tomcat</title>
    <link href="https://github/zhuchong6.github.io/2023/01/08/2023-1-9mini-tomcat1/"/>
    <id>https://github/zhuchong6.github.io/2023/01/08/2023-1-9mini-tomcat1/</id>
    <published>2023-01-08T16:00:00.000Z</published>
    <updated>2023-08-07T00:18:37.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作web开发的朋友对于tomcat应该不陌生，大家一直在和他打交道。</p><p>这边文章主要是模拟tomcat的主要功能，来自己实现一个简单的tomcat，用于更加清晰的理解它。</p><span id="more"></span><p>我们先回忆一下，tomcat做了什么？</p><p>在前后端统一的时代，我们会将写好的代码和jsp（主要是servlet实现类，jsp也是编译成servlet）打包，然后放到tomcat容器webapps目录下，然后启动tomcat容器，访问<code>localhost:80(默认端口)</code>，就能在本地浏览器中动态访问网页了。</p><p>经过上面的回忆，我们发现tomcat主要是做了两部分工作：</p><ol><li>处理浏览器发送给tomcat的请求，将其转发到响应的servlet中去</li><li>加载webapps下项目中的servlet实现类</li></ol><p>这个项目主要是为了学习，所以我们也只需要模拟这个主流程，<a href="https://github.com/zhuchong6/mini-tomcat">项目地址</a></p><h2 id="处理Http请求"><a href="#处理Http请求" class="headerlink" title="处理Http请求"></a>处理Http请求</h2><p>Http协议是应用层的协议，是基于tcp&#x2F;ip的协议，而tcp&#x2F;ip协议开发过于繁琐，于是就有了一个socket的抽象层，在tomcat中我们的Http协议就是基于Socket来实现的。</p><ol><li><p>首先，我们创建一个Tomcat类，并启动一个SocketServer，具体如下：</p><pre><code class="java">package com.zhu;import java.io.IOException;import java.net.ServerSocket;public class Tomcat &#123;    public void start()&#123;        try &#123;            ServerSocket serverSocket = new ServerSocket(8080);            serverSocket.accept();        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        Tomcat tomcat = new Tomcat();        tomcat.start();    &#125;&#125;</code></pre></li><li><p>这个时候我们已经有了一个serversocket用于监听socket客户端发送的请求，这个时候我们其实可以在浏览器中输入<code>localhost:8080</code>,打上断点发现其实也能访问。但是，有个问题，就是访问一次之后程序就停止了，这明显不合理，怎么可能一个tomcat只处理一次请求能。因此，我们需要一个死循环来处理源源不断的请求。将上面代码进行一个修改。</p><pre><code class="java">package com.zhu;import java.io.IOException;import java.net.ServerSocket;public class Tomcat &#123;    public void start()&#123;        try &#123;            while (true)&#123;                ServerSocket serverSocket = new ServerSocket(8080);                serverSocket.accept();            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        Tomcat tomcat = new Tomcat();        tomcat.start();    &#125;&#125;</code></pre></li><li><p>接下来的问题就简单了，我们已经拿到了前端发过来的请求，所以下一步就只要解析http请求即可。解析之前，我们先看下http请求报文的格式：</p><p><strong>HTTP请求报文有四个部分组成：请求行（request line）、请求头（request header）、空行和请求数据（request data）</strong></p><p><img src="/images/http-request.png" alt="http请求报文格式"></p></li><li><p>我们新建一个类SocketProcesser专门用于处理socket连接，解析http报文，这里为了简单处理我们只解析请求行的信息，并将解析出来的信息放到自定义的Request中：</p><pre><code class="java">package com.zhu;import com.zz.SelfServlet;import javax.servlet.ServletException;import java.io.IOException;import java.io.InputStream;import java.net.Socket;public class SocketProcessor implements Runnable&#123;    private Socket socket;    public SocketProcessor(Socket socket) &#123;        this.socket = socket;    &#125;    private void processSocket(Socket socket) &#123;        //处理socket连接，解析读取的数据，写返回的数据        try &#123;            InputStream inputStream = socket.getInputStream();            //读取1kb的数据到bytes数组，暂时简单测试，正式中应该用循环读取            byte[] bytes = new byte[2048];            inputStream.read(bytes);            //解析http请求，这里简单化处理只请求第一行内容，即请求方法，请求路径，协议版本            //GET /hello HTTP/1.1            Request request = extracted(bytes, new Request());                    &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; catch (ServletException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private static Request extracted(byte[] bytes, Request request) &#123;        //解析GET，原理是遇到第一个空格返回，记录下标和内容        int endPosition  = 0;        StringBuilder stringBuilder = new StringBuilder();        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39; &#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String method = stringBuilder.toString();        request.setMethod(method);        //清空暂存        stringBuilder.delete(0, stringBuilder.length());        //解析URL        endPosition++;        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39; &#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String url = stringBuilder.toString();        request.setUrl(url);        //清空暂存，在endPosition之后遇到第一个\r符号就停止        stringBuilder.delete(0, stringBuilder.length());        //解析URL        endPosition++;        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39;\r&#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String protocal = stringBuilder.toString();        request.setProtocol(protocal);        return request;    &#125;    @Override    public void run() &#123;        processSocket(socket);    &#125;&#125;</code></pre><pre><code class="java">package com.zhu;import java.net.Socket;//AbstractRequest就是一个抽象类实现了HttpServletRequest的接口，方便后续实现指定的几个接口//不然的话，就需要实现所有HttpServletRequest接口的所有方法了，这里略去了get/setpublic class Request extends AbstractRequest &#123;    private String method;    private String url;    private String protocol;    private Socket socket;    public Request() &#123;    &#125;    public Request(String method, String url, String protocol, Socket socket) &#123;        this.method = method;        this.url = url;        this.protocol = protocol;        this.socket = socket;    &#125;&#125;</code></pre></li><li><p>理论上来讲，我们已经将解析好http请求，并将其封到Request类中，这个时候只需要将其传递到我们自定义的Servlet中做一些我们自定义的业务处理。但是，我们目前还没写加载webapps目录下的servlet，所以我们先简单new一个跑通流程再说：</p><pre><code class="java">package com.zz;//com.zz包下，代表用户自定义的servlet com.zhu代表我们mini-tomcat框架的import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SelfServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        System.out.println(&quot;user servlet:&quot;+req.getMethod());      //这两个请求头必须要加，不然浏览器无法正常显示数据        resp.addHeader(&quot;Content-Length&quot;, &quot;12&quot;);        resp.addHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=utf-8&quot;);      //我们这里简单打印一个字符串        resp.getOutputStream().write(&quot;hello , mini-tomcat&quot;.getBytes());    &#125;&#125;</code></pre><p>于此同时，SocketProcessor也要进行修改：</p><pre><code class="java">package com.zhu;import com.zz.SelfServlet;import javax.servlet.ServletException;import java.io.IOException;import java.io.InputStream;import java.net.Socket;public class SocketProcessor implements Runnable&#123;    private Socket socket;    public SocketProcessor(Socket socket) &#123;        this.socket = socket;    &#125;    private void processSocket(Socket socket) &#123;        //处理socket连接，解析读取的数据，写返回的数据        try &#123;            InputStream inputStream = socket.getInputStream();            //读取1kb的数据到bytes数组，暂时简单测试，正式中应该用循环读取            byte[] bytes = new byte[2048];            inputStream.read(bytes);            //解析http请求，这里简单化处理只请求第一行内容，即请求方法，请求路径，协议版本            //GET /hello HTTP/1.1            Request request = extracted(bytes, new Request());            //这里自定义Servlet模拟用户写的servlet，暂时没写到tomcat加载webapps的servlet出此下策            SelfServlet selfServlet = new SelfServlet();              //这里service会自动根据Http的请求方式（get post等）来找对应的方法（doget dopost）            selfServlet.service(request, response);                    &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; catch (ServletException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private static Request extracted(byte[] bytes, Request request) &#123;        //解析GET，原理是遇到第一个空格返回，记录下标和内容        int endPosition  = 0;        StringBuilder stringBuilder = new StringBuilder();        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39; &#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String method = stringBuilder.toString();        request.setMethod(method);        //清空暂存        stringBuilder.delete(0, stringBuilder.length());        //解析URL        endPosition++;        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39; &#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String url = stringBuilder.toString();        request.setUrl(url);        //清空暂存，在endPosition之后遇到第一个\r符号就停止        stringBuilder.delete(0, stringBuilder.length());        //解析URL        endPosition++;        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39;\r&#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String protocal = stringBuilder.toString();        request.setProtocol(protocal);        return request;    &#125;    @Override    public void run() &#123;        processSocket(socket);    &#125;&#125;</code></pre></li><li><p>最后，就是将信息返回给浏览器端了，所以我们定义了一个Response类，用于生成http返回报文：</p><p><strong>HTTP响应报文也有四个部分组成，和请求报文格式是差不多的，包含状态行（status line）、响应头部（headers）、空行（blank line）和响应数据（也叫响应体或响应正文），图中请求数据换成响应的正文即可。</strong></p><p><img src="/images/http-request.png" alt="http请求报文格式"></p><p>代码如下：</p><pre><code class="java">package com.zhu;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;public class Response extends AbstractResponse&#123;    private int status = 200;    private String message = &quot;OK&quot;;    private byte SP = &#39; &#39;;    private byte CR = &#39;\r&#39;;    private byte LF = &#39;\n&#39;;    private Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();    private Request request;    private OutputStream socketOutputSteam;    ResponseServletOutputStream responseServletOutputStream = new ResponseServletOutputStream();    public Response(Request request) &#123;        this.request = request;        try &#123;            this.socketOutputSteam = request.getSocket().getOutputStream();        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    @Override    public int getStatus() &#123;        return status;    &#125;    @Override    public void setStatus(int status, String message) &#123;        this.status = status;        this.message = message;    &#125;    @Override    public void addHeader(String s, String s1) &#123;        headers.put(s, s1);    &#125;    @Override    public ResponseServletOutputStream getOutputStream() throws IOException &#123;        return responseServletOutputStream;    &#125;    /**     * 实际发送响应的地方     * 也是实现http response协议格式的地方     */    public void complete()&#123;        try &#123;            //发送响应行            sendResponseLine();            //发送响应头            sendResponseHeader();            //发送响应体            sendResponseBody();        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private void sendResponseBody() throws IOException &#123;        socketOutputSteam.write(getOutputStream().getBytes());    &#125;    private void sendResponseHeader() throws IOException&#123;        for (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;            String key = entry.getKey();            String value = entry.getValue();            socketOutputSteam.write(key.getBytes());            socketOutputSteam.write(&quot;:&quot;.getBytes());            socketOutputSteam.write(value.getBytes());            socketOutputSteam.write(CR);            socketOutputSteam.write(LF);        &#125;        socketOutputSteam.write(CR);        socketOutputSteam.write(LF);    &#125;    private void sendResponseLine() throws IOException &#123;        socketOutputSteam.write(request.getProtocol().getBytes());        socketOutputSteam.write(SP);        socketOutputSteam.write(status);        socketOutputSteam.write(SP);        socketOutputSteam.write(message.getBytes());        socketOutputSteam.write(CR);        socketOutputSteam.write(LF);    &#125;&#125;</code></pre><p>同时修改SocketProcessor：</p><pre><code class="java">package com.zhu;import com.zz.SelfServlet;import javax.servlet.ServletException;import java.io.IOException;import java.io.InputStream;import java.net.Socket;public class SocketProcessor implements Runnable&#123;    private Socket socket;    public SocketProcessor(Socket socket) &#123;        this.socket = socket;    &#125;    private void processSocket(Socket socket) &#123;        //处理socket连接，解析读取的数据，写返回的数据        try &#123;            InputStream inputStream = socket.getInputStream();            //读取1kb的数据到bytes数组，暂时简单测试，正式中应该用循环读取            byte[] bytes = new byte[2048];            inputStream.read(bytes);            //解析http请求，这里简单化处理只请求第一行内容，即请求方法，请求路径，协议版本            //GET /hello HTTP/1.1            Request request = extracted(bytes, new Request());            request.setSocket(socket);            Response response = new Response(request);            //这里自定义Servlet模拟用户写的servlet，暂时没写到tomcat加载webapps的servlet出此下策            SelfServlet selfServlet = new SelfServlet();              //这里service会自动根据Http的请求方式（get post等）来找对应的方法（doget dopost）            selfServlet.service(request, response);                        //发送响应            response.complete();                    &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125; catch (ServletException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private static Request extracted(byte[] bytes, Request request) &#123;        //解析GET，原理是遇到第一个空格返回，记录下标和内容        int endPosition  = 0;        StringBuilder stringBuilder = new StringBuilder();        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39; &#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String method = stringBuilder.toString();        request.setMethod(method);        //清空暂存        stringBuilder.delete(0, stringBuilder.length());        //解析URL        endPosition++;        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39; &#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String url = stringBuilder.toString();        request.setUrl(url);        //清空暂存，在endPosition之后遇到第一个\r符号就停止        stringBuilder.delete(0, stringBuilder.length());        //解析URL        endPosition++;        for(; endPosition&lt; bytes.length; endPosition++)&#123;            char currentChar = (char) bytes[endPosition];            if( currentChar == &#39;\r&#39;)&#123;                break;            &#125;            stringBuilder.append(currentChar);        &#125;        String protocal = stringBuilder.toString();        request.setProtocol(protocal);        return request;    &#125;    @Override    public void run() &#123;        processSocket(socket);    &#125;&#125;</code></pre><p>可以看见，一次浏览器请求都是一个request对应一个response。</p></li><li><p>最后，还有一个问题没有解决。目前为止，我们所有的请求都是单线程的。只有等第一个http请求连接完成，执行完解析，处理自定义业务（自定义的servlet中处理的），返回报文，第二个http请求才能进入。我们将其简单又滑下，将连接和解析处理任务分开，具体代码如下：</p><pre><code class="java">package com.zhu;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Tomcat &#123;    public void start()&#123;        //Socket 链接        try &#123;            //访问http://localhost:8080            ServerSocket serverSocket = new ServerSocket(8080);            ExecutorService executorService = Executors.newFixedThreadPool(10);            //支持多个socket连接请求，如果不加循环的话，第一次执行完，就会结束vm            while(true)&#123;                Socket socket = serverSocket.accept();                //用其他线程去做一些解析或者其他工作，主线程只用于接收请求                executorService.execute(new SocketProcessor(socket));            &#125;        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    public static void main(String[] args) &#123;        Tomcat tomcat = new Tomcat();        tomcat.start();    &#125;&#125;</code></pre></li><li><p>然后，启动项目访问<code>http://localhost:8080/hello</code>会出现我们设置的结果。</p></li></ol><p>目前，我们完成了tomcat解析http，并将其封装到Request类中，然后传递到我们自定义的servlet业务类中，执行业务之后能够正常返回http报文。</p><p>下篇文章将补全tomcat加载webapps下面的业务servlet，不用像现在一样硬编码，敬请期待！😄😄😄</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;作web开发的朋友对于tomcat应该不陌生，大家一直在和他打交道。&lt;/p&gt;
&lt;p&gt;这边文章主要是模拟tomcat的主要功能，来自己实现一个简单的tomcat，用于更加清晰的理解它。&lt;/p&gt;</summary>
    
    
    
    <category term="Tomcat" scheme="https://github/zhuchong6.github.io/categories/Tomcat/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Tomcat" scheme="https://github/zhuchong6.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之AOP</title>
    <link href="https://github/zhuchong6.github.io/2022/12/15/2022-12-08mini-spring8/"/>
    <id>https://github/zhuchong6.github.io/2022/12/15/2022-12-08mini-spring8/</id>
    <published>2022-12-15T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，已经完成了BeanPostProcessor实现，这篇文章着重讲述AOP如何实现。</p><p>让我们开始吧！😊</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><p>aop也就是切面编程，实际在我们的spring中其实就是生产一个代理类，这个代理类包含了原有类的操作，然后又增强了一些其他的操作。</p><p>我们可以想到，既然是代理类，那么肯定是原始类已经生产完之后，才回根据它生成，不然后就会导致代理类和被代理对象的不一致。</p><p>显而易见，我们可以在BeanPostProcessor中的afterinit方法中去实现这个逻辑，我们截取关键代码：</p><pre><code class="java">public Object postProcessAfterInitialization(Object bean, String beanName) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;after init bean processor&quot;);        &#125;              //这里只是区分下让逻辑分开，其实可以和上面合并在一起        if(beanName.equals(&quot;userService&quot;))&#123;              //创建代理类，这里使用jdk的动态代理，理由很简单无需引用其他三方的包              //但是需要在UserService中实现一个接口，具体可以看我们的代码            return Proxy.newProxyInstance(SelfTestBeanPostProcessor.class.getClassLoader(),                    bean.getClass().getInterfaces(), new InvocationHandler() &#123;                @Override                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                      //这里写的就是切面的逻辑                    System.out.println(&quot;aop logic-----&quot;);                      //这里调用原来的方法                    return method.invoke(bean, args);                &#125;            &#125;);        &#125;        return bean;&#125;</code></pre><p>完成之后，执行相关测试代码：</p><blockquote><p>before init bean processor<br>initializing bean —-afterPropertiesSet<br>after init bean processor<br>aop logic<br>com.zhu.service.OrderService@6f94fa3e|userService</p></blockquote><p>有我们想要的效果，这就是一个简单的aop实现。</p><p>自此，我们完成了我们的目标，写了一个简单的spring，比较清晰的了解了spring的生命周期，为我们后续理解spring源码做了一个简单的指引。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，已经完成了BeanPostProcessor实现，这篇文章着重讲述AOP如何实现。&lt;/p&gt;
&lt;p&gt;让我们开始吧！😊&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之BeanPostProcessor后置处理器</title>
    <link href="https://github/zhuchong6.github.io/2022/12/14/2022-12-08mini-spring7/"/>
    <id>https://github/zhuchong6.github.io/2022/12/14/2022-12-08mini-spring7/</id>
    <published>2022-12-14T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，已经完成了初始化的过程，十分简单。这次我们将学习BeanPostProcessor，来使我们初始化的过程更加的精细以及灵活。</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><p>BeanPostProcessor这个接口作用是在初始化前后，对bean进行一些操作，我们首先需要定义接口，代码如下：</p><pre><code class="java">package com.zhu.spring;public interface BeanPostProcessor &#123;    /**     * do something before init     * 初始化之前做一些动作     */    void postProcessBeforeInitialization(Object bean, String beanName);    /**     * do something after init     * 初始化结束之后做一些动作     */    void postProcessAfterInitialization(Object bean, String beanName);&#125;</code></pre><p>然后，需要在我们的核心容器类<strong>MiniSpringApplicationContext</strong>添加一些实现，具体如下：</p><pre><code class="java">package com.zhu.spring;import java.beans.Introspector;import java.io.File;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.net.URL;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class MiniSpringApplicationContext &#123;    private Class configClass;    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;();    private Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();    private List&lt;BeanPostProcessor&gt; beanPostProcessorList = new ArrayList&lt;&gt;();    public MiniSpringApplicationContext(Class configClass) &#123;        this.configClass = configClass;        //scan the class decorate by @ComponentScan        if(configClass.isAnnotationPresent(ComponentScan.class))&#123;            ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);            //scan path, eg: com.zhu.service            String path = componentScanAnnotation.value();            //  com.zhu.service  ----&gt; com/zhu/service            path = path.replace(&quot;.&quot;, &quot;/&quot;);            //find absolute path from MiniSpringApplicationContext context            ClassLoader classLoader = MiniSpringApplicationContext.class.getClassLoader();            // get url , /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service            URL resource = classLoader.getResource(path);            File file = new File(resource.getFile());            if(file.isDirectory())&#123;                File[] files = file.listFiles();                for (File f : files) &#123;                    String absolutePath = f.getAbsolutePath();                    if(absolutePath.endsWith(&quot;.class&quot;))&#123;                        //real load class                            // /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service/UserService ---&gt; com.zhu.service.UserService                            //com/zhu/service/UserService                            String className = absolutePath.substring(absolutePath.indexOf(&quot;com&quot;), absolutePath.indexOf(&quot;.class&quot;));                            //com.zhu.service.UserService                            className = className.replace(&quot;/&quot;, &quot;.&quot;);                        try &#123;                            Class&lt;?&gt; clazz = classLoader.loadClass(className);                            if(clazz.isAnnotationPresent(Component.class))&#123;                                                                //新增代码，判断clazz上是否实现或者继承了BeanPostProcessor接口，然后将其加入定义的List中                                if(BeanPostProcessor.class.isAssignableFrom(clazz))&#123;                                    BeanPostProcessor instance = (BeanPostProcessor)clazz.newInstance();                                    beanPostProcessorList.add(instance);                                &#125;                                Component componentAnnotation = clazz.getAnnotation(Component.class);                                String beanName = componentAnnotation.value();                                if(&quot;&quot;.equals(beanName))&#123;                                    //transfer name ,eg: Service-&gt;service SService-&gt;SService, SerR-&gt;serR                                    beanName = Introspector.decapitalize(clazz.getSimpleName());                                &#125;                                //generate BeanDefinition                                BeanDefinition beanDefinition = new BeanDefinition();                                beanDefinition.setType(clazz);                                if (clazz.isAnnotationPresent(Scope.class)) &#123;                                    Scope scopeAnnotation = clazz.getAnnotation(Scope.class);                                    beanDefinition.setScope(scopeAnnotation.value());                                &#125;else&#123;                                    beanDefinition.setScope(&quot;singleton&quot;);                                &#125;                                beanDefinitionMap.put(beanName, beanDefinition);                            &#125;                        &#125; catch (ClassNotFoundException e) &#123;                            e.printStackTrace();                        &#125; catch (InstantiationException e) &#123;                            e.printStackTrace();                        &#125; catch (IllegalAccessException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;        //create bean        for (String beanName : beanDefinitionMap.keySet()) &#123;            BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);            if(beanDefinition.getScope().equals(&quot;singleton&quot;))&#123;                Object bean = createBean(beanName, beanDefinition);                singletonObjects.put(beanName, bean);            &#125;        &#125;    &#125;    private Object createBean(String beanName, BeanDefinition beanDefinition)&#123;        Class clazz = beanDefinition.getType();        try &#123;            Object instance = clazz.getConstructor().newInstance();            // simple dependency injection            for (Field field : clazz.getDeclaredFields()) &#123;                if (field.isAnnotationPresent(Autowired.class)) &#123;                    //change true ,can assign private                    field.setAccessible(true);                    String fieldName = field.getName();                    Object bean = getBean(fieldName);                    field.set(instance, bean);                &#125;            &#125;            //check bean name aware            if (instance instanceof BeanNameAware) &#123;                //force cast to BeanNameAare and call its method                ((BeanNameAware)instance).setBeanName(beanName);            &#125;                        //新增代码，遍历list，执行before init            //before init            for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123;                beanPostProcessor.postProcessBeforeInitialization(instance, beanName);            &#125;            //check initalizing bean            if (instance instanceof InitializingBean) &#123;                //force cast to BeanNameAare and call its method                ((InitializingBean)instance).afterPropertiesSet();            &#125;                        //新增代码，遍历list，执行after init            //after init            for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123;                beanPostProcessor.postProcessAfterInitialization(instance, beanName);            &#125;            return instance;        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    public Object getBean(String beanName)&#123;        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);        if(beanDefinition == null)&#123;            throw new RuntimeException(&quot;class not found with bean name:&quot;+beanName);        &#125;        String scope = beanDefinition.getScope();        if(&quot;singleton&quot;.equals(scope))&#123;            Object bean = singletonObjects.get(beanName);            if(bean == null)&#123;                Object createdBean = createBean(beanName, beanDefinition);                singletonObjects.put(beanName, createdBean);                return createdBean;            &#125;            return bean;        &#125;else&#123;            return createBean(beanName, beanDefinition);        &#125;    &#125;&#125;</code></pre><p>最后，需要在我们的测试类中新增测试代码：</p><pre><code class="java">package com.zhu.service;import com.zhu.spring.BeanPostProcessor;import com.zhu.spring.Component;@Componentpublic class SelfTestBeanPostProcessor implements BeanPostProcessor &#123;    @Override    public void postProcessBeforeInitialization(Object bean, String beanName) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;before init bean processor&quot;);        &#125;    &#125;    @Override    public void postProcessAfterInitialization(Object bean, String beanName) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;after init bean processor&quot;);        &#125;    &#125;&#125;</code></pre><p>执行测试类，我们发现一次执行BeanPostProcessor的beforeinit方法，InitializingBean的afterInit方法，BeanPostProcessor的afterinit方法。</p><blockquote><p>结果如下：</p><p>before init bean processor<br>initializing bean —-afterPropertiesSet<br>after init bean processor<br>com.zhu.service.OrderService@60e53b93|userService</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，已经完成了初始化的过程，十分简单。这次我们将学习BeanPostProcessor，来使我们初始化的过程更加的精细以及灵活。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之InitializingBean初始化Bean</title>
    <link href="https://github/zhuchong6.github.io/2022/12/13/2022-12-08mini-spring6/"/>
    <id>https://github/zhuchong6.github.io/2022/12/13/2022-12-08mini-spring6/</id>
    <published>2022-12-13T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，已经完成了Aware类型的回调机制如何实现的。这次，我们将了解类初始化机制（InitializingBean）如何实现。</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><p>这个机制是为了在新建bean之前能进行一些简单的初始化的工作，实现机制和我们上一篇讲的Aware类接口不能说像，简直就是一毛一样，具体代码如下：</p><pre><code class="java">package com.zhu.spring;//新建一个接口public interface InitializingBean &#123;    void afterPropertiesSet() throws Exception;&#125;</code></pre><pre><code class="java">//check bean name awareif (instance instanceof BeanNameAware) &#123;  //force cast to BeanNameAare and call its method  ((BeanNameAware)instance).setBeanName(beanName);&#125;//check initalizing bean//接口的具体实现，和上面一致if (instance instanceof InitializingBean) &#123;  //force cast to BeanNameAare and call its method  ((InitializingBean)instance).afterPropertiesSet();&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，已经完成了Aware类型的回调机制如何实现的。这次，我们将了解类初始化机制（InitializingBean）如何实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之Aware回调机制</title>
    <link href="https://github/zhuchong6.github.io/2022/12/12/2022-12-08mini-spring5/"/>
    <id>https://github/zhuchong6.github.io/2022/12/12/2022-12-08mini-spring5/</id>
    <published>2022-12-12T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，已经完成了一个复杂的依赖注入功能。这篇文章我们实习Spring中回调的功能，也就是一系列的Aware接口。</p><p>我们开始吧😁！</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><p>我们先回顾下Aware类接口的使用，就拿最简单的一个接口<code>BeanNameAware</code>来说，我们自已定的类比如说上文的UserService类实现它，Spring的上下文会将beanName注入到它的属性中去，这样我们就可以拿到了这个UserService在Spring容器中的名称。</p><p>ok，具体要怎么实现呢？</p><p>首先，我们需要创建一个<code>BeanNameAware</code>接口，具体代码如下：</p><pre><code class="java">package com.zhu.spring;public interface BeanNameAware &#123;    void setBeanName(String beanName);&#125;</code></pre><p>然后在实现它，业务代码如下：</p><pre><code class="java">package com.zhu.service;import com.zhu.spring.Autowired;import com.zhu.spring.BeanNameAware;import com.zhu.spring.Component;import com.zhu.spring.Scope;@Component@Scope(&quot;singleton&quot;)public class UserService implements BeanNameAware &#123;    @Autowired    private OrderService orderService;    private String beanName;    public void test()&#123;        System.out.println(orderService+&quot;|&quot;+beanName);    &#125;    @Override    public void setBeanName(String beanName) &#123;        this.beanName = beanName;    &#125;&#125;</code></pre><p>现在的问题就是如何将值赋予给实现这个接口的累了，这一点很简单。</p><p>我们只需要在创建bean的代码中做一点点🤏小的修改，即可实现，代码如下：</p><pre><code class="java">Object instance = clazz.getConstructor().newInstance();// simple dependency injectionfor (Field field : clazz.getDeclaredFields()) &#123;  if (field.isAnnotationPresent(Autowired.class)) &#123;    //change true ,can assign private    field.setAccessible(true);    String fieldName = field.getName();    Object bean = getBean(fieldName);    field.set(instance, bean);  &#125;&#125;//check bean name aware//判断这个对象有没有实现BeanNameAware接口if (instance instanceof BeanNameAware) &#123;  //实现了，就强制转换成这个接口，然后调用它的setBeanName方法  //force cast to BeanNameAare and call its method  ((BeanNameAware)instance).setBeanName(beanName);&#125;</code></pre><p>完成之后，执行我们的测试代码，发现已经成功注入。在Spring中还有很多这样的Aware接口其实都是以类似这样的方式实现的，咋一看十分神奇，其实实现的原理很简单。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，已经完成了一个复杂的依赖注入功能。这篇文章我们实习Spring中回调的功能，也就是一系列的Aware接口。&lt;/p&gt;
&lt;p&gt;我们开始吧😁！&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之依赖注入</title>
    <link href="https://github/zhuchong6.github.io/2022/12/11/2022-12-08mini-spring4/"/>
    <id>https://github/zhuchong6.github.io/2022/12/11/2022-12-08mini-spring4/</id>
    <published>2022-12-11T03:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，已经实现了简单类的注入功能，这篇文章主要是为了完成复杂类的注入功能。废话少说，我们开始出发。</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><h2 id="补全bean名称生成"><a href="#补全bean名称生成" class="headerlink" title="补全bean名称生成"></a>补全bean名称生成</h2><p>在之前的代码中，bean的名称一直都是取<code>@Component</code>注解中的值，但是这个值可以为空的，我们没有处理这个分支下的情况，这次我们就进行一个补全，具体代码如下:</p><pre><code class="java">Component componentAnnotation = clazz.getAnnotation(Component.class);String beanName = componentAnnotation.value();//只需要在原来的代码中增加一段这样的代码if(&quot;&quot;.equals(beanName))&#123;  //transfer name ,eg: Service-&gt;service SService-&gt;SService, SerR-&gt;serR  //这里是直接取java.beans包下的一个方法，目的是将首字母小写。  beanName = Introspector.decapitalize(clazz.getSimpleName());&#125;</code></pre><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>回到正题，在Spring中依赖注入需要一个注解，用它实例化需要依赖的类。因此，我们也需要创建一个注解，代码如下：</p><pre><code class="java">package com.zhu.spring;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Autowired &#123;&#125;</code></pre><p>准备工作做完了，我们需要思考一下，在哪里去创建这个依赖呢？</p><p>没错，就是在创建bean的时候，我们需要创建这个依赖的bean，也就是在之前的createBean方法中去创建，具体代码如下：</p><pre><code class="java">private Object createBean(String beanName, BeanDefinition beanDefinition)&#123;        Class clazz = beanDefinition.getType();        try &#123;            Object instance = clazz.getConstructor().newInstance();                        // 新增的代码，查找类的所有变量，判断是否有Autowired注解修饰的类            // simple dependency injection            for (Field field : clazz.getDeclaredFields()) &#123;                                                    if (field.isAnnotationPresent(Autowired.class)) &#123;                      //有Autowired修饰的类，即需要注入的类                    //change true ,can assign private                    field.setAccessible(true);                      //获取字段的名称作为类名称                    String fieldName = field.getName();                      //直接调用getBean方法查询之前是否有创建过的bean，没有就新建，具体看一下实现                    Object bean = getBean(fieldName);                      //将bean设置进去                    field.set(instance, bean);                &#125;            &#125;            return instance;        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;</code></pre><p>我们可以做个测试，先创建一个OrderService类，然后在UserService中注入它，并打印结果，具体如下：</p><pre><code class="java">@Component@Scope(&quot;singleton&quot;)public class OrderService &#123;&#125;@Component@Scope(&quot;singleton&quot;)public class UserService &#123;    @Autowired    private OrderService orderService;    public void test()&#123;        System.out.println(orderService);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        MiniSpringApplicationContext miniSpringApplicationContext = new MiniSpringApplicationContext(AppConfig.class);        UserService userService = (UserService)miniSpringApplicationContext.getBean(&quot;userService&quot;);        userService.test();    &#125;&#125;//打印结果：//com.zhu.service.OrderService@610455d6</code></pre><p>自此，我们解决了我们依赖注入的问题，可以在代码中写更加复杂的bean了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，已经实现了简单类的注入功能，这篇文章主要是为了完成复杂类的注入功能。废话少说，我们开始出发。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之创建Bean</title>
    <link href="https://github/zhuchong6.github.io/2022/12/09/2022-12-08mini-spring3/"/>
    <id>https://github/zhuchong6.github.io/2022/12/09/2022-12-08mini-spring3/</id>
    <published>2022-12-09T17:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，完成了BeanDefinition的创建，这个类中保存了我们需要实例化bean的信息，这篇文章就是模拟一个创建bean的底层实现，让我们的mini-spring有一个完整的注入功能。</p><p>ok，我们开始吧！😁</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><h1 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h1><p>目前为止，我们已经完成从<code>@ComponentScan</code>注解定义的value中取到扫描包的位置，然后根据这个位置取出所有包含<code>@Component</code>注解的类，并将其信息存储到<code>BeanDefinition</code>中去。</p><p>接下来，我们要做的就非常简单了，那就是创建bean。我们需要在<strong>MiniSpringApplicationContext</strong>生产BeanDefinition之后直接创建bean，然后保存以供后续使用，具体代码如下：</p><pre><code class="java">package com.zhu.spring;import java.io.File;import java.lang.reflect.InvocationTargetException;import java.net.URL;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class MiniSpringApplicationContext &#123;    private Class configClass;    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;();    private Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();    public MiniSpringApplicationContext(Class configClass) &#123;        this.configClass = configClass;        //scan the class decorate by @ComponentScan        if(configClass.isAnnotationPresent(ComponentScan.class))&#123;            ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);            //scan path, eg: com.zhu.service            String path = componentScanAnnotation.value();            //  com.zhu.service  ----&gt; com/zhu/service            path = path.replace(&quot;.&quot;, &quot;/&quot;);            //find absolute path from MiniSpringApplicationContext context            ClassLoader classLoader = MiniSpringApplicationContext.class.getClassLoader();            // get url , /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service            URL resource = classLoader.getResource(path);            File file = new File(resource.getFile());            if(file.isDirectory())&#123;                File[] files = file.listFiles();                for (File f : files) &#123;                    String absolutePath = f.getAbsolutePath();                    if(absolutePath.endsWith(&quot;.class&quot;))&#123;                        //real load class                            // /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service/UserService ---&gt; com.zhu.service.UserService                            //com/zhu/service/UserService                            String className = absolutePath.substring(absolutePath.indexOf(&quot;com&quot;), absolutePath.indexOf(&quot;.class&quot;));                            //com.zhu.service.UserService                            className = className.replace(&quot;/&quot;, &quot;.&quot;);                        try &#123;                            Class&lt;?&gt; clazz = classLoader.loadClass(className);                            if(clazz.isAnnotationPresent(Component.class))&#123;                                Component componentAnnotation = clazz.getAnnotation(Component.class);                                String beanName = componentAnnotation.value();                                //generate BeanDefinition                                BeanDefinition beanDefinition = new BeanDefinition();                                beanDefinition.setType(clazz);                                if (clazz.isAnnotationPresent(Scope.class)) &#123;                                    Scope scopeAnnotation = clazz.getAnnotation(Scope.class);                                    beanDefinition.setScope(scopeAnnotation.value());                                &#125;else&#123;                                    beanDefinition.setScope(&quot;singleton&quot;);                                &#125;                                beanDefinitionMap.put(beanName, beanDefinition);                            &#125;                        &#125; catch (ClassNotFoundException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;        //create bean  生成beandefinition之后，完成bean的初始化        for (String beanName : beanDefinitionMap.keySet()) &#123;            BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);            if(beanDefinition.getScope().equals(&quot;singleton&quot;))&#123;                  //单例的时候创建，然后放到单例池，即一个map中去                Object bean = createBean(beanName, beanDefinition);                singletonObjects.put(beanName, bean);            &#125;        &#125;    &#125;      //具体初始化的代码，很简单利用Java的反射机制    private Object createBean(String beanName, BeanDefinition beanDefinition)&#123;        Class clazz = beanDefinition.getType();        Object o = null;        try &#123;            o = clazz.getConstructor().newInstance();        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125;        return o;    &#125;    public Object getBean(String beanName)&#123;                //从beandefinitionMap中获取对应类的信息        BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);        if(beanDefinition == null)&#123;            throw new RuntimeException(&quot;class not found with bean name:&quot;+beanName);        &#125;        String scope = beanDefinition.getScope();        if(&quot;singleton&quot;.equals(scope))&#123;              //单例的话先判断单例池中有没有，没有的话需要创建，有的话直接返回            Object bean = singletonObjects.get(beanName);            if(bean == null)&#123;                Object createdBean = createBean(beanName, beanDefinition);                singletonObjects.put(beanName, createdBean);                return createdBean;            &#125;            return bean;        &#125;else&#123;              //多例的话每次直接创建            return createBean(beanName, beanDefinition);        &#125;    &#125;&#125;</code></pre><p>自此，我们基本模拟完成了spring创建bean的一个过程，简单实现了一个单例或者多例的功能。</p><p>ok，我们可以验证一下，修改<code>UserService</code>里面<code>@Scope</code>注解的值，查看生产的对象的地址是不是一致，即可验证单例功能是否生效，具体代码如下：</p><pre><code class="java">@Component(&quot;userService&quot;)@Scope(&quot;prototype&quot;)public class UserService &#123;&#125;package com.zhu.service;import com.zhu.spring.MiniSpringApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        MiniSpringApplicationContext miniSpringApplicationContext = new MiniSpringApplicationContext(AppConfig.class);                //经过测试发现地址都不一样，符合多例的初衷。        System.out.println(miniSpringApplicationContext.getBean(&quot;userService&quot;));        System.out.println(miniSpringApplicationContext.getBean(&quot;userService&quot;));        System.out.println(miniSpringApplicationContext.getBean(&quot;userService&quot;));        System.out.println(miniSpringApplicationContext.getBean(&quot;userService&quot;));        System.out.println(miniSpringApplicationContext.getBean(&quot;userService&quot;));    &#125;&#125;</code></pre><p>总结：</p><p>目前为止，我们实现了简单类（就只有一个类，不依赖其他类）的注入。但是，这在我们实际生产中很少有这种简单的bean，一般都是需要依赖其他的bean。所以，我们下一步的目标就是完成依赖注入的流程。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，完成了BeanDefinition的创建，这个类中保存了我们需要实例化bean的信息，这篇文章就是模拟一个创建bean的底层实现，让我们的mini-spring有一个完整的注入功能。&lt;/p&gt;
&lt;p&gt;ok，我们开始吧！😁&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之BeanDefinition生成</title>
    <link href="https://github/zhuchong6.github.io/2022/12/08/2022-12-08mini-spring2%20/"/>
    <id>https://github/zhuchong6.github.io/2022/12/08/2022-12-08mini-spring2%20/</id>
    <published>2022-12-08T17:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>我们上一篇文章中，已经完成了如何通过配置指定的包路径扫描下面的所有的文件，并将<code>@Component</code>注解标注的类找出来，下一步其实就是实例化这个bean。但是，在Spring却没有直接这么做，而是通过BeanDefinition实现的，至于为什么，容我先卖个关子。</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>首先我们创建一个注解，<code>@scope</code>用于标识bean是否是单例，代码如下:</p><pre><code class="java">@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Scope &#123;    /**     * define bean is singleton or prototype     * @return     */    String value() default &quot;&quot;;&#125;</code></pre><p>我们自定义一个BeanDefinition类，用于表示我们要注入的类的结构，我们简单一些，只定义两个属性，具体如下:</p><pre><code class="java">package com.zhu.spring;public class BeanDefinition &#123;    //类    private Class type;        //单例还是多例，singleton单例，prototype多例    private String scope;    public Class getType() &#123;        return type;    &#125;    public void setType(Class type) &#123;        this.type = type;    &#125;    public String getScope() &#123;        return scope;    &#125;    public void setScope(String scope) &#123;        this.scope = scope;    &#125;&#125;</code></pre><p>同时修改MiniSpringApplicationContext代码，用于创建BeanDefinition，具体如下：</p><pre><code class="java">package com.zhu.spring;import java.io.File;import java.net.URL;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class MiniSpringApplicationContext &#123;    private Class configClass;      //新增，用于存放生产的BeanDefinition类对象    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;();    public MiniSpringApplicationContext(Class configClass) &#123;        this.configClass = configClass;        //scan the class decorate by @ComponentScan        if(configClass.isAnnotationPresent(ComponentScan.class))&#123;            ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);            //scan path, eg: com.zhu.service            String path = componentScanAnnotation.value();            //  com.zhu.service  ----&gt; com/zhu/service            path = path.replace(&quot;.&quot;, &quot;/&quot;);            //find absolute path from MiniSpringApplicationContext context            ClassLoader classLoader = MiniSpringApplicationContext.class.getClassLoader();            // get url , /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service            URL resource = classLoader.getResource(path);            File file = new File(resource.getFile());            System.out.println(file);            if(file.isDirectory())&#123;                File[] files = file.listFiles();                for (File f : files) &#123;                    String absolutePath = f.getAbsolutePath();                    System.out.println(absolutePath);                    if(absolutePath.endsWith(&quot;.class&quot;))&#123;                        //real load class                            // /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service/UserService ---&gt; com.zhu.service.UserService                            //com/zhu/service/UserService                            String className = absolutePath.substring(absolutePath.indexOf(&quot;com&quot;), absolutePath.indexOf(&quot;.class&quot;));                            //com.zhu.service.UserService                            className = className.replace(&quot;/&quot;, &quot;.&quot;);                            System.out.println(className);                        try &#123;                            Class&lt;?&gt; clazz = classLoader.loadClass(className);                            if(clazz.isAnnotationPresent(Component.class))&#123;                                                                //这是新增的代码                                Component componentAnnotation = clazz.getAnnotation(Component.class);                                  //通过注解取出bean的名称                                String beanName = componentAnnotation.value();                                //generate BeanDefinition                                BeanDefinition beanDefinition = new BeanDefinition();                                beanDefinition.setType(clazz);                                if (clazz.isAnnotationPresent(Scope.class)) &#123;                                      //有scope注解，取出scope定义的范围                                    Scope scopeAnnotation = clazz.getAnnotation(Scope.class);                                    beanDefinition.setScope(scopeAnnotation.value());                                &#125;else&#123;                                      //没有scope注解，默认单例                                    beanDefinition.setScope(&quot;singleton&quot;);                                &#125;                                  //将beanDefinition对象放到我们创建的好的map容器中去                                beanDefinitionMap.put(beanName, beanDefinition);                            &#125;                        &#125; catch (ClassNotFoundException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    public Object getBean(String beanName)&#123;        return null;    &#125;&#125;</code></pre><p>至此，我们完成本次的目的。创建BeanDefinition用于保存我们需要创建的bean对象，其中还包含bean的类型、作用域等（其实，实际还有许多其他属性，我们这里只是简写）。</p><p>那么，为什么要绕一下不直接创建bean对象呢？</p><p>其实，在我看来Spring作为一个大而全的框架需要考虑很多东西，如果在这里直接实例化的话，那么其后一些操作比如说延迟初始化，bena依赖信息的处理等需要自定义的操作就不好实现了。而加上这个类，我们就可以将一些自定义的操作放到其中，在需要实例化的时候可以统一处理，比较简单明了。</p><p>这样说的有些牵强，没关系，等我们这个系列完结，就能明白为什么要这么设计了。</p><p>最后，我们看一眼我们的代码结构作为结束。</p><p><img src="/images/mini-spring02.png" alt="mini-spring2"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;我们上一篇文章中，已经完成了如何通过配置指定的包路径扫描下面的所有的文件，并将&lt;code&gt;@Component&lt;/code&gt;注解标注的类找出来，下一步其实就是实例化这个bean。但是，在Spring却没有直接这么做，而是通过BeanDefinition实现的，至于为什么，容我先卖个关子。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mini-Spring之扫描组件类</title>
    <link href="https://github/zhuchong6.github.io/2022/12/07/2022-12-08mini-spring1/"/>
    <id>https://github/zhuchong6.github.io/2022/12/07/2022-12-08mini-spring1/</id>
    <published>2022-12-07T17:35:00.000Z</published>
    <updated>2023-08-07T00:18:37.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Java开发中，Spring是其重要的组成部分，以至于大家都调侃Java程序猿&#x3D;&#x3D;Spring程序员。Spring其重要性，不言而喻。但是，Spring框架及其复杂，以至于阅读源码的过程让人头脑发昏。笔者就曾试过阅读其源码，但是其复杂的调用栈让我直接CPU过载。</p><p>于是，此系列文章应运而生，使用简单的方式来手写一个Spring框架，让大家更加容易的阅读源码。</p><span id="more"></span><blockquote><p>本文所有的代码都在这个项目工程里，大家需要的时候可以随时取用。<a href="https://github.com/zhuchong6/mini-spring">传送门</a></p></blockquote><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>如图，我们创建一个Java项目，并创建两个包，一个用于写框架代码，一个用于写测试代码：</p><p><img src="/images/mini-spring01.png" alt="/images/mini-spring01"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我们知道，Spring加载bean的方式有两种，一种是xml的方式，另一种是annotation的方式，本项目选择第二种方式。</p><p>ok，我们正式开始。</p><ol><li><p>创建两个注解<code>@Component</code>和<code>@ComponentScan</code>,这两个注解作用：<code>@Component</code>标记是一个组件类,<code>@ComponentScan</code>表示开启类自动扫描。</p><pre><code class="java">package com.zhu.spring;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Component &#123;    //表示组件名称    String value() default &quot;&quot;;&#125;package com.zhu.spring;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ComponentScan &#123;    //表示要扫描的路径,eg:com.zhu.service    String value() default &quot;&quot;;&#125;</code></pre></li><li><p>我们需要模仿spring的applicationContext创建一个我们自己的context类，我称之为：<code>MiniSpringApplicationContext</code>,这个类的主要目的就是为了加载Bean，以及获取Bean，具体可以看下面代码：</p><pre><code class="java">package com.zhu.spring;import java.io.File;import java.net.URL;public class MiniSpringApplicationContext &#123;    private Class configClass;    public MiniSpringApplicationContext(Class configClass) &#123;        this.configClass = configClass;        //扫描所有被ComponentScan注解修饰的类        if(configClass.isAnnotationPresent(ComponentScan.class))&#123;            ComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);            //获取ComponentScan注解里面设置的路径scan path, eg: com.zhu.service            String path = componentScanAnnotation.value();              //将包名转换成文件路径            //  com.zhu.service  ----&gt; com/zhu/service            path = path.replace(&quot;.&quot;, &quot;/&quot;);            //find absolute path from MiniSpringApplicationContext context              //找到MiniSpringApplicationContext类加载器，因为我们要找的class文件在类路径下，所以需要从已经加载好的类中找类路径            ClassLoader classLoader = MiniSpringApplicationContext.class.getClassLoader();              // 获取到类路径的绝对路径，我这里是mac下面的路径，window下面分隔符有可能不一样            // get url , /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service            URL resource = classLoader.getResource(path);            File file = new File(resource.getFile());            System.out.println(file);            if(file.isDirectory())&#123;                  //找到这个绝对路径下所有的文件                File[] files = file.listFiles();                for (File f : files) &#123;                    //找到没一个文件的绝对路径，后面需要                    String absolutePath = f.getAbsolutePath();                    System.out.println(absolutePath);                      //判断是否属于.class文件                    if(absolutePath.endsWith(&quot;.class&quot;))&#123;                        //real load class                            // /Users/knight/IdeaProjects/mini-spring/out/production/mini-spring/com/zhu/service/UserService ---&gt; com.zhu.service.UserService                            //com/zhu/service/UserService                            String className = absolutePath.substring(absolutePath.indexOf(&quot;com&quot;), absolutePath.indexOf(&quot;.class&quot;));                            //com.zhu.service.UserService                            className = className.replace(&quot;/&quot;, &quot;.&quot;);                            System.out.println(className);                                  //上面的步骤，主要是为了找到要加载类的类路径，方便后面使用                        try &#123;                              //通过类加载器加载，需要传入类路径，eg:com.zhu.service.UserService这样的                            Class&lt;?&gt; aClass = classLoader.loadClass(className);                            if(aClass.isAnnotationPresent(Component.class))&#123;                                //找到标注了Component注解的类，也就是我们需要的bean                                System.out.println(&quot;bean is   &quot; + aClass.getName());                            &#125;                        &#125; catch (ClassNotFoundException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    public Object getBean(String beanName)&#123;        return null;    &#125;&#125;</code></pre><p>目前为止，我们实现了加载我们的Bean的代码，让我们测试一下。</p></li><li><p>在我们的service包下，创建如下代码，来进行一个验证：</p><pre><code class="java">package com.zhu.service;import com.zhu.spring.ComponentScan;//这里表示需要扫描的包路径@ComponentScan(&quot;com.zhu.service&quot;)public class AppConfig &#123;&#125;//分割线package com.zhu.service;import com.zhu.spring.Component;//这里表示Bean的名称@Component(&quot;userService&quot;)public class UserService &#123;&#125;//分割线package com.zhu.service;import com.zhu.spring.MiniSpringApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        MiniSpringApplicationContext miniSpringApplicationContext = new MiniSpringApplicationContext(AppConfig.class);        //test        UserService userService = (UserService) miniSpringApplicationContext.getBean(&quot;userService&quot;);    &#125;&#125;</code></pre><p>执行之后，我们可以看出确实通过AppConfig类，找到了我们需要扫描的包<code>com.zhu.servive</code>，然后在这个包下我们发现了用<code>Component</code>注解标识的<code>UserService</code>类，然后将这个类作为我们的bean。</p></li></ol><p>ok，到这里我们的第一步就简单实现了。回顾一下，我们自定义了两个注解<code>@Component</code>和<code>@ComponenetScan</code>,并在我们自己定以ApplicationContext中实现了他们的作用，即通过<code>@ComponentScan</code>中定义的包路径<code>xxx.xxx.xxx</code>，去寻找在这个路径下所有标记<code>@Component</code>的类，并将其加载，作为我们的bean。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在Java开发中，Spring是其重要的组成部分，以至于大家都调侃Java程序猿&amp;#x3D;&amp;#x3D;Spring程序员。Spring其重要性，不言而喻。但是，Spring框架及其复杂，以至于阅读源码的过程让人头脑发昏。笔者就曾试过阅读其源码，但是其复杂的调用栈让我直接CPU过载。&lt;/p&gt;
&lt;p&gt;于是，此系列文章应运而生，使用简单的方式来手写一个Spring框架，让大家更加容易的阅读源码。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
