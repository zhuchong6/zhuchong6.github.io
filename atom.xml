<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zeus的小窝QAQ</title>
  
  
  <link href="https://github/zhuchong6.github.io/atom.xml" rel="self"/>
  
  <link href="https://github/zhuchong6.github.io/"/>
  <updated>2022-09-29T01:04:32.300Z</updated>
  <id>https://github/zhuchong6.github.io/</id>
  
  <author>
    <name>zhuchong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python学习</title>
    <link href="https://github/zhuchong6.github.io/2022/09/28/2022-09-28python%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github/zhuchong6.github.io/2022/09/28/2022-09-28python%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-09-28T09:23:02.000Z</published>
    <updated>2022-09-29T01:04:32.300Z</updated>
    
    <content type="html"><![CDATA[<p>为什么学习Python？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为什么学习Python？&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Python" scheme="https://github/zhuchong6.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://github/zhuchong6.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>spring-security授权</title>
    <link href="https://github/zhuchong6.github.io/2022/03/03/2022-03-03spring-security%E6%8E%88%E6%9D%83/"/>
    <id>https://github/zhuchong6.github.io/2022/03/03/2022-03-03spring-security%E6%8E%88%E6%9D%83/</id>
    <published>2022-03-03T15:07:11.000Z</published>
    <updated>2022-09-29T01:04:32.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>之前我们学习了spring-security的认证过程，具体可以看这里<a href="https://zhuchong6.github.io/2022/02/18/2022-02-18spring-security/#more">这里</a></p><p>这次，我们来学习下security的授权过程。</p><span id="more"></span><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>和之前一样，我们先回忆下security的过滤器，因为security的认证授权都是基于过滤器机制的,<a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-security-filters">security所有拦截器</a>。</p><p>其中比较关键的一个拦截器<code>FilterSecurityInterceptor</code>,是作为控制用户授权的核心过滤器。具体流程图请看下图：</p><p><img src="/filtersecurityinterceptor.png" alt="鉴权流程"></p><ol><li><code>FilterSecurityInterceptor</code>从<code>SecurityContextHolder</code>中获取<code>Authentication</code>对象</li><li>根据<code>HttpServletRequest</code>，<code>HttpServletRequest</code>和<code>FilterChain</code>来创建一个<code>FilterInvocation</code>对象</li><li>接下来吧<code>FilterInvocation</code>作为参数，从<code>SecurityMetadataSource</code>中获取<code>ConfigAttribute</code>对象</li><li>最后，它将<code>Authentication</code>、<code>FilterInvocation</code>和<code>ConfigAttribute</code>传递给<code>AccessDecisionManager</code></li></ol><p>具体可以参考源码：</p><pre><code class="java">protected InterceptorStatusToken beforeInvocation(Object object) &#123;        Assert.notNull(object, &quot;Object was null&quot;);        if (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;            throw new IllegalArgumentException(&quot;Security invocation attempted for object &quot; + object.getClass().getName()                    + &quot; but AbstractSecurityInterceptor only configured to support secure objects of type: &quot;                    + getSecureObjectClass());        &#125;  //这个Object对象其实就是传入的FilterInvocation        Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object);        if (CollectionUtils.isEmpty(attributes)) &#123;            Assert.isTrue(!this.rejectPublicInvocations,                    () -&gt; &quot;Secure object invocation &quot; + object                            + &quot; was denied as public invocations are not allowed via this interceptor. &quot;                            + &quot;This indicates a configuration error because the &quot;                            + &quot;rejectPublicInvocations property is set to &#39;true&#39;&quot;);            if (this.logger.isDebugEnabled()) &#123;                this.logger.debug(LogMessage.format(&quot;Authorized public object %s&quot;, object));            &#125;            publishEvent(new PublicInvocationEvent(object));            return null; // no further work post-invocation        &#125;        if (SecurityContextHolder.getContext().getAuthentication() == null) &#123;            credentialsNotFound(this.messages.getMessage(&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;,                    &quot;An Authentication object was not found in the SecurityContext&quot;), object, attributes);        &#125;        Authentication authenticated = authenticateIfRequired();        if (this.logger.isTraceEnabled()) &#123;            this.logger.trace(LogMessage.format(&quot;Authorizing %s with attributes %s&quot;, object, attributes));        &#125;        // 这一步就是认证的流程        attemptAuthorization(object, attributes, authenticated);        if (this.logger.isDebugEnabled()) &#123;            this.logger.debug(LogMessage.format(&quot;Authorized %s with attributes %s&quot;, object, attributes));        &#125;        if (this.publishAuthorizationSuccess) &#123;            publishEvent(new AuthorizedEvent(object, attributes, authenticated));        &#125;        // Attempt to run as a different user        Authentication runAs = this.runAsManager.buildRunAs(authenticated, object, attributes);        if (runAs != null) &#123;            SecurityContext origCtx = SecurityContextHolder.getContext();            SecurityContext newCtx = SecurityContextHolder.createEmptyContext();            newCtx.setAuthentication(runAs);            SecurityContextHolder.setContext(newCtx);            if (this.logger.isDebugEnabled()) &#123;                this.logger.debug(LogMessage.format(&quot;Switched to RunAs authentication %s&quot;, runAs));            &#125;            // need to revert to token.Authenticated post-invocation            return new InterceptorStatusToken(origCtx, true, attributes, object);        &#125;        this.logger.trace(&quot;Did not switch RunAs authentication since RunAsManager returned null&quot;);        // no further work post-invocation        return new InterceptorStatusToken(SecurityContextHolder.getContext(), false, attributes, object);    &#125;</code></pre><pre><code class="java">//认证流程代码    private void attemptAuthorization(Object object, Collection&lt;ConfigAttribute&gt; attributes,            Authentication authenticated) &#123;        try &#123;      //决策管理器，进行决策      //默认策略AffirmativeBased----只要有一个成功就认证成功      //ConsensusBased----成功大于失败才认证成功      //UnanimousBased----所有都成功才认证成功            this.accessDecisionManager.decide(authenticated, object, attributes);        &#125;        catch (AccessDeniedException ex) &#123;            if (this.logger.isTraceEnabled()) &#123;                this.logger.trace(LogMessage.format(&quot;Failed to authorize %s with attributes %s using %s&quot;, object,                        attributes, this.accessDecisionManager));            &#125;            else if (this.logger.isDebugEnabled()) &#123;                this.logger.debug(LogMessage.format(&quot;Failed to authorize %s with attributes %s&quot;, object, attributes));            &#125;            publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, ex));            throw ex;        &#125;    &#125;</code></pre><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="FilterSecurityInterceptor授权过程"><a href="#FilterSecurityInterceptor授权过程" class="headerlink" title="FilterSecurityInterceptor授权过程"></a>FilterSecurityInterceptor授权过程</h2><p>经过上述的分析，我们基本明白security授权的一般流程。那么，我们可以实战感受下。</p><p>需求：从数据库动态读取权限信息，然后进行认证。</p><p>由上面的授权原理流程图，我们可以看出<code>SecurityMetadataSource</code>中获取的<code>ConfigAttribute</code>存储的就是与计算机安全相关的属性，换句话说就是我们需要的权限信息，所以需要重写<code>SecurityMetadataSource</code>类：</p><pre><code class="java">/** * @author by zhuhcong * @descr sms自定义的权限数据源 * @date 2022/3/7 18:14 */@Slf4j@Componentpublic class SmsRoleSecurityMetadataSource implements FilterInvocationSecurityMetadataSource &#123;    private final AntPathMatcher antPathMatcher = new AntPathMatcher();    /**     * 假设从数据库中加载     */    private final Map&lt;String,String&gt; urlRoleMap = new HashMap&lt;String,String&gt;()&#123;&#123;        put("/open/**","ROLE_ANONYMOUS");        put("/health","ROLE_ANONYMOUS");        put("/restart","ROLE_ADMIN");        put("/demo","ROLE_USER");        put("/index", "ROLE_USER");    &#125;&#125;;        @Override    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException &#123;        //根据 请求获取 需要的权限        FilterInvocation filterInvocation = (FilterInvocation) object;        String url = filterInvocation.getRequestUrl();        log.info(&quot;【请求 url : &#123;&#125;】&quot;, url);        for (Map.Entry&lt;String, String&gt; entry : urlRoleMap.entrySet()) &#123;            if (antPathMatcher.match(entry.getKey(), url)) &#123;                return SecurityConfig.createList(entry.getValue());            &#125;        &#125;        return null;    &#125;    /**     * 全部权限返回admin角色     * @return     */    @Override    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() &#123;        return SecurityConfig.createList(&quot;ADMIN&quot;);    &#125;    @Override    public boolean supports(Class&lt;?&gt; clazz) &#123;        return true;    &#125;&#125;</code></pre><p>然后，我们可以看到访问决策管理器，决定是否能授权。这里，其实可以使用内置的几个类，但是我们这里自己实现一个加深下理解。</p><pre><code class="java">//自定义策略，如果url匹配就放行，不匹配就不放行/** * @author by zhuhcong * @descr 访问决策投票,参考系统默认实现类RoleVoter * @date 2022/3/7 20:29 */public class SmsRoleBasedVoter implements AccessDecisionVoter&lt;Object&gt; &#123;    @Override    public boolean supports(ConfigAttribute attribute) &#123;        return true;    &#125;    @Override    public boolean supports(Class&lt;?&gt; clazz) &#123;        return true;    &#125;    @Override    public int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attributes) &#123;        if(authentication == null)&#123;            return ACCESS_DENIED;        &#125;        Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();        for (ConfigAttribute attribute : attributes) &#123;            if(attribute.getAttribute() == null)&#123;                continue;            &#125;            if (this.supports(attribute)) &#123;                for (GrantedAuthority authority : authorities) &#123;                    if(attribute.getAttribute().equals(authority.getAuthority()))&#123;                        return ACCESS_GRANTED;                    &#125;                &#125;            &#125;        &#125;        return ACCESS_DENIED;    &#125;&#125;</code></pre><p>自此，我们完成自定义部分。但是，还没有完，我们需要将这些自定义部分加入到配置中去，这样才能生效。</p><pre><code class="java">/** * 管家部分在 ++++标记的位置 * @author zhuchong */@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    private MyAuthenticationProvider myAuthenticationProvider;    @Autowired    private SmsAuthenticationProvider smsAuthenticationProvider;    @Autowired    private SmsRoleSecurityMetadataSource smsRoleSecurityMetadataSource;    @Bean    public BCryptPasswordEncoder bCryptPasswordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;    @Bean    public SmsLoginAuthenticationFilter smsLoginAuthenticationFilter() throws Exception&#123;        SmsLoginAuthenticationFilter filter = new SmsLoginAuthenticationFilter();        //对这个filter设置AuthenticationManager，取默认的ProviderManager        filter.setAuthenticationManager(authenticationManagerBean());        //设置成功的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;            //登录成功时返回给前端的数据            Map result = new HashMap();            result.put(&quot;success&quot;, &quot;sms登录成功&quot;);            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        //设置失败的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;            Map result = new HashMap();            if (exception instanceof UsernameNotFoundException) &#123;                result.put(&quot;fail&quot;, exception.getMessage());            &#125; else if (exception instanceof BadCredentialsException) &#123;                result.put(&quot;fail&quot;, &quot;sms密码错误&quot; + exception.getMessage());            &#125; else &#123;                result.put(&quot;fail&quot;, &quot;sms其他异常&quot;);            &#125;            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        return filter;    &#125;    @Bean    public MyLoginAuthenticationFilter myLoginAuthenticationFilter() throws Exception &#123;        MyLoginAuthenticationFilter filter = new MyLoginAuthenticationFilter();        //对这个filter设置AuthenticationManager，取默认的        filter.setAuthenticationManager(authenticationManagerBean());        //设置成功的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;            //登录成功时返回给前端的数据            Map result = new HashMap();            result.put(&quot;success&quot;, &quot;登录成功&quot;);            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        //设置失败的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;            Map result = new HashMap();            if (exception instanceof UsernameNotFoundException) &#123;                result.put(&quot;fail&quot;, exception.getMessage());            &#125; else if (exception instanceof BadCredentialsException) &#123;                result.put(&quot;fail&quot;, &quot;密码错误&quot; + exception.getMessage());            &#125; else &#123;                result.put(&quot;fail&quot;, &quot;其他异常&quot;);            &#125;            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        return filter;    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        //关闭跨域和csrf防护        http.cors().and().csrf().disable();        //对请求url进行防护        http//                .authorizeRequests()//                .antMatchers(&quot;/index&quot;).hasRole(&quot;USER&quot;)//                .antMatchers(&quot;hello&quot;).hasRole(&quot;admin&quot;)//                .and()                .authorizeRequests()                //放行这些路径                .antMatchers(&quot;/smsLogin&quot;,&quot;/verityCode&quot;,&quot;/login&quot;)                .permitAll()                .and()                .authorizeRequests()                .anyRequest().authenticated()                //修改accessManager  ++++                .accessDecisionManager(customizeAccessDecisionManager())                //放入自定义的权限拦截器 ++++                .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;                    @Override                    public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) &#123;                        object.setSecurityMetadataSource(smsRoleSecurityMetadataSource);                        return object;                    &#125;                &#125;)                .and()                .formLogin()                .permitAll()                .and()                .logout()                .permitAll()                .logoutSuccessHandler((request, response, authentication) -&gt; &#123;                    //登出成功时返回给前端的数据                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;注销成功&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .deleteCookies(&quot;JSESSIONID&quot;)                .and()                .exceptionHandling()                .accessDeniedHandler((request, response, exception) -&gt; &#123;                    //访问拒绝时返回给前端的数据                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;无权访问，need Authorities!!&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .authenticationEntryPoint((request, response, exception) -&gt; &#123;                    //访问有权限url时进行拦截                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;需要登录!!&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .and()                .sessionManagement()                .maximumSessions(1)     //最多只能一个用户登录一个账号                .expiredSessionStrategy(event -&gt; &#123;                    //session策略的返回                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;您的账号在异地登录，建议修改密码!!&quot;);                    HttpServletResponse response = event.getResponse();                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;);        //把filter添加到UsernamePasswordAuthenticationFilter这个过滤器位置        http.addFilterAt(myLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)                .addFilterAfter(smsLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);        //把自定义的AuthenticationProvider设置进去        http.authenticationProvider(myAuthenticationProvider)                .authenticationProvider(smsAuthenticationProvider);    &#125;      //++++    private AccessDecisionManager customizeAccessDecisionManager() &#123;        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoterList                = Arrays.asList(                new SmsRoleBasedVoter()        );        return new AffirmativeBased(decisionVoterList);    &#125;&#125;</code></pre><p>全部完成之后，就可以启动程序进行验证，具体验证流程可以参考<a href="https://zhuchong6.github.io/2022/02/18/2022-02-18spring-security/#more">认证篇</a>。</p><h2 id="AuthorizationFilter授权过程-Spring推荐"><a href="#AuthorizationFilter授权过程-Spring推荐" class="headerlink" title="AuthorizationFilter授权过程(Spring推荐)"></a>AuthorizationFilter授权过程(Spring推荐)</h2><p>我们可以看出上面的流程有点复杂，spring官方并不推荐这种方式。新的流程更加简洁易用，具体如下</p><p><img src="/authorizationfilter.png" alt="新流程"></p><p>可以看出，关键在于第三部的校验，比之前的简洁很多，具体源码可以看这里：</p><pre><code class="java">    public AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, HttpServletRequest request) &#123;        if (this.logger.isTraceEnabled()) &#123;            this.logger.trace(LogMessage.format(&quot;Authorizing %s&quot;, request));        &#125;    //遍历需要授权的的url，我们配置放行的url也回出现在这个map中        for (Map.Entry&lt;RequestMatcher, AuthorizationManager&lt;RequestAuthorizationContext&gt;&gt; mapping : this.mappings                .entrySet()) &#123;            RequestMatcher matcher = mapping.getKey();            MatchResult matchResult = matcher.matcher(request);            if (matchResult.isMatch()) &#123;                AuthorizationManager&lt;RequestAuthorizationContext&gt; manager = mapping.getValue();                if (this.logger.isTraceEnabled()) &#123;                    this.logger.trace(LogMessage.format(&quot;Checking authorization on %s using %s&quot;, request, manager));                &#125;        //如果，不是白名单中的url，AuthorizationManager进行一个处理        //默认的实现类是AuthenticatedAuthorizationManager，它是只要认证通过就会放行，默认显然不满足我们的需求        //显而易见，我们需要自定义的地方就在这                return manager.check(authentication,                        new RequestAuthorizationContext(request, matchResult.getVariables()));            &#125;        &#125;        this.logger.trace(&quot;Abstaining since did not find matching RequestMatcher&quot;);        return null;    &#125;</code></pre><p>其实，逻辑很简单，只需要跟着断点走一遍，即可。</p><p>下面来进行一个实战，代码如下：</p><pre><code class="java">@Componentpublic final class SmsAuthorizationFilterManager implements AuthorizationManager&lt;RequestAuthorizationContext&gt; &#123;    private final AntPathMatcher antPathMatcher = new AntPathMatcher();    /**     * 假设从数据库中加载     */    private final Map&lt;String,String&gt; urlRoleMap = new HashMap&lt;String,String&gt;()&#123;&#123;        put("/open/**","ROLE_ANONYMOUS");        put("/health","ROLE_ANONYMOUS");        put("/restart","ROLE_ADMIN");        put("/demo","ROLE_USER");        put("/index", "ROLE_USER");    &#125;&#125;;    @Override    public AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, RequestAuthorizationContext object) &#123;        HttpServletRequest request = object.getRequest();                //空信息直接返回授权失败        if(authentication.get() == null)&#123;            return new AuthorizationDecision(false);        &#125;        Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.get().getAuthorities();                //没有角色信息直接回回授权失败        if(authorities==null || authorities.size()==0)&#123;            return new AuthorizationDecision(false);        &#125;                //这一步就是每次比对，看有没有url匹配，如果有返回授权成功，否者失败        for(GrantedAuthority grantedAuthority : authorities)&#123;            String authority = grantedAuthority.getAuthority();            String role = urlRoleMap.get(request.getRequestURI());            boolean match = antPathMatcher.match(authority, role);            if(match)&#123;                return new AuthorizationDecision(true);            &#125;        &#125;        return new AuthorizationDecision(false);    &#125;        @Override    public void verify(Supplier&lt;Authentication&gt; authentication, RequestAuthorizationContext object) &#123;        AuthorizationManager.super.verify(authentication, object);    &#125;    &#125;</code></pre><p>接下来，还是配置类把这个类加载到配置中去。</p><pre><code class="java">@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    private MyAuthenticationProvider myAuthenticationProvider;    @Autowired    private SmsAuthenticationProvider smsAuthenticationProvider;    @Autowired    private SmsRoleSecurityMetadataSource smsRoleSecurityMetadataSource;    @Autowired    private SmsAuthorizationFilterManager smsAuthorizationFilterManager;    @Bean    public BCryptPasswordEncoder bCryptPasswordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;    @Bean    public SmsLoginAuthenticationFilter smsLoginAuthenticationFilter() throws Exception&#123;        SmsLoginAuthenticationFilter filter = new SmsLoginAuthenticationFilter();        //对这个filter设置AuthenticationManager，取默认的ProviderManager        filter.setAuthenticationManager(authenticationManagerBean());        //设置成功的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;            //登录成功时返回给前端的数据            Map result = new HashMap();            result.put(&quot;success&quot;, &quot;sms登录成功&quot;);            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        //设置失败的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;            Map result = new HashMap();            if (exception instanceof UsernameNotFoundException) &#123;                result.put(&quot;fail&quot;, exception.getMessage());            &#125; else if (exception instanceof BadCredentialsException) &#123;                result.put(&quot;fail&quot;, &quot;sms密码错误&quot; + exception.getMessage());            &#125; else &#123;                result.put(&quot;fail&quot;, &quot;sms其他异常&quot;);            &#125;            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        return filter;    &#125;    @Bean    public MyLoginAuthenticationFilter myLoginAuthenticationFilter() throws Exception &#123;        MyLoginAuthenticationFilter filter = new MyLoginAuthenticationFilter();        //对这个filter设置AuthenticationManager，取默认的        filter.setAuthenticationManager(authenticationManagerBean());        //设置成功的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;            //登录成功时返回给前端的数据            Map result = new HashMap();            result.put(&quot;success&quot;, &quot;登录成功&quot;);            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        //设置失败的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;            Map result = new HashMap();            if (exception instanceof UsernameNotFoundException) &#123;                result.put(&quot;fail&quot;, exception.getMessage());            &#125; else if (exception instanceof BadCredentialsException) &#123;                result.put(&quot;fail&quot;, &quot;密码错误&quot; + exception.getMessage());            &#125; else &#123;                result.put(&quot;fail&quot;, &quot;其他异常&quot;);            &#125;            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        return filter;    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        //关闭跨域和csrf防护        http.cors().and().csrf().disable();        //对请求url进行防护        http          //主要这块改动                .authorizeHttpRequests(auth-&gt;auth.mvcMatchers(&quot;/smsLogin&quot;,&quot;/verityCode&quot;,&quot;/login&quot;,&quot;logout&quot;)                        .permitAll()                                       //通过access把我们刚才定义的Manager设置进去                        .anyRequest().access(smsAuthorizationFilterManager)                )//                .authorizeRequests()//                .antMatchers(&quot;/index&quot;).hasRole(&quot;USER&quot;)//                .antMatchers(&quot;hello&quot;).hasRole(&quot;admin&quot;)//                .and()//                .authorizeRequests()//                //放行这些路径//                .antMatchers(&quot;/smsLogin&quot;,&quot;/verityCode&quot;,&quot;/login&quot;)//                .permitAll()//                .and()////                .authorizeRequests()//                .anyRequest().authenticated()//                //修改accessManager//                .accessDecisionManager(customizeAccessDecisionManager())//                //放入自定义的权限拦截器//                .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;////                    @Override//                    public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) &#123;//                        object.setSecurityMetadataSource(smsRoleSecurityMetadataSource);//                        return object;//                    &#125;//                &#125;)////                .and()                .formLogin()                .disable()                .logout()//                .permitAll()                .logoutSuccessHandler((request, response, authentication) -&gt; &#123;                    //登出成功时返回给前端的数据                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;注销成功&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .deleteCookies(&quot;JSESSIONID&quot;)                .and()                .exceptionHandling()                .accessDeniedHandler((request, response, exception) -&gt; &#123;                    //访问拒绝时返回给前端的数据                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;无权访问，need Authorities!!&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .authenticationEntryPoint((request, response, exception) -&gt; &#123;                    //访问有权限url时进行拦截                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;需要登录!!&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .and()                .sessionManagement()                .maximumSessions(1)     //最多只能一个用户登录一个账号                .expiredSessionStrategy(event -&gt; &#123;                    //session策略的返回                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;您的账号在异地登录，建议修改密码!!&quot;);                    HttpServletResponse response = event.getResponse();                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;);        //把filter添加到UsernamePasswordAuthenticationFilter这个过滤器位置        http.addFilterAt(myLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)                .addFilterAfter(smsLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);        //把自定义的AuthenticationProvider设置进去        http.authenticationProvider(myAuthenticationProvider)                .authenticationProvider(smsAuthenticationProvider);    &#125;    private AccessDecisionManager customizeAccessDecisionManager() &#123;        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoterList                = Arrays.asList(                new SmsRoleBasedVoter()        );        return new AffirmativeBased(decisionVoterList);    &#125;&#125;</code></pre><p>完成之后可以，启动项目进行验证。</p><p>至此，security的认证授权流程，及其实现过程已经完结。</p><p>我已将代码上传到github上，有兴趣可以去看下<a href="https://github.com/zhuchong6/spring-all">代码</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h1&gt;&lt;p&gt;之前我们学习了spring-security的认证过程，具体可以看这里&lt;a href=&quot;https://zhuchong6.github.io/2022/02/18/2022-02-18spring-security/#more&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这次，我们来学习下security的授权过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="微服务" scheme="https://github/zhuchong6.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="https://github/zhuchong6.github.io/2022/02/18/2022-02-18ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github/zhuchong6.github.io/2022/02/18/2022-02-18ThreadLocal%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-02-18T09:04:40.000Z</published>
    <updated>2022-09-29T01:04:32.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h1><p>ThreadLocal是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。</p><p>说人话就是，ThreadLocal在每个线程都创建副本，每个线程可以访问自己的副本，线程之间相互不影响。</p><span id="more"></span><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="void-set-T-value"><a href="#void-set-T-value" class="headerlink" title="void set(T value)"></a>void set(T value)</h3><pre><code class="java">public void set(T value) &#123;  //获取当前线程  Thread t = Thread.currentThread();  //获取ThreadLocalMap  ThreadLocalMap map = getMap(t);  if (map != null)    //不为空设置    map.set(this, value);  else    //为空创建ThreadLocalMap    createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123;  //返回线程Thread对象中维护的ThreadLocalMap变量  return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123;  //创建一个新的ThreadLocalMap，并绑定到t中  t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;</code></pre><h3 id="T-get"><a href="#T-get" class="headerlink" title="T get()"></a>T get()</h3><pre><code class="java">public T get() &#123;  //获取当前线程  Thread t = Thread.currentThread();  //获取当前线程维护的ThreadLocalMap  ThreadLocalMap map = getMap(t);  if (map != null) &#123;    //获取ThreadLocalMap.Entry对象    ThreadLocalMap.Entry e = map.getEntry(this);    if (e != null) &#123;      //不为空，直接返回      @SuppressWarnings(&quot;unchecked&quot;)      T result = (T)e.value;      return result;    &#125;  &#125;  //为空，返回默认值  return setInitialValue();&#125;private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;  //获取当前key对应的索引  //这个方法比较有趣，详细请看[threadlocal中hash](https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/81124944)  int i = key.threadLocalHashCode &amp; (table.length - 1);  //获取Entry对象，实际存储信息的对象  Entry e = table[i];  if (e != null &amp;&amp; e.get() == key)    //hash不冲突，并且不为空，返回对象    return e;  else    //hash冲突，或者e对象为空的情况下    return getEntryAfterMiss(key, i, e);&#125;private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;  Entry[] tab = table;  int len = tab.length;  //不空，即代表hash冲突  while (e != null) &#123;        ThreadLocal&lt;?&gt; k = e.get();    if (k == key)      return e;    //如果key为空，清除，避免内存泄漏    if (k == null)      expungeStaleEntry(i);    else      //向后查找一个1，即i = i+1      i = nextIndex(i, len);    e = tab[i];  &#125;  //e为空的情况下返回空  return null;&#125;private T setInitialValue() &#123;  //初始化null  T value = initialValue();  //获取当前线程  Thread t = Thread.currentThread();  //获取当前线程维护的ThreadLocalMap  ThreadLocalMap map = getMap(t);  if (map != null)    //设置对象    map.set(this, value);  else    //新建一个map    createMap(t, value);  return value;&#125;//初始化一个空对象protected T initialValue() &#123;  return null;&#125;</code></pre><h3 id="void-remove"><a href="#void-remove" class="headerlink" title="void remove()"></a>void remove()</h3><pre><code class="java">public void remove() &#123;  //获取当前线程的ThreadLocalMap  ThreadLocalMap m = getMap(Thread.currentThread());  if (m != null)    //不为空的话，直接清除当前对象的Entry    m.remove(this);&#125;private void remove(ThreadLocal&lt;?&gt; key) &#123;  Entry[] tab = table;  int len = tab.length;  //计算索引  int i = key.threadLocalHashCode &amp; (len-1);  for (Entry e = tab[i];       e != null;       e = tab[i = nextIndex(i, len)]) &#123;    //遍历查找相同的key，有的话清楚    if (e.get() == key) &#123;      e.clear();      expungeStaleEntry(i);      return;    &#125;  &#125;&#125;</code></pre><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><blockquote><p>什么叫内存泄漏？</p><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p><p>广义并通俗的说，就是：不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p></blockquote><p>ThreadLocal的代码结构，如图所示：</p><p><img src="/threadLocal.png" alt="threadLocal"></p><p>由此，我们可以知道，一般的调用链为：</p><blockquote><p>ThreadPool -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p></blockquote><p>如果此时，ThreadLocal使用完之后，讲栈中它的变量置为null,ThreadLocal 对象下一次 GC 会被回收,那么 Entry 中的与之关联的弱引用 key 就会变成 null。如果此时当前线程还在运行（线程池情况），<strong>那么 Entry 中的 key 为 null 的 Value 对象并不会被回收（存在强引用）</strong>；如果当前线程执行完毕会被回收（ThreaLocalMap的生命周期和Thread生命周期一起完结），那么 Value 自然也会被回收。</p><blockquote><p>为什么Value存在强引用？</p><p>可以通过数据结构看出来，v变量被指向value变量，这个就是强引用</p><pre><code>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        super(k);        value = v;    &#125;&#125;</code></pre></blockquote><p>以上，就是ThreadLocal内存泄漏的来源。那么，如何避免？</p><p>ThreadLocal 为了降低内存泄露的可能性，在set、get、remove操作时，会清除线程ThreadLocalMap中Entry所有数组中key为null的value值。</p><p>所以，当前线程使用完 threadlocal 后，我们可以通过调用 ThreadLocal 的 remove 方法进行清除从而降低内存泄漏的风险。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ThreadLocal详解&quot;&gt;&lt;a href=&quot;#ThreadLocal详解&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal详解&quot;&gt;&lt;/a&gt;ThreadLocal详解&lt;/h1&gt;&lt;p&gt;ThreadLocal是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。&lt;/p&gt;
&lt;p&gt;说人话就是，ThreadLocal在每个线程都创建副本，每个线程可以访问自己的副本，线程之间相互不影响。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java引用类型</title>
    <link href="https://github/zhuchong6.github.io/2022/02/18/2022-02-18Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/"/>
    <id>https://github/zhuchong6.github.io/2022/02/18/2022-02-18Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</id>
    <published>2022-02-18T09:02:40.000Z</published>
    <updated>2022-09-29T01:04:32.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java引用类型"><a href="#Java引用类型" class="headerlink" title="Java引用类型"></a>Java引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><pre><code class="java">Object o=new Object();//强引用</code></pre><p>在JVM进行GC的时候，只要对象有强引用与其关联，就绝对不会对它进行回收，即使已经内存不足了也不会收回有强引用指向的对象。</p><p>如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。</p><span id="more"></span><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><pre><code class="java">SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;abc&quot;));System.out.println(sr.get());System.gc();                //通知JVM的gc进行垃圾回收System.out.println(sr.get());</code></pre><p>如果内存空间足够，垃圾回收器就不会回收这个对象，但如果内存空间不足了，它就会被回收</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><pre><code class="java">WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;abc&quot;));System.out.println(sr.get());System.gc();                //通知JVM的gc进行垃圾回收System.out.println(sr.get());</code></pre><p>发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收</p><p>应用场景：ThreadLocal.ThreadLocalMap.Entry实现</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>当发生GC，虚引用就会被回收，并且会把回收的通知放到ReferenceQueue中</p><p>应用场景：DirectByteBuffer清除堆外缓存</p><p>以上简单记录下，更加详细的信息，可以移步这位大佬的博库<a href="https://cloud.tencent.com/developer/article/1484113">深入解读</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java引用类型&quot;&gt;&lt;a href=&quot;#Java引用类型&quot; class=&quot;headerlink&quot; title=&quot;Java引用类型&quot;&gt;&lt;/a&gt;Java引用类型&lt;/h1&gt;&lt;h2 id=&quot;强引用&quot;&gt;&lt;a href=&quot;#强引用&quot; class=&quot;headerlink&quot; title=&quot;强引用&quot;&gt;&lt;/a&gt;强引用&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Object o=new Object();//强引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在JVM进行GC的时候，只要对象有强引用与其关联，就绝对不会对它进行回收，即使已经内存不足了也不会收回有强引用指向的对象。&lt;/p&gt;
&lt;p&gt;如果你不需要使用某个对象了，可以将相应的引用设置为null，消除强引用来帮助垃圾回收器进行回收。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Security认证</title>
    <link href="https://github/zhuchong6.github.io/2022/02/18/2022-02-18spring-security/"/>
    <id>https://github/zhuchong6.github.io/2022/02/18/2022-02-18spring-security/</id>
    <published>2022-02-18T01:26:35.000Z</published>
    <updated>2022-09-29T01:04:32.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>Spring Security是一个安全框架，提供身份认证、授权和常见攻击的防护</p></blockquote><p>那么如何定义安全呢？</p><p>简单来说，就是你有没有进入系统的权限，以及能够访问什么样的资源的权限（包含页面按钮等）。</p><p>这些功能是每一个系统必须包含包含的，每个系统都必须重复这样一套代码。基于这样的背景，<strong>Spring</strong>抽象出一套通用的代码，在此基础上我们只需要定制化开发即可，这就诞生了Spring-Security。</p><span id="more"></span><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>我们先大概了解下Spring-Security的架构，从而对其有个大概的感知。</p><p><img src="/security-architecture.png" alt="spring-security架构图"></p><ul><li>从客户端发出的请求，首先经过servlet容器的FilterChain，进入一个个filter中</li><li>DelegatingFilterProxy是继承自Filter的一个类，用于将FilterChainProxy嵌入到webfilter中</li><li>请求到达FilterChainProxy之后，FilterChainProxy会根据请求的路径，将请求转发到不同的<strong>SpringSecurity定义的过滤器链</strong>上</li><li>请求到达Spring Security Chain上后，执行过滤器链中定义的Filter（<a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-security-filters">spring默认过滤器种类</a>）</li></ul><p>以上，就是Spring-Security大体架构。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li><p>创建一个SpringBoot项目，添加以下依赖</p><pre><code class="xml">&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>直接运行项目，可以看到控制台打印出密码：</p><pre><code class="java">2022-03-02 17:35:20.233  INFO 7930 --- [           main] .s.s.UserDetailsServiceAutoConfiguration : Using generated security password: fe636539-f71f-4408-a192-94047e6cf68c</code></pre></li><li><p>打开浏览器，输入地址<code>localhost:8080/private</code>，发现跳转到登录界面，用户名输入<code>user</code>,密码输入<code>上面控制台打印出的密码</code>，即可登录成功</p></li></ol><p>自此，一个简单的Spring-Security应用已经搭建好了。</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>看到这，大家可能对认证的过程一脸懵逼。不要急，笔者这就带着大家一起分析整个认证过程。</p><p>首先，还是看图，以下是刚才登录流程的流程图：</p><p><img src="/login.png" alt="login"></p><ol><li>首先用户请求未经授权的资源</li><li><code>FilterSecurityInterceptor</code>判断是否授权过，如果未授权抛出<code>AccessDeniedException</code>异常</li><li>由于未授权，<code>ExceptionTranslationFilter</code>启动授权过程，并通过配置类<code>AuthenticationEntryPoint</code>发送重定到登录页</li><li>然后，浏览器将请求重定向到的登录页面</li></ol><p>这就是刚才重定向的流程，下面的就是登录认证的流程：</p><p><img src="/form_login.png" alt="form_login"></p><ol><li>当用户在登录页面提交之后，请求通过过滤器链来到<code>UsernamePasswordAuthenticationFilter</code>这个过滤器中，创建一个<code>UsernamePasswordAuthenticationToken</code>（简单当成一个存储用户名密码的对象，后面会详细分析），注意这个时候还没有认证</li><li>通过<code>AuthenticationManager</code>对象进行认证（也就是比对用户名密码）的操作</li><li>成功，执行一些操作</li><li>失败，执行另一些操作</li></ol><p>以上，就是认证的大致流程。自此，可能还是有些不太明白具体怎么操作的，接下来我们深入源码来仔细剖析。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们可以看到，认证的关键流程是在一个叫做<code>UsernamePasswordAuthenticationFilter</code>开始的，我们打开源码查看他的继承结构：</p><pre><code class="java">GenericFilterBean (org.springframework.web.filter)    AbstractAuthenticationProcessingFilter (org.springframework.security.web.authentication)        UsernamePasswordAuthenticationFilter (org.springframework.security.web.authentication)</code></pre><p>可以发现，这是一个典型的模版方法模式，抽象类定义了大部分流程，实现类实现自定义部分。因此，我们的观察重点来到<code>AbstractAuthenticationProcessingFilter</code>类，又由于它是一个Filter类，我们直接从<code>doFilter</code>方法开始:</p><pre><code class="java">//继承filter实现的doFilter方法public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)  throws IOException, ServletException &#123;  doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);&#125;//真正执行逻辑的方法private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)  throws IOException, ServletException &#123;  //判断当前请求是否会被该过滤器请求  if (!requiresAuthentication(request, response)) &#123;    chain.doFilter(request, response);    return;  &#125;  try &#123;    //认证逻辑，由其子类实现，即UsernamePasswordAuthenticationFilter.attemptAuthentication方法    Authentication authenticationResult = attemptAuthentication(request, response);    if (authenticationResult == null) &#123;      // return immediately as subclass has indicated that it hasn&#39;t completed      return;    &#125;    //认证成功，设置session策略    this.sessionStrategy.onAuthentication(authenticationResult, request, response);    // Authentication success    if (this.continueChainBeforeSuccessfulAuthentication) &#123;      chain.doFilter(request, response);    &#125;    //认证成功，保存一些状态    successfulAuthentication(request, response, chain, authenticationResult);  &#125;  catch (InternalAuthenticationServiceException failed) &#123;    this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, failed);    unsuccessfulAuthentication(request, response, failed);  &#125;  catch (AuthenticationException ex) &#123;    // 认证失败，清除一些状态    unsuccessfulAuthentication(request, response, ex);  &#125;&#125;//判断当前请求是否会被该过滤器请求protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) &#123;  //注意这个参数，是他的实现类初始化的时候构造的，详见UsernamePasswordAuthenticationFilter构造方法  if (this.requiresAuthenticationRequestMatcher.matches(request)) &#123;    return true;  &#125;  if (this.logger.isTraceEnabled()) &#123;    this.logger      .trace(LogMessage.format(&quot;Did not match request to %s&quot;, this.requiresAuthenticationRequestMatcher));  &#125;  return false;&#125;</code></pre><p>UsernamePasswordAuthenticationFilter：</p><pre><code class="java">public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;username&quot;;    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;password&quot;;    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher(&quot;/login&quot;,            &quot;POST&quot;);    private String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;    private String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;    private boolean postOnly = true;    public UsernamePasswordAuthenticationFilter() &#123;        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);    &#125;    public UsernamePasswordAuthenticationFilter(AuthenticationManager authenticationManager) &#123;        super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);    &#125;    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)            throws AuthenticationException &#123;    //只支持POST方法        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());        &#125;    //获取用户名称        String username = obtainUsername(request);        username = (username != null) ? username : &quot;&quot;;        username = username.trim();    //获取密码        String password = obtainPassword(request);        password = (password != null) ? password : &quot;&quot;;    //创建一个Authentication，其中authenticated=false，代表未认证成功        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);        // Allow subclasses to set the &quot;details&quot; property        setDetails(request, authRequest);    //调用AuthenticationManager.authenticate方法进行认证        return this.getAuthenticationManager().authenticate(authRequest);    &#125;&#125;    @Nullable    protected String obtainPassword(HttpServletRequest request) &#123;        return request.getParameter(this.passwordParameter);    &#125;    @Nullable    protected String obtainUsername(HttpServletRequest request) &#123;        return request.getParameter(this.usernameParameter);    &#125;</code></pre><p>AuthenticaitonManager默认实现类ProviderManager：</p><pre><code class="java">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;        Class&lt;? extends Authentication&gt; toTest = authentication.getClass();        AuthenticationException lastException = null;        AuthenticationException parentException = null;        Authentication result = null;        Authentication parentResult = null;        int currentPosition = 0;        int size = this.providers.size();        for (AuthenticationProvider provider : getProviders()) &#123;            if (!provider.supports(toTest)) &#123;                continue;            &#125;            if (logger.isTraceEnabled()) &#123;                logger.trace(LogMessage.format(&quot;Authenticating request with %s (%d/%d)&quot;,                        provider.getClass().getSimpleName(), ++currentPosition, size));            &#125;            try &#123;        //注意⚠️        //注意⚠️        //注意⚠️        //核心代码在这，通过遍历所有的AuthenticationProvider        //如果有一个认证成功，就跳出循环，否者继续循环，循环完毕没有成功，就抛出异常                result = provider.authenticate(authentication);                if (result != null) &#123;                    copyDetails(authentication, result);                    break;                &#125;            &#125;            catch (AccountStatusException | InternalAuthenticationServiceException ex) &#123;                prepareException(ex, authentication);                // SEC-546: Avoid polling additional providers if auth failure is due to                // invalid account status                throw ex;            &#125;            catch (AuthenticationException ex) &#123;                lastException = ex;            &#125;        &#125;        if (result == null &amp;&amp; this.parent != null) &#123;            // Allow the parent to try.            try &#123;                parentResult = this.parent.authenticate(authentication);                result = parentResult;            &#125;            catch (ProviderNotFoundException ex) &#123;                // ignore as we will throw below if no other exception occurred prior to                // calling parent and the parent                // may throw ProviderNotFound even though a provider in the child already                // handled the request            &#125;            catch (AuthenticationException ex) &#123;                parentException = ex;                lastException = ex;            &#125;        &#125;        if (result != null) &#123;            if (this.eraseCredentialsAfterAuthentication &amp;&amp; (result instanceof CredentialsContainer)) &#123;                // Authentication is complete. Remove credentials and other secret data                // from authentication                ((CredentialsContainer) result).eraseCredentials();            &#125;            // If the parent AuthenticationManager was attempted and successful then it            // will publish an AuthenticationSuccessEvent            // This check prevents a duplicate AuthenticationSuccessEvent if the parent            // AuthenticationManager already published it            if (parentResult == null) &#123;                this.eventPublisher.publishAuthenticationSuccess(result);            &#125;            return result;        &#125;        // Parent was null, or didn&#39;t authenticate (or throw an exception).        if (lastException == null) &#123;            lastException = new ProviderNotFoundException(this.messages.getMessage(&quot;ProviderManager.providerNotFound&quot;,                    new Object[] &#123; toTest.getName() &#125;, &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));        &#125;        // If the parent AuthenticationManager was attempted and failed then it will        // publish an AbstractAuthenticationFailureEvent        // This check prevents a duplicate AbstractAuthenticationFailureEvent if the        // parent AuthenticationManager already published it        if (parentException == null) &#123;            prepareException(lastException, authentication);        &#125;        throw lastException;    &#125;</code></pre><p>关键问题来了，AuthenticationProvider是干嘛的？我们可以打个断点，发现他先走的AnonymousAuthenticationProvider这个，但是后来发现不支持，然后找他的父AuthenticaitonManager，里面默认走的DaoAuthenticationProvider，因此我们只需要看这个就好了。同样的，DaoAuthenticationProvider也是一个模版方法实践的案例，我们通过AbstractUserDetailsAuthenticationProvider可以找到执行流程：</p><pre><code class="java">//AbstractUserDetailsAuthenticationProvider类下面的方法public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,                () -&gt; this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;,                        &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));      //获取用户名，authentication目前未认证        String username = determineUsername(authentication);    //用户有无被缓存        boolean cacheWasUsed = true;        UserDetails user = this.userCache.getUserFromCache(username);        if (user == null) &#123;            cacheWasUsed = false;            try &#123;        //authentication目前未认证        //从子类实现取用户，user对象是从子类的取，一般是从数据库取，所以代表这个对象是实际用户存的                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);            &#125;            catch (UsernameNotFoundException ex) &#123;                this.logger.debug(&quot;Failed to find user &#39;&quot; + username + &quot;&#39;&quot;);                if (!this.hideUserNotFoundExceptions) &#123;                    throw ex;                &#125;                throw new BadCredentialsException(this.messages                        .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));            &#125;            Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;);        &#125;  //缓存直接走下面流程        try &#123;      //检查操作，暂时不理会            this.preAuthenticationChecks.check(user);      //关键点      //user是实际用户存的，authentication是通过前面请求参数封装的未认证      //这一步就是比对过程，还是在子类中实现            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);        &#125;        catch (AuthenticationException ex) &#123;            if (!cacheWasUsed) &#123;                throw ex;            &#125;            // There was a problem, so try again after checking            // we&#39;re using latest data (i.e. not from the cache)            cacheWasUsed = false;            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);            this.preAuthenticationChecks.check(user);            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);        &#125;        this.postAuthenticationChecks.check(user);        if (!cacheWasUsed) &#123;            this.userCache.putUserInCache(user);        &#125;        Object principalToReturn = user;        if (this.forcePrincipalAsString) &#123;            principalToReturn = user.getUsername();        &#125;        return createSuccessAuthentication(principalToReturn, authentication, user);    &#125;//子类DaoAuthenticationProvider的实现    protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication)            throws AuthenticationException &#123;        prepareTimingAttackProtection();        try &#123;      //通过UserDetailService取鱼用户名，并进行比对            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);            if (loadedUser == null) &#123;                throw new InternalAuthenticationServiceException(                        &quot;UserDetailsService returned null, which is an interface contract violation&quot;);            &#125;            return loadedUser;        &#125;        catch (UsernameNotFoundException ex) &#123;            mitigateAgainstTimingAttack(authentication);            throw ex;        &#125;        catch (InternalAuthenticationServiceException ex) &#123;            throw ex;        &#125;        catch (Exception ex) &#123;            throw new InternalAuthenticationServiceException(ex.getMessage(), ex);        &#125;    &#125;//子类DaoAuthenticationProvider的实现//真实信息和参数中取的信息的比对过程，也就是认证过程    protected void additionalAuthenticationChecks(UserDetails userDetails,            UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;        if (authentication.getCredentials() == null) &#123;            this.logger.debug(&quot;Failed to authenticate since no credentials provided&quot;);            throw new BadCredentialsException(this.messages                    .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));        &#125;        String presentedPassword = authentication.getCredentials().toString();        if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;            this.logger.debug(&quot;Failed to authenticate since password does not match stored value&quot;);            throw new BadCredentialsException(this.messages                    .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));        &#125;    &#125;</code></pre><p>以上，就是默认实现的整个认证流程，流程图可以参考下面的图：</p><p><img src="/process.png" alt="process"></p><h2 id="实现前后端分离的认证过程"><a href="#实现前后端分离的认证过程" class="headerlink" title="实现前后端分离的认证过程"></a>实现前后端分离的认证过程</h2><p>目前绝大多数的项目都是前后端分离的项目，而Spring-Security默认实现的是表单登录，所以需要对其进行一些改造来满足我们的需求。</p><p><strong>注意，我们暂时还是使用form表单的参数、url，只是改为Ajax提交</strong></p><ol><li><p>按照上面的流程图一步步替换，首先创建一个自己的Filter，由于使用的还是表单登录的filter，直接继承<code>UsernamePasswordAuthenticationFilter</code>即可</p><pre><code class="java">@Slf4jpublic class MyLoginAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123;</code></pre><pre><code>public MyLoginAuthenticationFilter() &#123;    //直接使用父类的配置    super();&#125;@Overridepublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;    //只支持post提交    if (!request.getMethod().equals(HttpMethod.POST.name())) &#123;        throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());    &#125;    UsernamePasswordAuthenticationToken unAuthenticaiton = null;    try &#123;        Map&lt;String, String&gt; map = getStringStringMap(request);        String username = map.get(&quot;username&quot;).trim();        String password = map.get(&quot;password&quot;).trim();        //创建一个未认证的Authentication        unAuthenticaiton = new UsernamePasswordAuthenticationToken(username, password);    &#125;catch (Exception e)&#123;        log.error(&quot;解析错误:&#123;&#125;&quot;, e.getMessage());    &#125;    return getAuthenticationManager().authenticate(unAuthenticaiton);&#125;/** * 将request中的用户名、密码提取出来封装到map中 * @param request * @return * @throws IOException */private Map&lt;String, String&gt; getStringStringMap(HttpServletRequest request) throws IOException &#123;    BufferedReader reader = request.getReader();    StringBuilder builder = new StringBuilder();    String line = reader.readLine();    while (line != null) &#123;        builder.append(line);        line = reader.readLine();    &#125;    reader.close();    String reqBody = builder.toString();            //JsonUtil是自己写的工具类，将string转成对象，可以直接用其他工具实现    JsonParser parse = JsonUtil.parse(reqBody);    Map&lt;String, String&gt; map = parse.readValueAs(Map.class);    return map;&#125;</code></pre><p>}</p></li></ol><pre><code>2. 替换`AuthenticaitonManager`，但是由于其默认实现类`ProviderManager`逻辑是通用的，所以我们这个场景没有必要替换3. 替换`AuthenticaitonProvider`，其中`UserServiceImpl`是我们自己的实现类```java@Componentpublic class MyAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider &#123;    @Autowired    public UserServiceImpl userService;      //对密码进行加密的类，Security中密码对比就是加密后比对是否一致    @Autowired    @Lazy    public BCryptPasswordEncoder bCryptPasswordEncoder;    /**     * 执行密码校验     * @param userDetails     * @param authentication     * @throws AuthenticationException     */    @Override    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;        if (authentication.getCredentials() == null) &#123;            this.logger.debug(&quot;Failed to authenticate since no credentials provided&quot;);            throw new BadCredentialsException(this.messages                    .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));        &#125;        String presentedPassword = authentication.getCredentials().toString();        if (!this.bCryptPasswordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;            this.logger.debug(&quot;Failed to authenticate since password does not match stored value&quot;);            throw new BadCredentialsException(this.messages                    .getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));        &#125;    &#125;    /**     * 获取密码参数,这个地方获取的就是可信任的     * 一般从数据库或者其他服务获取     * @param username     * @param authentication     * @return     * @throws AuthenticationException     */    @Override    protected UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;        UserDetails loadedUser = userService.loadUserByUsername(username);        if (loadedUser == null) &#123;            throw new InternalAuthenticationServiceException(                    &quot;UserDetailsService returned null, which is an interface contract violation&quot;);        &#125;        return loadedUser;    &#125;&#125;</code></pre><ol start="4"><li><p>实现自己的UserService类,关键点在于实现<code>UserDetailsService</code>接口。通常，这里就是从数据库或者服务中获取，这里简单演示下流程。</p><pre><code class="java">public interface UserService &#123;&#125;</code></pre><p>@Service(value &#x3D; “userService”)<br>public class UserServiceImpl implements UserService, UserDetailsService {</p><pre><code>@Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;    if (!&quot;zhuchong&quot;.equals(username)) &#123;        throw new UsernameNotFoundException(&quot;找不到用户&quot;);    &#125;            //添加角色    List&lt;GrantedAuthority&gt; grantedAuthorities = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;ADMIN,USER&quot;);    String encode = new BCryptPasswordEncoder().encode(&quot;123&quot;);  //这个是security默认提供的，一般我们需要实现自己的User类，实现UserDetails接口即可  //这里偷懒直接用现成的    return new User(&quot;zhuchong&quot;, encode, grantedAuthorities);&#125;</code></pre><p>}</p></li></ol><pre><code>5. 自此，我们所有流程基本修改完毕，但是还有最重要的一个就是把这些修改过的类配置进security中```java@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    private MyAuthenticationProvider myAuthenticationProvider;    @Bean    public BCryptPasswordEncoder bCryptPasswordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;    @Bean    public MyLoginAuthenticationFilter myLoginAuthenticationFilter() throws Exception &#123;        MyLoginAuthenticationFilter filter = new MyLoginAuthenticationFilter();        //对这个filter设置AuthenticationManager，取默认的        filter.setAuthenticationManager(authenticationManagerBean());        //设置成功的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;            //登录成功时返回给前端的数据            Map result = new HashMap();            result.put(&quot;success&quot;, &quot;登录成功&quot;);            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        //设置失败的处理器，由于要返回json，所以进行一些处理        filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;            Map result = new HashMap();            if (exception instanceof UsernameNotFoundException) &#123;                result.put(&quot;fail&quot;, exception.getMessage());            &#125; else if (exception instanceof BadCredentialsException) &#123;                result.put(&quot;fail&quot;, &quot;密码错误&quot; + exception.getMessage());            &#125; else &#123;                result.put(&quot;fail&quot;, &quot;其他异常&quot;);            &#125;            response.setContentType(&quot;application/json;charset=utf-8&quot;);            response.getWriter().write(JsonUtil.jsonToString(result));        &#125;);        return filter;    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        //关闭跨域和csrf防护        http.cors().and().csrf().disable();        //对请求url进行防护        http.authorizeRequests()                .antMatchers(&quot;/index&quot;).hasRole(&quot;USER&quot;)                .antMatchers(&quot;hello&quot;).hasRole(&quot;admin&quot;)                .and()                .formLogin()                .permitAll()                .and()                .logout()                .permitAll()                .logoutSuccessHandler((request, response, authentication) -&gt; &#123;                    //登出成功时返回给前端的数据                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;注销成功&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .deleteCookies(&quot;JSESSIONID&quot;)                .and()                .exceptionHandling()                .accessDeniedHandler((request, response, exception) -&gt; &#123;                    //访问拒绝时返回给前端的数据                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;无权访问，need Authorities!!&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .authenticationEntryPoint((request, response, exception) -&gt; &#123;                    //访问有权限url时进行拦截                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;需要登录!!&quot;);                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;)                .and()                .sessionManagement()                .maximumSessions(1)     //最多只能一个用户登录一个账号                .expiredSessionStrategy(event -&gt; &#123;                    //session策略的返回                    Map result = new HashMap();                    result.put(&quot;success&quot;, &quot;您的账号在异地登录，建议修改密码!!&quot;);                    HttpServletResponse response = event.getResponse();                    response.setContentType(&quot;application/json;charset=utf-8&quot;);                    response.getWriter().write(JsonUtil.jsonToString(result));                &#125;);        //把filter添加到UsernamePasswordAuthenticationFilter这个过滤器位置        http.addFilterAt(myLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);        //把自定义的AuthenticationProvider设置进去        http.authenticationProvider(myAuthenticationProvider);    &#125;&#125;</code></pre><p>自此，已经完成改造。可以在postman上测试一下，基本上入参返回值都能使用json来展示。</p><h2 id="自定义短信登录"><a href="#自定义短信登录" class="headerlink" title="自定义短信登录"></a>自定义短信登录</h2><p>我们可以模仿<code>UsernamePasswordAuthenticationFilter</code>来实现，短信的Filter</p><ol><li><p>创建一个用于实现短信功能的Filter，<code>SmsLoginAuthenticationFilter</code></p><pre><code class="java">public class SmsLoginAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;    Map&lt;String,String&gt; map= new HashMap&lt;&gt;();    //定义短信接口的入参    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;userPhone&quot;;    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;code&quot;;    private String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;    private String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;    //定义短信接口的url和方法类型    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher(&quot;/smsLogin&quot;,            &quot;POST&quot;);    public SmsLoginAuthenticationFilter() &#123;        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);    &#125;</code></pre><pre><code>public SmsLoginAuthenticationFilter(AuthenticationManager authenticationManager) &#123;    super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);&#125;@Overridepublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException &#123;    //只支持post提交    if (!request.getMethod().equals(HttpMethod.POST.name())) &#123;        throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());    &#125;    //取出reqest的手机号    String username = obtainUsername(request);    username = (username != null) ? username : &quot;&quot;;    username = username.trim();    //取出request的验证码    String password = obtainPassword(request);    password = (password != null) ? password : &quot;&quot;;    //创建一个自定义的Authentication对象    SmsAuthenticationToken smsAuthenticationToken = new SmsAuthenticationToken(username, password);    //把request的一些参数绑定到smsAuthenticationToken对象中，具体可以断点查看    setDetails(request, smsAuthenticationToken);    //调用AuthenticationManager的authenticate方法    return this.getAuthenticationManager().authenticate(smsAuthenticationToken);&#125;protected void setDetails(HttpServletRequest request, SmsAuthenticationToken authRequest) &#123;    authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));&#125;@Nullableprotected String obtainPassword(HttpServletRequest request) throws IOException &#123;    return map.get(passwordParameter);&#125;@Nullableprotected String obtainUsername(HttpServletRequest request) throws IOException &#123;    getStringStringMap(request);    return map.get(usernameParameter);&#125;/** * 将request中的用户名、密码提取出来封装到map中 * @param request * @return * @throws IOException */private Map&lt;String, String&gt; getStringStringMap(HttpServletRequest request) throws IOException &#123;    BufferedReader reader = request.getReader();    StringBuilder builder = new StringBuilder();    String line = reader.readLine();    while (line != null) &#123;        builder.append(line);        line = reader.readLine();    &#125;    reader.close();    String reqBody = builder.toString();    JsonParser parse = JsonUtil.parse(reqBody);    map = parse.readValueAs(Map.class);    return map;&#125;</code></pre><p>}</p></li></ol><pre><code>2. 自定义一个`Authentication`类，名字是`SmsAuthenticationToken`，用于自定义的短信信息,这个基本照抄`UsernamePasswordAuthenticationToken````javapublic class SmsAuthenticationToken extends AbstractAuthenticationToken &#123;    private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;    private final Object principal;    private Object credentials;    public SmsAuthenticationToken(Object principal, Object credentials) &#123;        super(null);        this.principal = principal;        this.credentials = credentials;    &#125;    public SmsAuthenticationToken(Collection&lt;? extends GrantedAuthority&gt; authorities, Object principal, Object credentials) &#123;        super(authorities);        this.principal = principal;        this.credentials = credentials;        super.setAuthenticated(true);    &#125;    @Override    public Object getCredentials() &#123;        return this.credentials;    &#125;    @Override    public Object getPrincipal() &#123;        return this.principal;    &#125;&#125;</code></pre><ol start="3"><li><p>第1步中调用AuthenticationManager的authenticate方法，由于AuthenticationManager实现类ProviderManager比较通用，可以不用重新实现</p></li><li><p>创建一个<code>AuthenticationProvider</code>的实现类<code>SmsAuthenticationProvider</code>，用于实现具体查找可信任的验证码信息</p><pre><code class="java">@Componentpublic class SmsAuthenticationProvider implements AuthenticationProvider &#123;    @Autowired    private SmsServiceImpl smsService;    @Override    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;        SmsAuthenticationToken smsAuthenticationToken = (SmsAuthenticationToken) authentication;        //请求参数获取的        String unAuthenticationCode = authentication.getCredentials().toString();        //从后台缓存获取的        String authenticationCode = smsService.getCode(smsAuthenticationToken.getPrincipal().toString());        if (authenticationCode == null) &#123;            throw new InternalAuthenticationServiceException(                    &quot;UserDetailsService returned null, which is an interface contract violation&quot;);        &#125;        if (!unAuthenticationCode.equals(authenticationCode)) &#123;            throw new BadCredentialsException(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;);        &#125;        //验证通过，从数据库取user，填充到userDetails中        UserDetails user = smsService.loadUserByUsername(smsAuthenticationToken.getPrincipal().toString());        return createSuccessAuthentication(authentication, user);    &#125;    private Authentication createSuccessAuthentication(Authentication authentication, UserDetails smsDetail) &#123;        //主要拼一个        SmsAuthenticationToken authenticationToken = new SmsAuthenticationToken(smsDetail.getAuthorities(),                smsDetail.getUsername(), smsDetail.getPassword());        authenticationToken.setDetails(authentication.getDetails());        return authenticationToken;    &#125;    @Override    public boolean supports(Class&lt;?&gt; authentication) &#123;        return (SmsAuthenticationToken.class.isAssignableFrom(authentication));    &#125;&#125;</code></pre></li><li><p>由于这个是短信验证功能，和表单提交的有点不一样，因此User对象得定制，所以新增一个SmsDetail类.这个类实现UserDetail接口</p></li></ol><pre><code class="java">@Datapublic class SmsDetail implements UserDetails &#123;    private static final Log logger = LogFactory.getLog(User.class);    private String password;    private String username;    private Set&lt;GrantedAuthority&gt; authorities;    private boolean accountNonExpired;    private boolean accountNonLocked;    private boolean credentialsNonExpired;    private boolean enabled;    /**     * 手机号     */    private String phone;    /**     * 验证码     */    private String code;&#125;</code></pre><ol start="6"><li><p>接下来就是熟悉的controller层和service层</p><pre><code class="java">@RestControllerpublic class SmsLoginController &#123;    @PostMapping(&quot;/verityCode&quot;)    @ResponseBody    Result login(@RequestBody Map&lt;String, String&gt; map) &#123;        String username = map.get(&quot;userPhone&quot;);        //如果用户存在，发送验证码        Boolean checkUserExist = true;        if(checkUserExist)&#123;            //假装是一个随机的字符串            String code = &quot;66666&quot;;            CacheUtil.put(&quot;sms&quot;+username,code);            return Result.ok(code);        &#125;        return Result.ok();    &#125;&#125;</code></pre><p>   @Service(value &#x3D; “smsService”)<br>   public class SmsServiceImpl implements UserService, UserDetailsService {</p><pre><code>   public String getCode(String phone) throws UsernameNotFoundException &#123;       //这里就是通过phone去缓存中取数据       String key = &quot;sms&quot;+phone;       String code = CacheUtil.get(key);       if(code == null)&#123;           throw new UsernameNotFoundException(&quot;验证码不存在&quot;);       &#125;       return code;   &#125;   @Override   public UserDetails loadUserByUsername(String phone) throws UsernameNotFoundException &#123;       //通过手机号查找用户       if (!&quot;131&quot;.equals(phone)) &#123;           throw new UsernameNotFoundException(&quot;找不到用户&quot;);       &#125;       List&lt;GrantedAuthority&gt; grantedAuthorities = AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;ADMIN,USER&quot;);       String encode = new BCryptPasswordEncoder().encode(&quot;123&quot;);       return new User(&quot;zhuchong&quot;, encode, grantedAuthorities);   &#125;</code></pre><p>   }</p><pre><code></code></pre></li><li><p>添加配置，将我们刚才的自定义的类设置进去</p><pre><code class="java">@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Autowired    private MyAuthenticationProvider myAuthenticationProvider;    @Autowired    private SmsAuthenticationProvider smsAuthenticationProvider;</code></pre><pre><code>   @Bean   public BCryptPasswordEncoder bCryptPasswordEncoder() &#123;       return new BCryptPasswordEncoder();   &#125;   @Bean   public SmsLoginAuthenticationFilter smsLoginAuthenticationFilter() throws Exception&#123;       SmsLoginAuthenticationFilter filter = new SmsLoginAuthenticationFilter();       //对这个filter设置AuthenticationManager，取默认的ProviderManager       filter.setAuthenticationManager(authenticationManagerBean());       //设置成功的处理器，由于要返回json，所以进行一些处理       filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;           //登录成功时返回给前端的数据           Map result = new HashMap();           result.put(&quot;success&quot;, &quot;sms登录成功&quot;);           response.setContentType(&quot;application/json;charset=utf-8&quot;);           response.getWriter().write(JsonUtil.jsonToString(result));       &#125;);       //设置失败的处理器，由于要返回json，所以进行一些处理       filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;           Map result = new HashMap();           if (exception instanceof UsernameNotFoundException) &#123;               result.put(&quot;fail&quot;, exception.getMessage());           &#125; else if (exception instanceof BadCredentialsException) &#123;               result.put(&quot;fail&quot;, &quot;sms密码错误&quot; + exception.getMessage());           &#125; else &#123;               result.put(&quot;fail&quot;, &quot;sms其他异常&quot;);           &#125;           response.setContentType(&quot;application/json;charset=utf-8&quot;);           response.getWriter().write(JsonUtil.jsonToString(result));       &#125;);       return filter;   &#125;   @Bean   public MyLoginAuthenticationFilter myLoginAuthenticationFilter() throws Exception &#123;       MyLoginAuthenticationFilter filter = new MyLoginAuthenticationFilter();       //对这个filter设置AuthenticationManager，取默认的       filter.setAuthenticationManager(authenticationManagerBean());       //设置成功的处理器，由于要返回json，所以进行一些处理       filter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;           //登录成功时返回给前端的数据           Map result = new HashMap();           result.put(&quot;success&quot;, &quot;登录成功&quot;);           response.setContentType(&quot;application/json;charset=utf-8&quot;);           response.getWriter().write(JsonUtil.jsonToString(result));       &#125;);       //设置失败的处理器，由于要返回json，所以进行一些处理       filter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;           Map result = new HashMap();           if (exception instanceof UsernameNotFoundException) &#123;               result.put(&quot;fail&quot;, exception.getMessage());           &#125; else if (exception instanceof BadCredentialsException) &#123;               result.put(&quot;fail&quot;, &quot;密码错误&quot; + exception.getMessage());           &#125; else &#123;               result.put(&quot;fail&quot;, &quot;其他异常&quot;);           &#125;           response.setContentType(&quot;application/json;charset=utf-8&quot;);           response.getWriter().write(JsonUtil.jsonToString(result));       &#125;);       return filter;   &#125;   @Override   protected void configure(HttpSecurity http) throws Exception &#123;       //关闭跨域和csrf防护       http.cors().and().csrf().disable();       //对请求url进行防护       http.authorizeRequests()               .antMatchers(&quot;/index&quot;).hasRole(&quot;USER&quot;)               .antMatchers(&quot;hello&quot;).hasRole(&quot;admin&quot;)               .and()               .authorizeRequests()               //放行这些路径               .antMatchers(&quot;/smsLogin&quot;,&quot;verityCode&quot;,&quot;/login&quot;)               .permitAll()               .and()               .formLogin()               .permitAll()               .and()               .logout()               .permitAll()               .logoutSuccessHandler((request, response, authentication) -&gt; &#123;                   //登出成功时返回给前端的数据                   Map result = new HashMap();                   result.put(&quot;success&quot;, &quot;注销成功&quot;);                   response.setContentType(&quot;application/json;charset=utf-8&quot;);                   response.getWriter().write(JsonUtil.jsonToString(result));               &#125;)               .deleteCookies(&quot;JSESSIONID&quot;)               .and()               .exceptionHandling()               .accessDeniedHandler((request, response, exception) -&gt; &#123;                   //访问拒绝时返回给前端的数据                   Map result = new HashMap();                   result.put(&quot;success&quot;, &quot;无权访问，need Authorities!!&quot;);                   response.setContentType(&quot;application/json;charset=utf-8&quot;);                   response.getWriter().write(JsonUtil.jsonToString(result));               &#125;)               .authenticationEntryPoint((request, response, exception) -&gt; &#123;                   //访问有权限url时进行拦截                   Map result = new HashMap();                   result.put(&quot;success&quot;, &quot;需要登录!!&quot;);                   response.setContentType(&quot;application/json;charset=utf-8&quot;);                   response.getWriter().write(JsonUtil.jsonToString(result));               &#125;)               .and()               .sessionManagement()               .maximumSessions(1)     //最多只能一个用户登录一个账号               .expiredSessionStrategy(event -&gt; &#123;                   //session策略的返回                   Map result = new HashMap();                   result.put(&quot;success&quot;, &quot;您的账号在异地登录，建议修改密码!!&quot;);                   HttpServletResponse response = event.getResponse();                   response.setContentType(&quot;application/json;charset=utf-8&quot;);                   response.getWriter().write(JsonUtil.jsonToString(result));               &#125;);       //把filter添加到UsernamePasswordAuthenticationFilter这个过滤器位置       http.addFilterAt(myLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)               .addFilterAfter(smsLoginAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);       //把自定义的AuthenticationProvider设置进去       http.authenticationProvider(myAuthenticationProvider)               .authenticationProvider(smsAuthenticationProvider);   &#125;</code></pre><pre><code></code></pre></li><li><p>ok完成，启动应用进行验证。首先，先访问<code>/verityCode</code>接口获取验证码，然后在访问<code>/smsLogin接口</code>进行短信功能的认证过程</p></li></ol><p>自此，我们认证过程就告一段落。限于文笔，笔者讲述的可能不是很清晰，大家配合断点源码食用更佳。</p><p>我会把项目上传到github上，以下是链接：<a href="https://github.com/zhuchong6/spring-all">spring-security</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">spring官方文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Security是一个安全框架，提供身份认证、授权和常见攻击的防护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么如何定义安全呢？&lt;/p&gt;
&lt;p&gt;简单来说，就是你有没有进入系统的权限，以及能够访问什么样的资源的权限（包含页面按钮等）。&lt;/p&gt;
&lt;p&gt;这些功能是每一个系统必须包含包含的，每个系统都必须重复这样一套代码。基于这样的背景，&lt;strong&gt;Spring&lt;/strong&gt;抽象出一套通用的代码，在此基础上我们只需要定制化开发即可，这就诞生了Spring-Security。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="微服务" scheme="https://github/zhuchong6.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Spring" scheme="https://github/zhuchong6.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>golang入门</title>
    <link href="https://github/zhuchong6.github.io/2022/01/28/2022-01-28go%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%8E%A2/"/>
    <id>https://github/zhuchong6.github.io/2022/01/28/2022-01-28go%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%8E%A2/</id>
    <published>2022-01-28T03:04:59.000Z</published>
    <updated>2022-09-29T01:04:32.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go学习"><a href="#Go学习" class="headerlink" title="Go学习"></a>Go学习</h1><p>环境：</p><blockquote><p>操作系统：mac</p></blockquote><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>去<a href="https://golang.google.cn/doc/install">官网地址</a>下载mac版本的安装包，双击按照提示安装就行了</li><li>打开terminal，输入<code>go version</code>，验证是否安装成功</li><li>输入<code>cd /usr/local/go</code>查看go的安装目录</li></ol><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><ol><li><p>创建一个文件夹hello，然后就进入文件夹（我是在桌面创建的）</p></li><li><p>开启依赖跟踪和管理，<code>go mod init example/hello</code>,运行成功后会在hello目录下有一个go.mod文件</p></li><li><p>通过编辑器（我使用的vscode）创建一个hello.go文件</p></li><li><p>在hello.go输入一下代码</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello, World!&quot;)&#125;</code></pre></li><li><p>执行<code>go run .</code>命令，控制台打出<em>Hello, World!</em></p></li></ol><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><ol><li><p>创建一个文件夹greet，然后进入文件夹</p></li><li><p>开启依赖跟踪和管理，<code>go mod init example.io/greetings</code>,执行成功后greet目录下有个go.mod文件</p></li><li><p>创建<em>greetings.go</em>文件</p></li><li><p>输入一下代码</p><pre><code class="go">//声明一个名为greetings的包，组织相关函数package greetingsimport &quot;fmt&quot;//实现Hello函数//Hello：函数名，大写字母开头表示是一个Exported Name，能被包外调用，否则不能被包外调用//name：入参//第一个string：入参类型//第二个string：出参类型func Hello(name string) string&#123;    //message 返回参数名称  //:= 在go中是简写，  //等同于 var message string  //message = fmt.Sprintf(&quot;Hi, %v. Welcome!&quot;, name)    message := fmt.Sprint(&quot;Hi, %v. Welcome!&quot;, name)  //返回值    return message&#125;</code></pre></li></ol><h3 id="调用模块"><a href="#调用模块" class="headerlink" title="调用模块"></a>调用模块</h3><ol><li><p>在hello文件夹下，创建一个<strong>hello.go</strong>文件</p></li><li><p>输入以下代码</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;example.io/greetings&quot;)func main()&#123;    message := greetings.Hello(&quot;from hello.go file invoke&quot;)    fmt.Println(message)&#125;</code></pre></li><li><p>运行命令<code>go mod edit -replace example.com/greetings=../greetings</code>,关联导入<code>&quot;example.io/greetings&quot;</code>的实际地址</p></li><li><p>运行命令<code>go mod tidy</code>,同步添加example.io&#x2F;greetings模块的依赖项</p></li><li><p>运行命令<code>go run .</code>，得到结果<strong>Hi, from hello.go file invoke. Welcome!</strong></p></li></ol><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ol><li><p>打开<strong>greetings&#x2F;greetings.go</strong>文件，进行如下修改：</p><pre><code class="go">package greetingsimport (    &quot;fmt&quot;  //导入errors库    &quot;errors&quot;)//多了一个error返回参数，注意go函数可以返回多个参数func Hello(name string) (string, error)&#123;  //如果name为空，返回error类型    if name == &quot;&quot; &#123;        return &quot;&quot;, errors.New(&quot;empty name&quot;)    &#125;    message := fmt.Sprintf(&quot;Hi, %v. Welcome!&quot;, name)  //如果不为空，error位置返回一个nill，用于调用方判断    return message, nil&#125;</code></pre></li><li><p>打开<strong>hello&#x2F;hello.go</strong>文件，进行如下修改：</p><pre><code class="go">package mainimport (  //导入日志库    &quot;log&quot;    &quot;fmt&quot;    &quot;example.com/greetings&quot;)func main()&#123;    //设置log参数    log.SetPrefix(&quot;greetings: &quot;)  //0 不打印日期参数     log.SetFlags(0)    //返回俩参数，用俩参数接收    message,err := greetings.Hello(&quot;&quot;)    //这里对greetings返回的err参数进行判断  //如果是nil代表没有错误，继续正确流程；不是nil进行一个错误的打印，然后退出程序    if(err != nil)&#123;        log.Fatal(err)    &#125;    fmt.Println(message)&#125;</code></pre></li><li><p>进入hello目录，执行<code>go run .</code> ，打印如下：</p><pre><code class="go">greetings: empty nameexit status 1</code></pre><p><strong>总结，go中的通用错误处理就是这样，返回一个error作为参数，然后调用方进行检查</strong></p></li></ol><h3 id="返回随机问候"><a href="#返回随机问候" class="headerlink" title="返回随机问候"></a>返回随机问候</h3><p>为了完成这个功能，需要使用<strong>slice</strong>结构，这个结构大致可以看作Java中的ArrayList，可以动态扩容。</p><p>修改<strong>greetings&#x2F;greetings.go</strong>文件，改动如下：</p><pre><code class="go">package greetingsimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;math/rand&quot;    &quot;time&quot;)func Hello(name string) (string, error)&#123;    if name == &quot;&quot; &#123;        return &quot;&quot;, errors.New(&quot;empty name&quot;)    &#125;    message := fmt.Sprintf(randomFormat(), name)    return message, nil&#125;//init方法会在程序启动全局变量初始化后自动被调用func init() &#123;  //设置随机数种子    rand.Seed(time.Now().UnixNano())&#125;//随机返回一个greet模版func randomFormat() string&#123;    formats := []string&#123;        &quot;Hi, %v. Welcome!&quot;,        &quot;Great to see you, %v!&quot;,        &quot;Hail, %v! Well met!&quot;,    &#125;    return formats[rand.Intn(len(formats))]&#125;</code></pre><p>执行之后，结果如下：</p><pre><code class="go">knight@knightdeMBP hello % go run .Hi, jj. Welcome!knight@knightdeMBP hello % go run .Great to see you, jj!knight@knightdeMBP hello % go run .Hi, jj. Welcome!</code></pre><h3 id="返回多个人的问候"><a href="#返回多个人的问候" class="headerlink" title="返回多个人的问候"></a>返回多个人的问候</h3><p>由于之前greetings.go中的Hello函数入参只有一个，我们现在需要多个。</p><p>go不支持函数重载，只有新写一个函数，具体代码如下：</p><pre><code class="go">package greetingsimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;math/rand&quot;    &quot;time&quot;)func Hello(name string) (string, error)&#123;    if name == &quot;&quot; &#123;        return &quot;&quot;, errors.New(&quot;empty name&quot;)    &#125;    message := fmt.Sprintf(randomFormat(), name)    return message, nil&#125;//入参是多个参数，返回一个map结构，一个error参数func Hellos(names []string) (map[string]string, error)&#123;  //初始化map结构    messages := make(map[string]string)  //遍历入参，index代表names的索引，name代表索引位置对应的值  //如果不关心索引的话，index可以用 &#39;_&#39;代替，表示忽略索引参数，例如：for _,name := range namse&#123;&#125;    for index, name := range names&#123;        fmt.Println(index)        message, err := Hello(name)    if (err != nil) &#123;      return nil, err    &#125;    //设置map        messages[name] = message    &#125;    return messages, nil&#125;func init() &#123;    rand.Seed(time.Now().UnixNano())&#125;func randomFormat() string&#123;    formats := []string&#123;        &quot;Hi, %v. Welcome!&quot;,        &quot;Great to see you, %v!&quot;,        &quot;Hail, %v! Well met!&quot;,    &#125;    return formats[rand.Intn(len(formats))]&#125;</code></pre><p>然后对调用方进行修改，具体如下：</p><pre><code class="go">package mainimport (    &quot;log&quot;    &quot;fmt&quot;    &quot;example.com/greetings&quot;)func main()&#123;    //设置log参数    log.SetPrefix(&quot;greetings: &quot;)    log.SetFlags(0)  //创建一个names的slice结构    names := []string&#123;&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;&#125;  //作为入参，然后接一个map    message,err := greetings.Hellos(names)    if(err != nil)&#123;        log.Fatal(err)    &#125;  //打印    fmt.Println(message)&#125;</code></pre><p>到hello目录下，执行命令<code>go run .</code>，得到结果：</p><pre><code class="go">knight@knightdeMacBook-Pro hello % go run .map[lisi:Hi, lisi. Welcome! wangwu:Great to see you, wangwu! zhangsan:Hi, zhangsan. Welcome!]</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ol><li><p>在<strong>greetings</strong>目录创建一个greetings_test.go文件</p></li><li><p>往greetings_test.go文件写入如下代码</p><pre><code class="go">package greetingsimport (    &quot;testing&quot;    &quot;regexp&quot;)//创建一个测试单个名称的测试用例，测试类必须以TestName的形式，其中Name代表确切的测试过程//指向 *testing.T 的指针，用于报告，或者记录你的测试过程func TestHelloName(t *testing.T)  &#123;    name := &quot;Gladys&quot;    want := regexp.MustCompile(`\b`+name+`\b`)  //正常调用greetings.go里面的Hello方法    msg, err := Hello(&quot;Gladys&quot;)  //如果返回的参数，包含Gladys，测试通过，否者打印日志    if( !want.MatchString(msg) || err!=nil )&#123;        t.Fatalf(`Hello(&quot;Gladys&quot;) = %q, %v, want match for %#q, nil`, msg, err, want)    &#125;&#125;//创建一个测试空名称的测试用例func TestHelloEmpty(t *testing.T)&#123;    msg, err := Hello(&quot;&quot;)    if msg != &quot;&quot; || err == nil &#123;        t.Fatalf(`Hello(&quot;&quot;) = %q, %v, want &quot;&quot;, error`, msg, err)    &#125;&#125;</code></pre></li><li><p>在当前目录，即<strong>greetings</strong>目录下，打开命令输入<code>go test</code>或者<code>go test -v</code></p></li><li><p>修改greetings.Hello方法，重复步骤3，来查看失败的测试结果</p></li></ol><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>本主题主要学习两个命令,<code>go build</code>：编译包和他们的依赖，不会安装结果，<code>go install</code>：编译并安装结果</p><ol><li><p>进入hello目录，执行<code>go build</code>命令，会在当前目录下看到一个hello可执行文件，执行<code>./hello</code>查看结果</p></li><li><p>发现go的安装目录，执行<code>go list -f &#39;&#123;&#123;.Target&#125;&#125;&#39;</code>，看到<code>/Users/knight/go/bin/hello</code>，这是我的机器上默认的安装路径</p></li><li><p>修改安装路径，两种方式，如下：</p><pre><code class="go">//方式一//mac 或者linuxexport PATH=$PATH:/path/to/your/install/directory//方式二go env -w GOBIN=/path/to/your/bin</code></pre><p>我这里用方式二设置的目录</p></li><li><p>安装， 执行<code>go install</code>,然后就看到在我们上面设置的目录里面有一个hello的可执行文件了</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Go学习&quot;&gt;&lt;a href=&quot;#Go学习&quot; class=&quot;headerlink&quot; title=&quot;Go学习&quot;&gt;&lt;/a&gt;Go学习&lt;/h1&gt;&lt;p&gt;环境：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：mac&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="go" scheme="https://github/zhuchong6.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://github/zhuchong6.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Long类型有趣的现象</title>
    <link href="https://github/zhuchong6.github.io/2022/01/06/2022-01-06Long%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%8E%B0%E8%B1%A1/"/>
    <id>https://github/zhuchong6.github.io/2022/01/06/2022-01-06Long%E7%B1%BB%E5%9E%8B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%8E%B0%E8%B1%A1/</id>
    <published>2022-01-06T08:55:52.000Z</published>
    <updated>2022-09-29T01:04:32.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天碰到个有趣的问题，简而言之就是Long类型能不能用<code>==</code>来进行比较的问题。</p><p>先说结论，不是完全不行，但是不推荐。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们先明确一个观点，<code>==</code>比较的是地址值，Long&#x3D;&#x3D;Long比较的是两个对象的地址值是否相同。</p><p>我们看下jdk获取Long类型值的源码：</p><pre><code class="java">public static Long valueOf(long l) &#123;  final int offset = 128;  if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache    return LongCache.cache[(int)l + offset];  &#125;  return new Long(l);&#125;private static class LongCache &#123;  private LongCache()&#123;&#125;  static final Long cache[] = new Long[-(-128) + 127 + 1];  static &#123;    for(int i = 0; i &lt; cache.length; i++)      cache[i] = new Long(i - 128);  &#125;&#125;</code></pre><p>可以看到，当值在-128～127之间的时候，用<code>==</code>比较，实际取的缓存地址值，那么地址值当然一样，或者说值一样；但是，当值不在这个范围内，那么就是新建的Long对象，值就不相等了。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><pre><code class="java">public static void main(String[] args) &#123;  Long a= 1L;  Long b = 1L;  System.out.println(a== b);  Long c=128L;  Long d=128L;  System.out.println(c==d);  System.out.println(c.compareTo(d));&#125;//结果truefalse0</code></pre><p>总结，当值在-128-127之间，用&#x3D;&#x3D;也可以，超出就不行。</p><p>不过，避免出错还是推荐<code>compare</code>方法来比较大小。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天碰到个有趣的问题，简而言之就是Long类型能不能用&lt;code&gt;==&lt;/code&gt;来进行比较的问题。&lt;/p&gt;
&lt;p&gt;先说结论，不是完全不行，但是不推荐。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
    <category term="杂记" scheme="https://github/zhuchong6.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://github/zhuchong6.github.io/2021/10/29/2021-10-29%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://github/zhuchong6.github.io/2021/10/29/2021-10-29%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-10-29T07:24:21.000Z</published>
    <updated>2022-09-29T01:04:32.288Z</updated>
    
    <content type="html"><![CDATA[<p>​随着业务发展，系统的越来越复杂，几乎每个公司的系统都会从单体转向分布式，随之而来绕不开的问题就是<code>分布式事务</code>，下面来探讨几种主流的<code>分布式事务</code>解决方案</p><span id="more"></span><h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><p>由于分布式事务方案，无法做到完全的ACID的保证，没有一种完美的方案，能够解决掉所有业务问题。因此在实际应用中，会根据业务的不同特性，选择最适合的分布式事务方案。</p><h2 id="两阶段提交（2PC）-x2F-XA"><a href="#两阶段提交（2PC）-x2F-XA" class="headerlink" title="两阶段提交（2PC）&#x2F;XA"></a>两阶段提交（2PC）&#x2F;XA</h2><p>XA是由X&#x2F;Open组织提出的分布式事务的规范，XA规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如mysql在XA中扮演的是RM角色</p><p>事务流程大致如下：</p><p><img src="/XA.png"></p><p>大致的流程：</p><p>第一阶段（prepare）：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；<br>第二阶段 (commit&#x2F;rollback)：事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。</p><blockquote><p>特点：</p><ul><li>简单易理解，开发容易</li><li>对资源长时间锁定，并发度低</li></ul></blockquote><h2 id="TCC-Try-Confirm-Cancel"><a href="#TCC-Try-Confirm-Cancel" class="headerlink" title="TCC(Try-Confirm-Cancel)"></a>TCC(Try-Confirm-Cancel)</h2><p>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC 事务机制相比于上面介绍的 XA，解决了其几个缺点：</p><ol><li>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li><li>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li><li>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</li></ol><p>TCC<br>Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）<br>Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。<br>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</p><p>在 Try 阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。<br>基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。</p><p>具体实现可以参考：<a href="https://www.cnblogs.com/jajian/p/10014145.html">tcc详解</a></p><p>TCC 需要事务接口提供 try, confirm, cancel 三个接口，提高了编程的复杂性。依赖于业务方来配合提供这样的接口，推行难度大，所以一般不推荐使用这种方式。</p><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章<a href="https://queue.acm.org/detail.cfm?id=1394128">完整方案</a>。</p><p>该方案中会有消息生产者与消费者两个角色，假设系统 订单服务 是消息生产者，支付服务 是消息消费者，其大致流程如下：</p><p><img src="/LocalMessage.png" alt="本地消息表"></p><ol><li>在订单库中引入一张消息表来记录订单消息，即用户下单成功后同时往这张消息表插入一条下单成功的消息，状态为“发送中”。<strong>注意订单逻辑和插入消息表的代码要包裹在一个事务里面，这里保证了本地事务的强一致性</strong>。即订单逻辑和插入消息表的消息组成了一个强一致性的事务，要么同时成功，要么同时失败。</li><li>完成 1）步的逻辑后，此时再向mq的ORDER_QUEUE队列中投递一条下单消息，这条下单消息的内容跟保存在订单库消息表的消息内容一致。</li><li>mq接收到消息后，此时支付服务也监听到这条消息了，此时支付服务处理消费逻辑即开始生成支付凭证。</li><li>支付凭证生成后，再反向向mq投递一条消费成功的消息到ACC_QUEUE队列。</li><li>同时订单服务又来监听这个支付服务消费成功的消息，当订单服务监听到这个消费成功的消息后，此时再将本地消息表的消息状态改为“已发送”。</li><li>流程图中，任意一处崩溃都会导致分布式事务失败，此时并没有改变消息表中状态。因此，我们增加一个消息恢复系统（就是定时任务），来重复投递消息，确保消息能被正确消费。如果，在投递过程中失败，一般设置一个最大的重试次数，超过可以通过短信、钉钉、邮件的方式来进行一个人工的干预，经行一个人为保底</li></ol><blockquote><p>特点：</p><p>建设成本低，实现了可靠消息的传递确保了分布式事务的最终一致性</p><p>本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩；本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的。</p></blockquote><h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><p>通过具有分布式事务消息的能力的消息队列（目前只有rocketmq支持<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">官方文档</a>），来确保分布式事务，具体流程如下：</p><p><img src="/rocketmq.png" alt="事务消息"></p><p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p><ol><li>事务消息发送及提交：</li></ol><p>(1) 发送消息（half消息）。</p><p>(2) 服务端响应消息写入结果。</p><p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><ol start="2"><li>补偿流程：</li></ol><p>(1) 对没有Commit&#x2F;Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”（默认15次，然后就rollback）</p><p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p><p>(3) 根据本地事务状态，重新Commit或者Rollback</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><blockquote><p>开发简单；可以支撑高并发业务</p><p>引入新的组件，系统复杂度增加；消息队列有丢失消息的风险</p></blockquote><h2 id="尽最大努力通知"><a href="#尽最大努力通知" class="headerlink" title="尽最大努力通知"></a>尽最大努力通知</h2><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃</li></ol><blockquote><p>开发简单。</p><p>适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果；不保证一致性。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	随着业务发展，系统的越来越复杂，几乎每个公司的系统都会从单体转向分布式，随之而来绕不开的问题就是&lt;code&gt;分布式事务&lt;/code&gt;，下面来探讨几种主流的&lt;code&gt;分布式事务&lt;/code&gt;解决方案&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://github/zhuchong6.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Class文件结构</title>
    <link href="https://github/zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://github/zhuchong6.github.io/2021/10/21/2021-10-21Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2021-10-21T08:30:39.000Z</published>
    <updated>2022-09-29T01:04:32.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们常说Java是跨平台的语言，主要原因是有JVM。可以说，只要有能运行JVM的平台，Java代码基本可以无缝移植，而跨平台的基石便是Class文件。</p><p><img src="/01.png"></p><p>本文旨在解析Class文件数据结构，加深对jvm的理解。</p><p>环境：</p><blockquote><p>操作系统：win10</p><p>JDK版本：1.8.0_291</p></blockquote><p>本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。</p><span id="more"></span><h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>Class文件是一组以8bit为基础的字节流，多数据项之间严格按照数据紧凑的排列在Class文件中，没有分割符。如果数据项占用超过8bit，那么以<code>Big-Endian</code>方式分割成若干个8bit存储。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F">Big-Endian见wiki</a></p></blockquote><p>根据JVM规定，Class文件采用一种类型C结构体的伪结构体来存储数据，这种结构体中只有两种数据类型：<code>无符号数</code>和<code>表</code></p><ul><li>无符号数：以u1、u2、u4、u8代表1Byte、2Byte、4Byte、8Byte的无符号数，用于描述数字、索引、数量或者按照UTF-8编码构成的字符串</li><li>表:_info结尾，由多个无符号数和其他表构成的复合数据结构，用于描述有层次关系的符合数据结构</li></ul><blockquote><p>1Byte &#x3D; 8bit</p></blockquote><p>下面Class文件结构伪代码:</p><pre><code class="java">ClassFile &#123;    u4             magic;    u2             minor_version;    u2             major_version;    u2             constant_pool_count;    cp_info        constant_pool[constant_pool_count-1];    u2             access_flags;    u2             this_class;    u2             super_class;    u2             interfaces_count;    u2             interfaces[interfaces_count];    u2             fields_count;    field_info     fields[fields_count];    u2             methods_count;    method_info    methods[methods_count];    u2             attributes_count;    attribute_info attributes[attributes_count];&#125;</code></pre><p>属性解释：</p><ul><li><p>magic</p><p>魔数，标识文件类型，值是0xCAFEBABE</p></li><li><p>minor_version,major_version</p><p>major_version：主版本号；minor_version：次版本号。高版本JDK能向下兼容以前的版本的Class文件，不能兼容之后的，例如：JDK1.0.2能支持的版本号为45.0-45.3，不能支持45.65535版本Class文件；JDK1.1.*能支持45.0-45.65535</p></li><li><p>constant_pool_count</p><p>代表常量池容量计数值，这个技术值从1开始，而不是0。假设这个值是10，那么代表常量池有9个常量，索引范围是1-9。而0则是为了满足某些指向常量池索引表达为“不引用任何常量池项”的特定情况</p></li><li><p>constant_pool[]</p><p>代表实际存放常量池的数组，大小是constant_pool_count，索引范围(1-constant_pool_count-1),具体如下图：</p><p><img src="/constant_pool_struct.png" alt="常量池结构"></p><blockquote><p>cp_info的结构</p><p>常量池通用结构：</p><pre><code class="java">cp_info&#123;u1 tag;u1 info[];&#125;</code></pre><p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下:</p><table><thead><tr><th><strong>Constant Type</strong></th><th><strong>Value</strong></th><th>涵义</th></tr></thead><tbody><tr><td>CONSTANT_Class</td><td>7</td><td>类或者接口的全限定名</td></tr><tr><td>CONSTANT_Fieldref</td><td>9</td><td>表示类中的字段</td></tr><tr><td>CONSTANT_Methodref</td><td>10</td><td>表示类中方法</td></tr><tr><td>CONSTANT_InterfaceMethodref</td><td>11</td><td>表示类中实现的接口的方法</td></tr><tr><td>CONSTANT_String</td><td>8</td><td>表示java.lang.String类型的常量对象</td></tr><tr><td>CONSTANT_Integer</td><td>3</td><td>表示4字节(int)的数值常量</td></tr><tr><td>CONSTANT_Float</td><td>4</td><td>表示4字节(float)的数值常量</td></tr><tr><td>CONSTANT_Long</td><td>5</td><td>表示8字节(long)的数值常量</td></tr><tr><td>CONSTANT_Double</td><td>6</td><td>表示8字节(double)的数值常量</td></tr><tr><td>CONSTANT_NameAndType</td><td>12</td><td>表示字段或者方法的名称或者类型</td></tr><tr><td>CONSTANT_Utf8</td><td>1</td><td>表示字符串常量的值</td></tr><tr><td>CONSTANT_MethodHandle</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType</td><td>16</td><td>表示方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic</td><td>18</td><td>表示invokedynamic指令所用到的引导方法(Bootstrap Method)、引导方法使用到动态调用名称（Dynamic Invocation Name）、参数和请求返回类型、以及可选择性附加被称为静态参数（Static Arguments）的常量序列</td></tr></tbody></table><ul><li><strong>CONSTANT_Class_info</strong></li></ul><pre><code>CONSTANT_Class_info&#123;    //值为7    u1 tag;    //指向一个CONSTANT_Utf8_info结构体的索引，这个结构体存储具体的值    u2 name_index;&#125;</code></pre><ul><li><strong>CONSTANT_Fieldref_info，CONSTANT_Methodref_info，CONSTANT_InterfaceMethodref_info</strong></li></ul><pre><code>CONSTANT_Fieldref_info &#123;       //值为9    u1 tag;    //指向CONSTANT_Class_info结构体的索引，类型可以是类也可以是接口    u2 class_index;    //指向一个CONSTANT_NameAndType_info结构体的索引，并且这个结构体中描述符必须是字段描述符    u2 name_and_type_index;&#125;CONSTANT_Methodref_info &#123;       //值为10    u1 tag;    //指向CONSTANT_Class_info结构体的索引，类型必须是类，不可以是接口    u2 class_index;    //指向一个CONSTANT_NameAndType_info结构体的索引，并且这个结构体中描述符必须是方法描述符;如果以&#39;&lt;&#39;(&#39;\u003c&#39;)开头，一定是&lt;init&gt;这个特殊方法，返回值是void。    u2 name_and_type_index;&#125;CONSTANT_InterfaceMethodref_info &#123;       //值为11    u1 tag;    //指向CONSTANT_Class_info结构体的索引，类型必须是接口，不可以是类    u2 class_index;    //指向一个CONSTANT_NameAndType_info结构体的索引，并且这个结构体中描述符必须是方法描述符    u2 name_and_type_index;&#125;</code></pre><ul><li><strong>CONSTANT_String_info</strong></li></ul><pre><code>CONSTANT_String_info &#123;       //值为8    u1 tag;    //指向一个CONSTANT_Utf8_info结构体的索引，这个结构体存储具体的值    u2 string_index;&#125;</code></pre><ul><li><strong>CONSTANT_Integer_info，CONSTANT_Float_info</strong></li></ul><pre><code>CONSTANT_Integer_info &#123;       //值为3    u1 tag;    //存储整数值    u4 bytes;&#125;CONSTANT_Float_info &#123;       //值为4    u1 tag;    //存储浮点值    u4 bytes;&#125;</code></pre><ul><li><strong>CONSTANT_Long_info，CONSTANT_Double_info</strong></li></ul><p>具体可见<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">LONG如何存储</a></p><pre><code>CONSTANT_Long_info &#123;       //值为5    u1 tag;    //高4位    u4 high_bytes;    //低4位    u4 low_bytes;&#125;CONSTANT_Double_info &#123;       //值为6    u1 tag;    u4 high_bytes;    u4 low_bytes;&#125;</code></pre><ul><li><strong>CONSTANT_NameAndType_info</strong></li></ul><pre><code>CONSTANT_NameAndType_info &#123;      //值为12    u1 tag;    //指向一个CONSTANT_Utf8_info结构体的索引,包含特殊方法&lt;init&gt;,或者方法和字段的非全限定名，即短名。    u2 name_index;    //指向一个CONSTANT_Utf8_info结构体的索引,代表字段或者方法    u2 descriptor_index;&#125;</code></pre><ul><li><strong>CONSTANT_Utf8_info</strong></li></ul><pre><code>CONSTANT_Utf8_info &#123;         //值为12    u1 tag;    //长度    u2 length;    //字节数组    u1 bytes[length];&#125;</code></pre><ul><li><strong>CONSTANT_MethodHandle_info</strong></li></ul><pre><code>CONSTANT_MethodHandle_info &#123;      //值为15    u1 tag;    //值在1-9之间，值表示方法句柄的类型及其字节码行为    u1 reference_kind;    //值是常量池的有效索引    //如果reference_kind项的值为1（REF_getField）、2（REF_getStatic）、3（REF_putField）或4（REF_putStatic），那么常量池在reference_index索引处的项必须是CONSTANT_Fieldref_info结构，表示由一个字段创建的方法句柄    //如果reference_kind项的值是5（REF_invokeVirtual）、6（REF_invokeStatic）、7（REF_invokeSpecial）或8（REF_newInvokeSpecial），那么常量池在reference_index索引处的项必须是CONSTANT_Methodref_info结构，表示由类的方法或构造函数创建的方法句柄    //如果reference_kind项的值是9（REF_invokeInterface），那么常量池在reference_index索引处的项必须是CONSTANT_InterfaceMethodref_info结构，表示由接口方法创建的方法句柄    //如果reference_kind项的值是5（REF_invokeVirtual）、6（REF_invokeStatic）、7（REF_invokeSpecial）或9（REF_invokeInterface），那么方法句柄对应的方法不能为实例初始化（）方法或类初始化方法（）    //如果reference_kind项的值是8（REF_newInvokeSpecial），那么方法句柄对应的方法必须为实例初始化&lt;init&gt;    u2 reference_index;&#125; </code></pre><ul><li><strong>CONSTANT_MethodType_info</strong></li></ul><pre><code>CONSTANT_MethodType_info &#123;    //值为16   u1 tag;   //必须是CONSTANT_Utf8_info结构，代表方法的描述符   u2 descriptor_index;&#125;</code></pre><ul><li><strong>CONSTANT_InvokeDynamic_info</strong></li></ul><pre><code>// 表示invokedynamic指令所使用到的引导方法（Bootstrap Method）、引导方法使用到动态调用名称（Dynamic Invocation Name）、参数和请求返回类型、以及可以选择性的附加被称为静态参数（Static Arguments）的常量序列。CONSTANT_InvokeDynamic_info &#123;     //值为18   u1 tag;   //对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引   u2 bootstrap_method_attr_index;   对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_info 结构，表示方法名和方法描述符   u2 name_and_type_index;&#125;</code></pre><p>综上，就是1.8版本jvm字节码部分常量池所有类型，像最后三个有点抽象，暂时先放在一边，等后续我们在详谈</p></blockquote></li><li><p>access_flags</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>适用范围</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明为public，可以从包外访问</td><td>所有类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明为final，不允许有子类</td><td>类</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>调用Invokescial指令对超类方法进行处理</td><td>类和接口</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>声明是接口类型而不是类</td><td>接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>声明是抽象类型，不能被实例化</td><td>接口或抽象类</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明是由编译器生成的，不出现在源码中</td><td>所有类型</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>声明为注解类型</td><td>注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>声明为枚举类型</td><td>枚举</td></tr></tbody></table></li><li><p>this_class</p><p>指向一个CONSTANT_Class_info的常量池索引，代表该类或者接口信息</p></li><li><p>super_class</p><p>如果值是0，那么代表Object类；如果不是0，值为一个指向CONSTANT_Class_info的索引，代表该类的父类</p></li><li><p>interfaces_count</p><p>接口计数器，代表实现接口数量，如果没事实现接口计数器值是0</p></li><li><p>interfaces[]</p><p>接口索引数组，每个索引指向一个CONSTANT_Class_info结构，代表接口信息，按照源码中从左到右排序</p></li><li><p>fields_count</p><p>字段计数器，代表field_info结构的数量</p></li><li><p>fields[]</p><p>field_info的集合，代表类或者接口的完整描述。注意，只包含本身类中的，不包含继承的字段。</p><blockquote><p>field_info结构</p><p>每个字段都是由field_info结构来描述，并且一个类文件中不能有两个字段具有相同的名称和描述符</p><blockquote><p><strong>字段描述符</strong></p><p>字段描述符表示类、实例或局部变量的类型</p><pre><code>FieldDescriptor:    FieldType    FieldType:  BaseType  ObjectType  ArrayType  BaseType:  (one of)  B C D F I J S Z  ObjectType:  L ClassName ;  ArrayType:  [ ComponentType  ComponentType:  FieldType</code></pre><p>下面的表格解释上面的作用</p><table><thead><tr><th>FieldType术语</th><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>有符号的byte类型，-127-128</td></tr><tr><td>C</td><td>char</td><td><a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%A4%9A%E6%96%87%E7%A7%8D%E5%B9%B3%E9%9D%A2/10788078?fr=aladdin">基本多语言平面</a>中的Unicode字符编码点，使用UTF-16编码</td></tr><tr><td>D</td><td>double</td><td>双精度浮点</td></tr><tr><td>F</td><td>float</td><td>单精度浮点</td></tr><tr><td>I</td><td>int</td><td>整数</td></tr><tr><td>J</td><td>long</td><td>长整数</td></tr><tr><td>L ClassName ;</td><td>reference</td><td>类ClassName的实例</td></tr><tr><td>S</td><td>short</td><td>带符号的short类型</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>一维数组，二维数组用[[表示</td></tr></tbody></table></blockquote><p>field_info结构：</p><pre><code>field_info &#123;  u2             access_flags;  u2             name_index;  u2             descriptor_index;  u2             attributes_count;  attribute_info attributes[attributes_count];&#125;</code></pre><p>access_flags:</p><p>​表示字段的访问权限和属性，具体如下表：</p><table><thead><tr><th>名称</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明public，可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>声明privcate，仅能在定义类中使用</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>声明protected，可以在子类中访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>声明static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明final，在对象构造之后，不能直接赋值</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>声明volatile，不能被缓存</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>声明transient，不能由持久化对象管理器写入或者读取</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明synthetic，不存在源码中，表示编译器生成</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>声明为enum的元素</td></tr></tbody></table><p>name_index</p><p>​指向一个CONSTANT_Utf8_info结构的索引，代表一个有效的非全限定名（方法、字段、局部变量和形式参数的名称存储为非限定名称）</p><p>descriptor_index</p><p>​指向一个CONSTANT_Utf8_info结构的索引，代表一个有效的<strong>字段描述符</strong></p><p>attributes_count</p><p>​表示该字段附加属性的数量</p><p>attributes[]</p><p>​表示该字段附加属性列表，每一个项都是一个attribute_info结构，具体见后面attributes部分</p></blockquote></li><li><p>methods_count</p><p>methods_count项的值给出了method_info结构在方法表中的数量</p></li><li><p>methods[]</p><p>method_info结构表示该类或接口类型声明的所有方法，包括实例方法、类方法、实例初始化方法和任何类或接口初始化方法；不包括从父类或者父接口继承的方法。</p><blockquote><p>method_info结构</p><p>每个方法都是有method_info结构描述，一个类文件中的两个方法不能有相同的名称和描述符</p><blockquote><p>方法描述符</p><p>MethodDescriptor:</p><p>​(  {ParameterDescriptor}  )  ReturnDescriptor</p><p>ParameterDescriptor:</p><p>​FieldType</p><p>ReturnDescriptor:</p><p>​FieldType<br>​VoidDescriptor</p><p>VoidDescriptor:</p><p>​v（表示方法不返回任何值）</p><p>方法：Object m(int i, double d, Thread t) {…}</p><p>方法描述符：(IDLjava&#x2F;lang&#x2F;Thread;)Ljava&#x2F;lang&#x2F;Object;</p></blockquote><p>Method_info结构:</p><pre><code>method_info &#123;   u2             access_flags;   u2             name_index;   u2             descriptor_index;   u2             attributes_count;   attribute_info attributes[attributes_count];&#125;</code></pre><p>access_flags:</p><p>​表示方法的访问权限和属性，具体如下表：</p><table><thead><tr><th>名称</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>声明public，可以包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>声明private，只有类内能访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>声明protected,子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>声明static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>声明final，不能被重写</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>声明synchronized，使用时被monitor包裹</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>声明一个桥接方法，由编译器生产</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>声明具有可变数量的参数。</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>声明native，用除了java的其他语言实现</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>声明为abstract;没有提供任何实现。</td></tr><tr><td>ACC_STRICT</td><td>0x0800</td><td>声明strictfp，浮点模式是FP-strict</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>声明synthetic，不存在源码中，表示编译器生成</td></tr></tbody></table><p>name_index</p><p>​指向一个CONSTANT_Utf8_info结构的索引，代表一个有效的非全限定名（方法、字段、局部变量和形式参数的名称存储为非限定名称）</p><p>descriptor_index</p><p>指向一个CONSTANT_Utf8_info结构的索引，代表一个有效的<strong>字段描述符</strong></p><p>attributes_count</p><p>表示该方法附加属性的数量</p><p>attributes[]</p><p>表示该字段附加属性列表，每一个项都是一个attribute_info结构，具体见后面attributes部分</p></blockquote></li><li><p>attributes_count</p><p>attributes数量</p></li><li><p>attributes[]</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7">attribute_info</a>集合，在Class文件，字段表，方法表中都可以携带自己的属性表集合，用以描述某些场景的专用信息，jdk8中一共有23项属性，具体如下：</p><table><thead><tr><th>属性名</th><th>使用位置</th><th>出现版本</th><th>解释</th></tr></thead><tbody><tr><td>ConstantValue</td><td>字段表</td><td>1.0.2</td><td>final关键字定义的常量值</td></tr><tr><td>Code</td><td>方法表</td><td>1.0.2</td><td>Java方法包裹代码编译成的字节码指令，native方法没有</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>6</td><td>在类型检查的验证中使用</td></tr><tr><td>Exceptions</td><td>方法表</td><td>1.0.2</td><td>Exceptions属性指示方法可能抛出哪些已检查异常</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>1.1</td><td>内部类列表</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>5.0</td><td>当且仅当类表示局部类或匿名类时，类必须具有EnclosingMethod属性</td></tr><tr><td>Synthetic</td><td>类、方法表、字段表</td><td>1.1</td><td>标识方法或字段为编译器自动生成</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>5.0</td><td>支持泛型下的方法签名，任何类、接口、初始化方法或者成员的泛型签名如果包含类型变量(Type Variables)或者参数化类型(Parameterized Type),该属性记录泛型签名信息</td></tr><tr><td>SourceFile</td><td>类文件</td><td>1.0.2</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>5.0</td><td>存储额外的调试信息</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>1.0.2</td><td>Java源码行号和字节码指令对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>1.0.2</td><td>方法的局部变量描述，调试期间用于确定局部变量的值</td></tr><tr><td>LocalVariableTypeTable</td><td>Code属性</td><td>5.0</td><td>在方法执行期间，调试器可以使用它来确定给定局部变量的值</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>1.1</td><td>标记类、接口、方法、字段被废弃</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td>5.0</td><td>运行时可见注解</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类、方法表、字段表</td><td>5.0</td><td>运行时不可见注解</td></tr><tr><td>RuntimeVisibleParameterAnnotations</td><td>方法表</td><td>5.0</td><td>运行时可见方法参数注解</td></tr><tr><td>RuntimeInvisibleParameterAnnotations</td><td>方法表</td><td>5.0</td><td>运行时不可见方法参数注解</td></tr><tr><td>RuntimeVisibleTypeAnnotations</td><td>类、方法表、字段表、Code属性</td><td>8</td><td>运行时可见类型注解</td></tr><tr><td>RuntimeInvisibleTypeAnnotations</td><td>类、方法表、字段表、Code属性</td><td>8</td><td>运行时不可见类型注解</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>5.0</td><td>记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>7</td><td>保存invokedynamic指令引用的引导方法说明符</td></tr><tr><td>MethodParameters</td><td>方法表</td><td>8</td><td>记录了关于方法的形式参数的信息，比如它们的名称。</td></tr></tbody></table></li></ul><p>以上，就是本次的全部内容。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/">Oracle JVM规范</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们常说Java是跨平台的语言，主要原因是有JVM。可以说，只要有能运行JVM的平台，Java代码基本可以无缝移植，而跨平台的基石便是Class文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文旨在解析Class文件数据结构，加深对jvm的理解。&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：win10&lt;/p&gt;
&lt;p&gt;JDK版本：1.8.0_291&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://github/zhuchong6.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MVCC-数据库高并发的关键</title>
    <link href="https://github/zhuchong6.github.io/2021/05/12/2021-05-12MVCC-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%85%B3%E9%94%AE/"/>
    <id>https://github/zhuchong6.github.io/2021/05/12/2021-05-12MVCC-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%85%B3%E9%94%AE/</id>
    <published>2021-05-12T11:19:09.000Z</published>
    <updated>2022-09-29T01:04:32.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要介绍InnoDB高并发性能关键技术，MVCC(Muti-Version Concurrency Control)多版本并发控制，意思是基于多版本的并发控制协议，通过版本号机制，避免同一数据在不同事务的锁竞争，而提高读并发。</p><p>环境：</p><blockquote><p>操作系统：macos</p><p>数据库版本：mysql 8.0.23 innodb引擎</p></blockquote><p>本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。</p><span id="more"></span><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h2><p>mysql会为每一行记录生成隐藏列，如下：</p><ol><li><code>DB_TRX_ID</code>:事务ID，是根据事务产生时间顺序递增的独一无二的ID，大小6个字节，特别注意删除被认为是更新，对这条记录有个标志位标记为已删除。</li><li><code>DB_ROLL_PTR</code>:回滚指针，指向改行的回滚段<code>rollback segment</code>，大小为7个字节,通过这个找到之前版本的数据。该行所有旧版本数据，在<code>undo log</code>中通过链表组织。</li><li><code>DB_ROW_ID</code>:行标识，隐藏的单调递增ID，如果没有主键会生成这个当作主键，并以它产生聚簇索引，大小为6字节。</li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>我们要对一条记录进行更改的时候（insert，update，delete），都需要把回滚时所需要的东西记录下来，<code>InnoDB</code>把这些因为回滚而记录的东西称之为<code>undo log</code>。</p><p><code>undo log</code>分为插入<code>undo log</code>和更新<code>undo log</code>（<strong>删除被视为更新</strong>），插入<code>undo log</code>只在事务回滚时需要，事务提交后可以立即删除；更新<code>undo log</code>也可以用来进行一致性读，只有当没有事务的时候才能被丢弃，应为需要这个生产快照进行一致性读取</p><p>每次对记录的改动都会生成一个log，每个log也有<code>DB_ROLL_PTR</code>属性，可以将这些log链接起来，形成一个链表，也就是我们说的版本链，版本链的头节点就是记录最新的值，具体流程如下图：</p><p><img src="/mvcc1.png" alt="插入log"></p><h2 id="READ-VIEW"><a href="#READ-VIEW" class="headerlink" title="READ_VIEW"></a>READ_VIEW</h2><p>什么是 Read View，说白了 Read View 就是事务进行快照读操作的时候生产的读视图 (Read View)。</p><p>它主要包含这几部分：</p><ul><li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃(<strong>未提交</strong>)的读写事务的<code>事务id</code>列表</li><li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</li><li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。 <strong>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</strong></li><li><code>creator_trx_id</code>：表示创建该<code>ReadView</code>的事务的<code>事务id</code>。</li></ul><p>有了READ_VIEW之后，我们就可以遵循以下算法判断我们访问的某个版本(<code>trx_id</code>)是否可见：</p><ol><li><code>trx_id == creator_trx_id</code>，意味着当前事务在访问它自己修改过的记录，所以该版本<strong>可以</strong>被当前事务访问。</li><li><code>trx_id &lt; min_trx_id</code>，表明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，所以该版本<strong>可以</strong>被当前事务访问。</li><li><code>trx_id &gt; max_trx_id</code>，表明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，所以该版本<strong>不可以</strong>被当前事务访问。</li><li><code>min_trx_id &lt; trx_id &lt; max_trx_id</code>，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。<strong>栗子：假设 m_ids&#x3D;[5,6,7,9,12],如果trx_id&#x3D;5，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果trx_id&#x3D;8,说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</strong></li></ol><h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><ul><li>快照读：读取的是快照，默认隔离级别下<code>select</code>查询基本都是快照读</li><li>当前读：读取的是最新的，<code>select lock in share mode</code>、<code>select for update</code>和<code>update/delete/insert</code>都是读最新</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>首先，我们应该明确mvcc只会在两种事物隔离级别起作用，<code>READ COMMITED</code>和<code>REPEATED_READ</code>。</p><p><code>READ COMMITED</code>下，同一事务每个快照读都会生成并获取最新的<strong>READ_VIEW</strong>；<code>REPEATED_READ</code>下，同一个事务中的第一个快照读才会创建<strong>READ_VIEW</strong>，之后的快照读获取的都是同一个<strong>READ_VIEW</strong>。</p><p>如图所示，有如下一个版本链，并且准备执行事务。</p><p><img src="/mvcc2.png" alt="mvcc"></p><ol><li>第一次执行select语句时，由于是快照读，会产生一个<strong>READ_VIEW</strong></li><li>根据<strong>READ_VIEW</strong>从版本链中找到合适的可见版本，这里是age&#x3D;2的版本</li><li>执行update语句，生成age&#x3D;3的版本</li><li>再次执行select语句，这里分两种情况：RR隔离级别，读取的是age&#x3D;2的版本；RC隔离级别，读取的是age&#x3D;3的版本</li></ol><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="RR是如何在RC级的基础上解决不可重复读的？"><a href="#RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="RR是如何在RC级的基础上解决不可重复读的？"></a>RR是如何在RC级的基础上解决不可重复读的？</h3><p>由于RR级别的快照读只会第一次在事务开启时时候生成READ_VIEW，在这个事务内快照读读取的数据都是一样的；RC级别时每次快照读都会重新生成READ_VIEW，所以同一事务下读取的结果不一样，这就是不可重复读。所以，避免不可重复读的方式就是生成READ_VIEW的策略不一样</p><ul><li>RR级别下：</li></ul><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>快照读(无影响)查询金额为500</td><td>快照读(无影响)查询金额为500</td></tr><tr><td>更新金额为400</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>select <code>快照读</code>金额为500</td></tr><tr><td></td><td>select lock in share mode<code>当前读</code>金额为400</td></tr></tbody></table><ul><li>RC级别下：</li></ul><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>开启事务</td><td>开启事务</td></tr><tr><td>快照读(无影响)查询金额为500</td><td>快照读(无影响)查询金额为500</td></tr><tr><td>更新金额为400</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>select <code>快照读</code>金额为400</td></tr><tr><td></td><td>select lock in share mode<code>当前读</code>金额为400</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要介绍InnoDB高并发性能关键技术，MVCC(Muti-Version Concurrency Control)多版本并发控制，意思是基于多版本的并发控制协议，通过版本号机制，避免同一数据在不同事务的锁竞争，而提高读并发。&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：macos&lt;/p&gt;
&lt;p&gt;数据库版本：mysql 8.0.23 innodb引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Innodb锁</title>
    <link href="https://github/zhuchong6.github.io/2021/04/27/2021-04-27Innodb%E9%94%81/"/>
    <id>https://github/zhuchong6.github.io/2021/04/27/2021-04-27Innodb%E9%94%81/</id>
    <published>2021-04-27T11:49:03.000Z</published>
    <updated>2022-09-29T01:04:32.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍InnoDB的锁，主要是什么了解锁的种类，已经为后续研究InnoDB事务打好基础。</p><p>环境：</p><blockquote><p>操作系统：macos</p><p>数据库版本：mysql 8.0.23 innodb引擎</p></blockquote><p>本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。</p><span id="more"></span><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><p>InnoDB主要有以下这几种锁：</p><ul><li><strong>共享锁和独占锁（Shared and Exclusive Locks）</strong></li><li><strong>意向锁（Intention Locks）</strong></li><li><strong>记录锁（Record Locks）</strong></li><li><strong>间隙锁（Gap Locks）</strong></li><li><strong>临键锁（Next-Key Locks等于行锁+间隙锁）</strong></li><li><strong>插入意向锁（Insert Intention Locks）</strong></li><li><strong>自增锁（AUTO-INC Locks）</strong></li><li><strong>空间索引的Predicate Locks （Predicate Locks for Spatial Indexes）</strong></li></ul><p>可以参考下图：</p><p><img src="/lock.png" alt="锁分类"></p><h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><p>都是InnoDB标准行级锁的实现，InnoDB执行行级锁定的方式是，在搜索或扫描表索引时，它会对遇到的索引记录设置共享或排他锁。一次，<strong>行锁实际上是索引记录锁</strong>。</p><ul><li>共享锁（S锁）：允许持有锁的事务读取一行，又叫读锁</li><li>独占锁（X锁）：允许持有锁的事务更新或者删除一行，又叫写锁</li></ul><p>如果，事务T1持有第r行记录的共享锁，那么事务T2对第r行尝试加一个共享锁能够立即执行，即T1和T2都能保持共享锁；如果，事务T2尝试持有r的独占锁，不能被立即执行（必须等T1的共享锁解锁）。</p><p>如果，事物T1持有第r行记录的独占锁，那么事务T2对r上任意一种类型的锁的请求都不能立即被授予。</p><p>案例：</p><p><strong>下面所有案例都是手动提交事务</strong></p><p>共享锁：</p><pre><code class="mysql">##第一次验证共享锁-共享锁begin ;select * from user where id = 1 for share ;##执行完上面语句，在打开一个事务begin ;select * from user where id = 1 for share ;###现象：上面都很快查出来##验证共享锁-独占锁begin ;select * from user where id = 1 for share ;##执行完上面语句，在打开一个事务begin ;select * from user where id = 1 for share ;###现象：上面执行第二个查询的时候，持续一段时间并报错</code></pre><p>独占锁：</p><pre><code class="mysql">##验证独占锁-独占锁begin ;select * from user where id = 1 for update ;##执行完上面语句，在打开一个事务begin ;update user set name=1 where id=1;##现象：上面执行第二个查询的时候，持续一段时间并报错##验证独占锁-共享锁begin ;select * from user where id = 1 for update ;##执行完上面语句，在打开一个事务begin ;select * from user where id = 1 for share ;###现象：上面执行第二个查询的时候，持续一段时间并报错</code></pre><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>是表锁，不会锁表，只是一个标记，目的是加速事务中是否有行级锁的判定，具体介绍如下：</p><h4 id="mysql中有表锁"><a href="#mysql中有表锁" class="headerlink" title="mysql中有表锁"></a>mysql中有表锁</h4><p><code>LOCK TABLES mytable READ;</code>用读锁锁表，会阻塞其他事务修改表数据</p><p><code>LOCK TABLES mytable WRITE;</code> 用写锁锁表，会阻塞其他事务读和写</p><h4 id="InnoDB支持行级锁"><a href="#InnoDB支持行级锁" class="headerlink" title="InnoDB支持行级锁"></a>InnoDB支持行级锁</h4><p>如上面所述，行锁分为<code>X</code>和<code>S</code>锁。</p><h4 id="意向锁来源"><a href="#意向锁来源" class="headerlink" title="意向锁来源"></a>意向锁来源</h4><p>当表级锁和行级锁并存时，假如事务A用行锁<code>S锁</code>锁住表中的一行，那么这一行只能读不能写。</p><p>之后，事务B申请表锁的<code>X</code>锁，如果B申请成功，理论上可以修改表中任意一行，与A的行锁冲突；那么只能让B不能申请成功，必须先判断表中的每一行是否已被行锁<code>X</code>锁住，要扫描整个表。如果说没有行锁呢？是不是就白白的扫了一次整表，这样效率不高。</p><p>因此，意向锁诞生了。</p><p>在意向锁存在情况下，事务A必须先申请表的意向共享锁<code>IS</code>，成功后再申请一行的行锁(S)；在意向锁存在的情况下，事务B在申请表锁<code>X</code>锁的时候，会受到共享意向锁<code>IS</code>锁的阻塞,就不必在扫一次全表就可以判断能不能申请成功了。</p><h4 id="意向锁的加锁策略"><a href="#意向锁的加锁策略" class="headerlink" title="意向锁的加锁策略"></a>意向锁的加锁策略</h4><ul><li>在事务获得表中一行的共享锁之前，它必须首先获得表上的IS锁或更强的锁</li><li>在事务获得表中一行的排他锁之前，它必须首先获得表上的IX锁</li></ul><h4 id="意向锁兼容性"><a href="#意向锁兼容性" class="headerlink" title="意向锁兼容性"></a>意向锁兼容性</h4><table><thead><tr><th align="left"></th><th align="left">X</th><th align="left">IX</th><th align="left">S</th><th align="left">IS</th></tr></thead><tbody><tr><td align="left">X</td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Conflict</td></tr><tr><td align="left">IX</td><td align="left">Conflict</td><td align="left">Compatible</td><td align="left">Conflict</td><td align="left">Compatible</td></tr><tr><td align="left">S</td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Compatible</td><td align="left">Compatible</td></tr><tr><td align="left">IS</td><td align="left">Conflict</td><td align="left">Conflict</td><td align="left">Compatible</td><td align="left">Compatible</td></tr></tbody></table><p>如上表，这个是官网的表格，看完会有个问题为什么IX和X会冲突，那么任意两个写操做，即使不同行也会死锁，其实官方文档说的很清楚，上述表格是<strong>表级锁类型</strong>的兼容<code>Table-level lock type compatibility is summarized in the following matrix</code>。所以，不要和上面的<strong>行级锁</strong>的X锁弄混。</p><h3 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h3><p>记录锁是索引上的锁，总是锁定索引记录而不是实际数据。</p><p>如果没有创建索引，InnoDB会创建一个隐藏的聚集索引，并用这个索引来锁定记录，具体可以参考之前InnoDB索引详解的文章</p><blockquote><p>例如：</p><p>SELECT c1 FROM t WHERE c1 &#x3D; 10 FOR UPDATE;</p><p>会在索引c1&#x3D;10上开锁，防止其他事物增、删、改</p></blockquote><h3 id="间隙锁（Gap-Locks"><a href="#间隙锁（Gap-Locks" class="headerlink" title="间隙锁（Gap Locks)"></a>间隙锁（Gap Locks)</h3><p>间隙锁是对索引记录之间间隙的锁，或者是第一个索引记录的之前的，或最后一个索引记录之后，作用是防止间隔中被其他记录插入</p><p>栗子：</p><p><code>select * from user where id between 11 an 20 </code>,在id属性上加间隙锁，那么间隙锁的范围为：</p><pre><code class="shell">(-∞,11),(10,20),(11,+∞),</code></pre><p>以下条件都会产生间隙锁(<strong>RR事务隔离级别下</strong>)：</p><ol><li>使用普通索引</li><li>使用多列唯一索引</li><li>使用唯一索引锁定多条记录</li></ol><p>对于使用唯一索引锁定行以搜索唯一行语句，不需要间隙锁；如果没有索引或者有一个非唯一索引，语句会锁定前面的间隙，例如：</p><p><code>select * from user where id=3</code>,如果id上加了唯一索引，就只会产生记录锁，不会产生间隙锁；如果，id上没有索引或者不是唯一索引，那么会加上间隙锁，锁定(-∞,3)这个间隙</p><h3 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h3><p><code>next-key locks</code>是索引记录上记录锁和间隙锁的组合，作用是防止幻读(配合mvcc机制)。</p><p>假设索引包含值10、11、13和20。此索引可能的next-key锁包括以下时间间隔，其中圆括号表示不包含时间间隔端点，方括号表示包含端点：</p><pre><code class="shell">(-∞,10],(10,11],(11,13],(13,20],(20,+∞],</code></pre><h3 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h3><p>插入意向锁是插入操作之前，由插入操作设置的一种<strong>间隙锁</strong>。此锁表示插入的意图，即如果插入到同一索引间隙中的多个事务没有插入到间隙中的同一位置，则它们不需要等待彼此。假设存在值为4和7的索引记录。分别尝试插入值5和6的单独事务，在获得插入行的独占锁之前，每个事务都使用插入意图锁锁定4和7之间的间隙，但不会相互阻止，因为这些行不冲突。</p><p>以上，就是InnoDB常用的锁,大部分参考的是官方文档<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">mysql锁</a>。有不同见解的，可以随时邮件交流！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要介绍InnoDB的锁，主要是什么了解锁的种类，已经为后续研究InnoDB事务打好基础。&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：macos&lt;/p&gt;
&lt;p&gt;数据库版本：mysql 8.0.23 innodb引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>项目中用到的设计模式-工厂模式</title>
    <link href="https://github/zhuchong6.github.io/2021/04/25/2021-04-25%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github/zhuchong6.github.io/2021/04/25/2021-04-25%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-25T10:55:10.000Z</published>
    <updated>2022-09-29T01:04:32.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们项目是一个电商项目，我被分配到商品模块的开发任务。其中，涉及到创建商品这个功能，第一个版本比较简单就只有单纯的商品，我的实现也非常简单，直接new一个对象然后设置值就行。但是，后来因为业务需求，各个种类的商品，各个功能的商品逐渐加入到版本迭代中，如果还是这么简单粗暴的处理方式其实也行，但是由于不断修改原始代码增加了犯错的几率，也让测试小伙伴多次重复测试，降低效率。</p><p>这个时候，我就意识到了问题的严重性，决定重构代码。</p><span id="more"></span><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>第一个版本比较简单，具体可以看下面</p><pre><code class="java">public class Product&#123;  String name;&#125;public class ProductA extends Product&#123;  //轮播图  String[] imgs;&#125;public class ProductB extends Product&#123;  //轮播视频  String[] videos;&#125;public class ProductFactory&#123;  pubic static Product produce(int type)&#123;      if(type ==1) new ProductA();    if(type ==2) new ProductB();    return null;  &#125;&#125;</code></pre><p>优点：</p><ul><li>这个模式优点是将各个不同商品分开，逻辑分离，老代码不做更改，新代码只需继承<code>Product</code>，比较容易实现</li></ul><p>缺点：</p><ul><li><p>如果说我在增加一个<code>虚拟商品（比如积分卡）/实物商品（比如手机）</code>的维度，如果只是增加一个属性字段的话，又会陷入没有使用设计模式之前的困境(可以参考下面)，会有大量重复代码，这个设计模式就没有意义</p><pre><code class="java">if(type ==1)&#123;  //重复代码  if(&quot;纬度&quot;== 虚拟) ...;  if(&quot;纬度&quot;== 实体) ...;&#125;if(type ==2)&#123;  if(&quot;纬度&quot;== 虚拟) ...;  if(&quot;纬度&quot;== 实体) ...;&#125;</code></pre></li></ul><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>如果增加了<code>维度</code>我们该怎么办？</p><p>简单，我们可以对工厂抽象一层分为<code>实体工厂/虚拟工厂</code>专门用来处理维度属性，具体实现如下：</p><pre><code class="java">//商品基类public class Product&#123;  String name;&#125;//虚拟商品public class ProductXuni extends Product&#123;  //轮播图  String[] imgs;&#125;//实体商品public class ProductShiti extends Product&#123;  //轮播视频  String[] videos;&#125;//生产不同商品的工厂的抽象类public interface AbstractFactory&#123;  Product produce();&#125;//虚拟工厂public class XuniFactory implements AbstractFactory&#123;  Product produce()&#123;    return new ProductXuni();  &#125;&#125;//实体工厂public class ShitiFactory implements AbstractFactory&#123;  Product produce()&#123;    return new ProductShiti();  &#125;&#125;//这样省略了大量的重复代码public class Demo &#123;    public static void main(String[] arg) &#123;        AbstractFactory xuniF = new XuniFactory();        AbstractFactory shitiF = new ShitiFactory();        xuniF.produce(); //虚拟商品        shitiF.produce(); //实体商品    &#125;&#125;</code></pre><p>这样看来，好像是完美的解决了目前的问题。但是，产品经理的需求是不断进化的。他又提出一个需求，我们现在创建的都是商品(这里特指自己平台的)，下个版本要将我们的<code>商品、赠品、地推物料、三方商品...</code>这个几个分类全部整合到一起。</p><p><strong>SHIT！！！</strong></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>没办法，生活还要继续。上面的模式生产的都是一类产品，虽然分成多个维度但是还是属于商品这一个大类下面，如果想新建一个分类（比如：地推物料、淘宝商品、京东商品…）最简单粗暴的方式就是每一个分类就将上面的工厂方法复制一份（实际上前两次我就是这么干的😄），但是会带来大量重复代码—cv是真的爽</p><p>于是，我决定采用抽象工厂方法将代码进行重构，具体实现如下：</p><pre><code class="java">public interface Item &#123;    Item produce();&#125;//商品public class Product implements Item&#123;        public Product() &#123;        produce();    &#125;    public Item produce()&#123;      return new Product();    &#125;&#125;//淘宝商品public class TBProduct implements Item&#123;    public TBProduct() &#123;        produce();    &#125;        public Item produce()&#123;      return new TBProduct();    &#125;&#125;//抽象工厂public interface AbstractFactory&#123;        Item produce();&#125;//商品工厂public class ProductFactory implements AbstractFactory()&#123;  public Product produce() &#123;          return new Product();  &#125;&#125;//淘宝商品工厂public class TBProductFactory implements AbstractFactory()&#123;  public TBProduct produce() &#123;          return new TBProduct();  &#125;&#125;public class Client &#123;   public static void main(String[] args) &#123;     //生产商品     AbstractFactory productF = new ProductFactory();     Product keyboard = productF.produce();             //生产淘宝商品     AbstractFactory tabaoF = new TBProductFactory();     TBProduct keyboard = tabaoF.produce();   &#125;&#125;</code></pre><p>咋看一下好像解决了问题，我们以后增加JD商品的时候只需要在增加一个工厂，一个产品就行了。但是，有个问题。比如说，我想要在淘宝工厂方法里面在增加一个动作，叫<code>destroy()</code>。那么，所有的工厂都会重写这个方法，改动非常之大。这个问题，也是抽象工厂模式的缺陷。对此，我又增加了一层抽像来解决这个问题，具体如下：</p><pre><code class="java">//抽象工厂public interface AbstractFactory&#123;        Item produce();    Item destroy();&#125;//抽象工厂基础类public abstract class BaseAbstractFactory implements AbstractFactory&#123;        public Item produce() &#123;        return null;    &#125;      //默认实现      public Item destroy() &#123;        return null;    &#125;&#125;//商品工厂public class ProductFactory extends BaseAbstractFactory&#123;&#125;//淘宝商品public class TBProductFactory extends BaseAbstractFactory&#123;&#125;</code></pre><p>以上，通过增加一个基础抽象类，默认实现抽象工厂的方法，后面的实际工厂继承这个类来根据实际情况选择是否重写，算是比较完美的重构了我们当前的代码。</p><h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>经过这一次的代码重构，我越发觉得以前写的代码是真的垃圾，只是无脑的将业务逻辑进行堆砌，耦合及其严重，导致很多时候牵一发而动全身。看来，设计模式是真的很有必要好好学习，当谨记！！！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们项目是一个电商项目，我被分配到商品模块的开发任务。其中，涉及到创建商品这个功能，第一个版本比较简单就只有单纯的商品，我的实现也非常简单，直接new一个对象然后设置值就行。但是，后来因为业务需求，各个种类的商品，各个功能的商品逐渐加入到版本迭代中，如果还是这么简单粗暴的处理方式其实也行，但是由于不断修改原始代码增加了犯错的几率，也让测试小伙伴多次重复测试，降低效率。&lt;/p&gt;
&lt;p&gt;这个时候，我就意识到了问题的严重性，决定重构代码。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB索引详解</title>
    <link href="https://github/zhuchong6.github.io/2021/04/18/2021-04-18mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github/zhuchong6.github.io/2021/04/18/2021-04-18mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-18T11:16:35.000Z</published>
    <updated>2022-09-29T01:04:32.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB索引详解"><a href="#InnoDB索引详解" class="headerlink" title="InnoDB索引详解"></a>InnoDB索引详解</h1><p>环境：</p><blockquote><p>操作系统：macos</p><p>数据库版本：mysql 8.0.23 innodb引擎</p></blockquote><p>本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。</p><span id="more"></span><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>大家应该都有用过字典，我们查字典的时候有好几种方式。我这里拿拼音的方式举例，比如说我要查<code>朱</code>这个字，首先要找到z去字典拼音目录里面先找z，然后在找zhu这个拼音，最后通过后面的页码数找到<code>朱</code>的释义。这里，如果把字典比作数据库，那么拼音目录就是所谓的<code>索引</code>。</p><h2 id="索引有什么用？"><a href="#索引有什么用？" class="headerlink" title="索引有什么用？"></a>索引有什么用？</h2><p>还是拿刚才查字典的动作举例，如果没有拼音目录，我们想找到<code>朱</code>字就只能一个个的去翻字典了，很慢。所以，明白没，索引作用就是加快查询的速度的。</p><p>自此，我们可以给索引下一个定义了：</p><blockquote><p>索引是一种数据结构，可以用来加快查询速度</p></blockquote><h2 id="索引的物理结构"><a href="#索引的物理结构" class="headerlink" title="索引的物理结构"></a>索引的物理结构</h2><p>由于，我平时用mysql比较多，就以mysql数据库，innodb引擎来举例，聊下mysql的索引设计。根据官方文档，索引底层的数据结构是有B+树实现的，大概的结构如下图：</p><p><img src="/a.png" alt="B+树"></p><p>我们可以看到，实际存放数据的地方是最下面红色部分，红色部分中id与蓝色id重复，我们是先找到id，才能找到数据。那么id是什么？id代表<code>聚簇索引（cluster index）</code>。根据官方文档的说法，每次创建一张innodb引擎的表时，都会有一个特殊的索引，称之为聚簇索引，用于存储行数据。<strong>通常聚簇索引和主键等同，但是，如果你没有定义主键，那么就选第一个非空的唯一索引作为聚簇索引；如果还是没有的话，那么就会生成一个隐藏的聚簇索引叫<code>GEN_CLUST_INDEX</code>,这个id是一个6byte单调自增的数</strong></p><blockquote><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">mysql聚簇索引</a></p></blockquote><p>这里简述下数据库查询流程，假设我们有一条这样的sql<code>select * from user where id=13</code>，由于id&#x3D;13，那么12&lt;13&lt;14那么就做左边的树下找到<code>id=13</code>的指向实际存储数据指针，再找到数据，就是这么一个简单的流程,具体如图：</p><p><img src="/b.png" alt="查询流程"></p><p>实际使用中，我们不一定每次都用聚簇索引来查询，还会使用其他索引来辅助查询。这个时候，就会用到非聚簇索引，官方称之为<code>二级索引</code>。二级索引的查询流程构建在聚簇索引之上的，假设我们的sql是&#96;&#96;select * from user where name&#x3D;a&#96;，具体执行流程如下：</p><p><img src="/c.png" alt="二级索引流程"></p><p>可以看出，二级索引第一次查询查的是表的聚簇索引，然后在通过聚簇索引反查用户的记录，这个过程被称作<strong>回表</strong>。如果，我查询结果只需要name和id两个字段的话，但是使用<code>select *</code>查询所有字段触发<strong>回表</strong>性能就很差。但是，如果使用<code>select name, id</code>只查需要的字段就在第一次查询时查到需要的字段，不会再进行第二次查询过程，提升了查询效率，这个叫<strong>索引覆盖</strong>。这就是为什么有的sql优化建议查询只需要查需要的字段，不止网络开销，还有这个方面的考量。</p><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p><strong>组合索引</strong>我个人总是和聚簇索引搞混，但是其实是二级索引。他的结构和上面的差不多，只是是由多个字段组成，具体结构如下：</p><p><img src="/d.png" alt="组合索引"></p><p>组合索引是先按照第一个索引字段查找，然后第一个字段相同按照第二个字段查找，这也就是为什么组合索引会有<strong>最左匹配原则</strong>这个东西。</p><h2 id="一些索引的问题"><a href="#一些索引的问题" class="headerlink" title="一些索引的问题"></a>一些索引的问题</h2><h3 id="NULL不走索引？"><a href="#NULL不走索引？" class="headerlink" title="NULL不走索引？"></a>NULL不走索引？</h3><p>有很多博文说NULL不走索引，所以不能让字段为NULL。这个说法不准确，在我当前环境中，NULL是能够走索引的,结果如下：</p><pre><code class="sql">explain select * from user where name is NULL;</code></pre><p><img src="/e.png" alt="e"></p><p>可以看出NULL是走索引的，但是，还是不推荐使用NULL，因为会使索引、索引统计和值更加复杂，并且需要额外一个字节的存储空间。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;InnoDB索引详解&quot;&gt;&lt;a href=&quot;#InnoDB索引详解&quot; class=&quot;headerlink&quot; title=&quot;InnoDB索引详解&quot;&gt;&lt;/a&gt;InnoDB索引详解&lt;/h1&gt;&lt;p&gt;环境：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：macos&lt;/p&gt;
&lt;p&gt;数据库版本：mysql 8.0.23 innodb引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文所有内容都是基于以上环境的，如果有异议的地方欢迎邮件交流。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql排序后union顺序错乱🤪</title>
    <link href="https://github/zhuchong6.github.io/2021/04/10/2021-04-10mysql%E6%8E%92%E5%BA%8F%E5%90%8Eunion%E9%A1%BA%E5%BA%8F%E9%94%99%E4%B9%B1/"/>
    <id>https://github/zhuchong6.github.io/2021/04/10/2021-04-10mysql%E6%8E%92%E5%BA%8F%E5%90%8Eunion%E9%A1%BA%E5%BA%8F%E9%94%99%E4%B9%B1/</id>
    <published>2021-04-10T11:26:27.000Z</published>
    <updated>2022-09-29T01:04:32.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次sql排序后union-all导致的排序错乱"><a href="#记一次sql排序后union-all导致的排序错乱" class="headerlink" title="记一次sql排序后union all导致的排序错乱"></a>记一次sql排序后union all导致的排序错乱</h1><h3 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h3><blockquote><p>操作系统:macOS</p><p>Mysql:8</p></blockquote><h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><p>业务中需要对查询结果进行时间倒序排列，然后将几个查询子集合并，sql如下：</p><pre><code class="mysql">select distinct tmp.user_id          as userId,                tmp.real_name        as realName,                tmp.mobile           as mobile,                tmp.register_time,                tmp.sourcefrom ((select user_id, real_name, mobile, register_time, &#39;直属粉丝&#39; as source from user where superior_id = ?1)      union all      (select user_id, real_name, mobile, register_time, &#39;间推粉丝&#39; as source       from user       where superior_id in (select user_id from user where superior_id = ?1)) ) as tmp</code></pre><span id="more"></span><p>业务中需要按照以下顺序进行排序：</p><blockquote><table><thead><tr><th>Source</th><th>registerTime</th></tr></thead><tbody><tr><td>直属粉丝</td><td>2020-10-02 00:00:00</td></tr><tr><td>直属粉丝</td><td>2020-10-01 00:00:00</td></tr><tr><td>间推粉丝</td><td>2020-11-02 00:00:00</td></tr><tr><td>间推粉丝</td><td>2020-11-01 00:00:00</td></tr></tbody></table></blockquote><p>我第一个想法就是分别在两个子查询语句中查询后按照时间排讯，但是执行后发现顺序是错乱的。原因是，<code>order by</code>要比<code>union all</code>执行级别低，一旦两个关键字同时出现，会先执行<code>union</code>，在执行<code>order by</code></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>由上面想要的结果，我们可以知道需要进行source排序和register倒排，那么解决方案就很明白了，如下：</p><pre><code class="mysql">select distinct tmp.user_id          as userId,                tmp.real_name        as realName,                tmp.mobile           as mobile,                tmp.register_time,                tmp.od,                tmp.sourcefrom ((select user_id, real_name, mobile, register_time, &#39;直属粉丝&#39; as source, 0 as od from user where superior_id = ?1)      union all      (select user_id, real_name, mobile, register_time, &#39;间推粉丝&#39; as source, 1 as od       from user       where superior_id in (select user_id from user where superior_id = ?1)) ) as tmporder by  tmp.od, tmp.register_time desc;</code></pre><p>比之前多增加了一个od字段用于source的排序，register_time用于时间排序,可以避免乱序问题。</p><p>由于这个问题还花了点时间，特此记录下！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;记一次sql排序后union-all导致的排序错乱&quot;&gt;&lt;a href=&quot;#记一次sql排序后union-all导致的排序错乱&quot; class=&quot;headerlink&quot; title=&quot;记一次sql排序后union all导致的排序错乱&quot;&gt;&lt;/a&gt;记一次sql排序后union all导致的排序错乱&lt;/h1&gt;&lt;h3 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;操作系统:macOS&lt;/p&gt;
&lt;p&gt;Mysql:8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题重现&quot;&gt;&lt;a href=&quot;#问题重现&quot; class=&quot;headerlink&quot; title=&quot;问题重现&quot;&gt;&lt;/a&gt;问题重现&lt;/h3&gt;&lt;p&gt;业务中需要对查询结果进行时间倒序排列，然后将几个查询子集合并，sql如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;mysql&quot;&gt;select distinct tmp.user_id          as userId,
                tmp.real_name        as realName,
                tmp.mobile           as mobile,
                tmp.register_time,
                tmp.source
from ((select user_id, real_name, mobile, register_time, &amp;#39;直属粉丝&amp;#39; as source from user where superior_id = ?1)
      union all
      (select user_id, real_name, mobile, register_time, &amp;#39;间推粉丝&amp;#39; as source
       from user
       where superior_id in (select user_id from user where superior_id = ?1)) ) as tmp
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://github/zhuchong6.github.io/tags/Mysql/"/>
    
    <category term="杂记" scheme="https://github/zhuchong6.github.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>springboot整合ELK实现日志收集</title>
    <link href="https://github/zhuchong6.github.io/2021/04/04/2021-04-05ELK%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>https://github/zhuchong6.github.io/2021/04/04/2021-04-05ELK%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-04T18:08:06.000Z</published>
    <updated>2022-09-29T01:04:32.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot应用整合ELK实现日志收集"><a href="#SpringBoot应用整合ELK实现日志收集" class="headerlink" title="SpringBoot应用整合ELK实现日志收集"></a>SpringBoot应用整合ELK实现日志收集</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>ELK即Elasticsearch（<strong>后面简称ES</strong>）、Logstash、Kibana这三个组件，这三个组件配合起来可以搭建线上的日志系统，本文主要讲述如何使用ELK来收集springboot项目的日志</p><h2 id="ELK各个组件的作用"><a href="#ELK各个组件的作用" class="headerlink" title="ELK各个组件的作用"></a>ELK各个组件的作用</h2><ul><li>Elasticsearch：用于存储收集的日志</li><li>Logstash：用于收集日志，SpringBoot应用整合了Logstash以后会把日志发送给Logstash,Logstash再把日志转发给Elasticsearch</li><li>Kibana：通过提供web端可视化界面来查看日志</li></ul><span id="more"></span><p>具体流程可，大致如下图：</p><p><img src="/a.png" alt="ELK流程图"></p><h2 id="使用Docker-Compose搭建ELK环境"><a href="#使用Docker-Compose搭建ELK环境" class="headerlink" title="使用Docker Compose搭建ELK环境"></a>使用Docker Compose搭建ELK环境</h2><h3 id="下载Docker镜像"><a href="#下载Docker镜像" class="headerlink" title="下载Docker镜像"></a>下载Docker镜像</h3><pre><code class="dockerfile">docker pull elasticsearch:7.12.0docker pull logstash:7.12.0docker pull kibana:7.12.0</code></pre><p>注意⚠️：这里一定要指定镜像版本，不然下载的是两年前的版本</p><h3 id="搭建Elasticsearch集群"><a href="#搭建Elasticsearch集群" class="headerlink" title="搭建Elasticsearch集群"></a>搭建Elasticsearch集群</h3><p>这里，我是为了其他的用途搭建的是一个集群，你们也可以选这一个单机的ES，具体步骤如下：</p><ol><li><p>创建一个docker-compose文件</p><pre><code class="bash">vim /Users/mac/Environments/docker/es/es-compose.yml</code></pre></li><li><p>写入配置</p><pre><code class="dockerfile">version: &#39;2.2&#39;services:  es01:    image: elasticsearch:7.12.0    container_name: es01    environment:      - node.name=es01      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es02,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data01:/usr/share/elasticsearch/data    ports:      - 9200:9200    networks:      - elastic  es02:    image: elasticsearch:7.12.0    container_name: es02    environment:      - node.name=es02      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es03      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data02:/usr/share/elasticsearch/data    networks:      - elastic  es03:    image: elasticsearch:7.12.0    container_name: es03    environment:      - node.name=es03      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es02      - cluster.initial_master_nodes=es01,es02,es03      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    ulimits:      memlock:        soft: -1        hard: -1    volumes:      - data03:/usr/share/elasticsearch/data    networks:      - elastic  # kibana:  #   image: kibana:7.12.0  #   container_name: kibana  #   ports:  #     - 5611:5601  #   depends_on:  #     - es01    #     - es02  #     - es03  #   environment:  #     SERVER_NAME: kibana  #     ELASTICSEARCH_HOSTS: http://es01:9200  #     #ELASTICSEARCH_URL: http://es01:9200  #   networks:  #     - elastic    # logstash:  #   image: logstash:7.12.0  #   container_name: logstash  #   volumes:  #     - ./logstash-springboot.conf:/usr/share/logstash/pipeline/logstash.conf #挂载logstash的配置文件  #   depends_on:  #     - es01  #es节点启动之后在启动   #     - es02  #     - es03  #   ports:  #     - 4560:4560  #   networks:  #     - elastic      volumes:  data01:    driver: local  data02:    driver: local  data03:    driver: local networks:  elastic:    driver: bridge</code></pre></li><li><p>执行<code>docker-compose -f es-compose.yml up -d</code>,使用<code>docker ps</code>命令查看是否启动成功或者访问<a href="http://localhost:9200/_cat/health?v">http://localhost:9200/_cat&#x2F;health?v</a>看是否有结果。如果docker是刚下载的话没有进行特殊配置的话，应该会出现，一开始出现3个节点，然后迅速挂掉几个现象。这是因为es集群占用内存太大，内存不够会杀掉应用，官网上推荐的是4g内存（内存不够跑单节点就行了），我们可以修改docker配置，给他更大内存，如图所示：</p><p><img src="/b.png" alt="修改docker内存"></p><p>修改完成，执行<code>docker-compose -f es-compose.yml down -v</code>关闭容器，重复步骤3</p></li></ol><h3 id="搭建Kibana"><a href="#搭建Kibana" class="headerlink" title="搭建Kibana"></a>搭建Kibana</h3><p>将上面<code>es-compose.yml</code>中kibana相关配置打开，重启。访问<a href="http://localhost:5611/">http://localhost:5611/</a>,会出现kibana的ui界面</p><h3 id="搭建Logstash"><a href="#搭建Logstash" class="headerlink" title="搭建Logstash"></a>搭建Logstash</h3><p><code>es-compose.yml</code>同级目录下，创建一个文件，文件名称是<code>logstash-springboot.conf</code>,然后填入如下内容：</p><pre><code>input &#123;  tcp &#123;    mode =&gt; &quot;server&quot;    host =&gt; &quot;0.0.0.0&quot;    port =&gt; 4560    codec =&gt; json_lines  &#125;&#125;output &#123;  elasticsearch &#123;    hosts =&gt; &quot;es01:9200&quot;    index =&gt; &quot;springboot-logstash-%&#123;+YYYY.MM.dd&#125;&quot;  &#125;&#125;</code></pre><p>然后类似上面的，打开<code>es-compose.yml</code>Logstash配置，并重启。至此，ELK已经搭建完成</p><h2 id="在SpringBoot应用中集成Logstash"><a href="#在SpringBoot应用中集成Logstash" class="headerlink" title="在SpringBoot应用中集成Logstash"></a>在SpringBoot应用中集成Logstash</h2><ol><li><p>创建一个springboot应用，在pom文件中引入依赖文件</p><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/net.logstash.logback/logstash-logback-encoder --&gt;&lt;dependency&gt;  &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;  &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;  &lt;version&gt;6.6&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>在resouce目录下添加一个文件，文件名称为logback-spring.xml，作用是将logback的日志输出到Logstash中去，文件内容如下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration&gt;&lt;configuration&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot;/&gt;    &lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot;/&gt;    &lt;!--应用名称--&gt;    &lt;property name=&quot;APP_NAME&quot; value=&quot;mall-admin&quot;/&gt;    &lt;!--日志文件保存路径--&gt;    &lt;property name=&quot;LOG_FILE_PATH&quot; value=&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/logs&#125;&quot;/&gt;    &lt;contextName&gt;$&#123;APP_NAME&#125;&lt;/contextName&gt;    &lt;!--每天记录日志到文件appender--&gt;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;LOG_FILE_PATH&#125;/$&#123;APP_NAME&#125;-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;            &lt;maxHistory&gt;30&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;encoder&gt;            &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!--输出到logstash的appender--&gt;    &lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;        &lt;!--可以访问的logstash日志收集端口,填logstash的地址端口--&gt;        &lt;destination&gt;localhost:4560&lt;/destination&gt;        &lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;/&gt;    &lt;/appender&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;        &lt;appender-ref ref=&quot;LOGSTASH&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre></li><li><p>启动springboot应用，访问下有日志输出的接口，然后去Kibana中查看</p></li></ol><h2 id="在Kibana中查看日志"><a href="#在Kibana中查看日志" class="headerlink" title="在Kibana中查看日志"></a>在Kibana中查看日志</h2><h3 id="创建index-pattern"><a href="#创建index-pattern" class="headerlink" title="创建index  pattern"></a>创建index  pattern</h3><p><img src="/d.png"></p><p><img src="/e.png"></p><p><img src="/f.png"></p><h3 id="查看收集日志"><a href="#查看收集日志" class="headerlink" title="查看收集日志"></a>查看收集日志</h3><p><img src="/g.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>搭建了ELK日志收集系统之后，我们如果要查看SpringBoot应用的日志信息，就不需要查看日志文件了，直接在Kibana中查看即可。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SpringBoot应用整合ELK实现日志收集&quot;&gt;&lt;a href=&quot;#SpringBoot应用整合ELK实现日志收集&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot应用整合ELK实现日志收集&quot;&gt;&lt;/a&gt;SpringBoot应用整合ELK实现日志收集&lt;/h1&gt;&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;ELK即Elasticsearch（&lt;strong&gt;后面简称ES&lt;/strong&gt;）、Logstash、Kibana这三个组件，这三个组件配合起来可以搭建线上的日志系统，本文主要讲述如何使用ELK来收集springboot项目的日志&lt;/p&gt;
&lt;h2 id=&quot;ELK各个组件的作用&quot;&gt;&lt;a href=&quot;#ELK各个组件的作用&quot; class=&quot;headerlink&quot; title=&quot;ELK各个组件的作用&quot;&gt;&lt;/a&gt;ELK各个组件的作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Elasticsearch：用于存储收集的日志&lt;/li&gt;
&lt;li&gt;Logstash：用于收集日志，SpringBoot应用整合了Logstash以后会把日志发送给Logstash,Logstash再把日志转发给Elasticsearch&lt;/li&gt;
&lt;li&gt;Kibana：通过提供web端可视化界面来查看日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="ElasticSearch" scheme="https://github/zhuchong6.github.io/categories/ElasticSearch/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="ElasticSearch" scheme="https://github/zhuchong6.github.io/tags/ElasticSearch/"/>
    
    <category term="Docker" scheme="https://github/zhuchong6.github.io/tags/Docker/"/>
    
    <category term="微服务" scheme="https://github/zhuchong6.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式组件-分布式ID</title>
    <link href="https://github/zhuchong6.github.io/2021/04/03/2021-04-04%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6-%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <id>https://github/zhuchong6.github.io/2021/04/03/2021-04-04%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6-%E5%88%86%E5%B8%83%E5%BC%8FID/</id>
    <published>2021-04-03T21:23:01.000Z</published>
    <updated>2022-09-29T01:04:32.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式ID是什么？"><a href="#分布式ID是什么？" class="headerlink" title="分布式ID是什么？"></a>分布式ID是什么？</h1><p>就像我们每个人都有一个生份证来标识我是我，每条数据也需要一个唯一标识方便后续查找。在单库单表应用中用自增的id来标识数据，但是，这种方式在数据过大进行分库分表之后就会有id冲突的问题。所以，我们需要引入分布式的id（即为每条数据生成全局唯一的id）来解决冲突的问题。</p><span id="more"></span><h1 id="分布式ID满足什么条件？"><a href="#分布式ID满足什么条件？" class="headerlink" title="分布式ID满足什么条件？"></a>分布式ID满足什么条件？</h1><ul><li>全局唯一（基本条件）</li><li>高性能</li><li>高可用</li><li>趋势递增（方便建立索引，提高查找效率）</li></ul><h1 id="分布式ID有哪些生成方式？"><a href="#分布式ID有哪些生成方式？" class="headerlink" title="分布式ID有哪些生成方式？"></a>分布式ID有哪些生成方式？</h1><ol><li><p><strong>UUID</strong></p><p>uuid是一个方案，但是uuid它不仅是太长还是字符串，太长导致存储空间大，字符串的话就会导致查询耗时（主要是这个缺点）</p></li><li><p><strong>基于数据库自增ID</strong></p><p>可以单独一个mysql来通过自增的方式生成ID，当我们需要一个ID时就往表插入一条记录，并返回主键ID。但是，这种方案缺点也比较致命，当访问量上来的时候数据库成为了系统的瓶颈，不太适合</p></li><li><p><strong>基于数据库集群自增ID</strong></p><p>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。A数据库设置起始的ID为1，每次加2；B数据的起始ID为2，每次加2；这样两个MySQL实例的自增ID分别就是：</p><pre><code>1,3,5,7,92,4,6,8,10</code></pre><p>这样也提高了性能，但是，如果数据量继续增加，两台机器不够，后续扩容比较麻烦。所以，也不推荐这种方式</p></li><li><p><strong>基于数据库的号段模式</strong></p><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,100] 代表100个ID，具体的业务服务将本号段，生成1~100的自增ID并加载到内存。表结构如下：</p><pre><code class="mysql">CREATE TABLE test (  biz_tagint(20) NOT NULL COMMENT &#39;业务类型&#39;,  max_id bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,  step int(20) NOT NULL COMMENT &#39;号段的步长，即每次多生成几个id&#39;,  version int(20) NOT NULL COMMENT &#39;版本号，乐观锁&#39;,  PRIMARY KEY (`id`)) </code></pre><table><thead><tr><th>biz_tag</th><th>max_id</th><th>step</th><th>version</th></tr></thead><tbody><tr><td>Order</td><td>2000</td><td>2000</td><td>1</td></tr></tbody></table><p>第一次生成2000个id加载到内存，用完之后在申请2000个，这样不像上面频繁操作数据库，对数据库压力小很多</p><p><strong>这个方式最大的问题在于生成的号码是连续的，类似订单id的业务，容易被扫库或者测算出订单量</strong></p></li><li><p>基于redis模式</p><p>redis模式其实类似mysql自增id的方式，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。但是存在一个问题，redis持久化问题。redis持久化分为两种，<code>RDB</code>和<code>AOP</code>。</p><blockquote><p>RDB会定时打一个快照进行持久化，这种模式有可能<code>Redis</code>挂掉之后，没有及时保存ID，下次重启的时候ID会重复</p></blockquote><blockquote><p>AOF会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况,但是AOF持久化会损耗性能，并且在宕机重启后可能由于文件过大导致恢复数据时间过长</p></blockquote></li><li><p>基于雪花算法（SnowFlake）模式</p><p>雪花算法是twitter开源的分布式ID生成算法，是另一种当下主流生成方式，其核心思想是：<strong>使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，保持自增性且不重复</strong></p><p>结构图：</p><p><img src="/snowflake.png" alt="雪花算法"></p><p>值得注意的是，中间10bit（记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器，用不了这么多），一般用5bit表示机房ID，5bit表示机器id。</p><p>当然，雪花算法也有问题，就是时钟回拨的问题，会导致ID重复（由于使用的容器配置写错，我们就碰到ID冲突的问题）</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基本上，市面上主流的解决方案就是以上几种方式或者基于之上的。像百度的<code>uid-generator</code>是基于雪花算法，并解决时钟回拨的问题；滴滴的<code>Tinyid</code>则是基于数据库号段模式；而美团的<code>leaf</code>，则两种模式都兼容。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;分布式ID是什么？&quot;&gt;&lt;a href=&quot;#分布式ID是什么？&quot; class=&quot;headerlink&quot; title=&quot;分布式ID是什么？&quot;&gt;&lt;/a&gt;分布式ID是什么？&lt;/h1&gt;&lt;p&gt;就像我们每个人都有一个生份证来标识我是我，每条数据也需要一个唯一标识方便后续查找。在单库单表应用中用自增的id来标识数据，但是，这种方式在数据过大进行分库分表之后就会有id冲突的问题。所以，我们需要引入分布式的id（即为每条数据生成全局唯一的id）来解决冲突的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="https://github/zhuchong6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>java并发编程（一）-线程</title>
    <link href="https://github/zhuchong6.github.io/2021/01/07/2021-01-07java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://github/zhuchong6.github.io/2021/01/07/2021-01-07java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-07T11:04:01.000Z</published>
    <updated>2022-09-29T01:04:32.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>为什么使用多线程？只有一个目的就是更好的利用多核cpu的资源。多线程一定快吗？不一定，多线程上下文切换需要花费时间，如果执行的任务比较简单，多线程花的时候可能比串行执行还要慢。</p><span id="more"></span><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><ol><li><p>继承<code>Thread</code>类</p><pre><code class="java">public class Demo4 &#123;    public static void main(String[] args) &#123;        new MyTread().start();    &#125;&#125;class MyTread extends Thread&#123;    @Override    public void run() &#123;        System.out.println(&quot;thread:&quot;+Thread.currentThread().getName());    &#125;&#125;</code></pre></li><li><p>实现<code>Runnable</code>接口</p><pre><code class="java">new Thread(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;实现Runnable接口&quot;);    &#125;&#125;).start();</code></pre></li><li><p>实现<code>Callable</code>接口</p><pre><code class="java">FutureTask&lt;String&gt; stringFutureTask = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() &#123;    @Override    public String call() throws Exception &#123;        return &quot;call接口&quot;;    &#125;&#125;);new Thread(stringFutureTask).start();String s = null;try &#123;    s = stringFutureTask.get();&#125; catch (InterruptedException e) &#123;    e.printStackTrace();&#125; catch (ExecutionException e) &#123;    e.printStackTrace();&#125;System.out.println(s);</code></pre></li></ol><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>在Java中，线程状态在Thread类中的枚举中：</p><pre><code class="java">public enum State &#123;  //新建状态，但是没有调用start()方法  NEW,  //运行状态，包括正在运行中的，以及等待分配cpu的线程  RUNNABLE,  //阻塞状态，代表正在等待获取锁首次进入synchronized代码块或者方法  //或者重入的线程  BLOCKED,  //调用以下不带时间参数的方法，会使线程进入waiting状态  //Object.wait with no timeout  //Thread.join with no timeout  //LockSupport.park  WAITING,  //调用以下带时间参数的方法，会使线程进入waiting状态  //Thread.sleep  //Object.wait with timeout  //Thread.join with timeout  //LockSupport.parkNanos  //LockSupport.parkUntil  TIMED_WAITING,  //完成线程要执行的任务  TERMINATED;&#125;</code></pre><p><img src="/thread_state.png" alt="状态图"></p><p>上面是，线程状态流转图。</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><pre><code class="java">/** * 线程状态演示 * @author zhuchong */@Slf4j(topic = &quot;test&quot;)public class ThreadStateTest &#123;    public static void main(String[] args) &#123;        Thread t1 = new Thread(&quot;t1&quot;) &#123;            @Override            public void run() &#123;                log.debug(&quot;running&quot;);            &#125;        &#125;;        Thread t2 = new Thread(&quot;t2&quot;) &#123;            @Override            public void run() &#123;                while (true)&#123;                &#125;            &#125;        &#125;;        t2.start();        Thread t3 = new Thread(&quot;t3&quot;) &#123;            @Override            public void run() &#123;                log.debug(&quot;running&quot;);            &#125;        &#125;;        t3.start();        Thread t4 = new Thread(&quot;t4&quot;) &#123;            @Override            public void run() &#123;                synchronized (ThreadStateTest.class)&#123;                    try &#123;                        Thread.sleep(10000000);                    &#125;catch (InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;;        t4.start();        Thread t5 = new Thread(&quot;t5&quot;) &#123;            @Override            public void run() &#123;                try &#123;                    t2.join();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;;        t5.start();        Thread t6 = new Thread(&quot;t6&quot;) &#123;            @Override            public void run() &#123;                synchronized (ThreadStateTest.class)&#123;                    try &#123;                        Thread.sleep(10000000);                    &#125;catch (InterruptedException e)&#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;;        t6.start();        try &#123;            Thread.sleep(500);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        log.debug(&quot;t1 state &#123;&#125;&quot;, t1.getState());        log.debug(&quot;t2 state &#123;&#125;&quot;, t2.getState());        log.debug(&quot;t3 state &#123;&#125;&quot;, t3.getState());        log.debug(&quot;t4 state &#123;&#125;&quot;, t4.getState());        log.debug(&quot;t5 state &#123;&#125;&quot;, t5.getState());        log.debug(&quot;t6 state &#123;&#125;&quot;, t6.getState());    &#125;&#125;-------结果------17:52:31.049 [t3] DEBUG test - running17:52:31.549 [main] DEBUG test - t1 state NEW17:52:31.556 [main] DEBUG test - t2 state RUNNABLE17:52:31.556 [main] DEBUG test - t3 state TERMINATED17:52:31.556 [main] DEBUG test - t4 state TIMED_WAITING17:52:31.556 [main] DEBUG test - t5 state WAITING17:52:31.556 [main] DEBUG test - t6 state BLOCKED</code></pre><h3 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h3><pre><code class="java">//提示调度器让出cpu，调度器可能会忽略不一定执行public static native void yield();//暂停线程正在执行的任务，当前线程还持有锁public static native void sleep(long millis);//中断此线程//如果此线程处于被阻塞状态，例如调用sleep,wait,join方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常//如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。public void interrupt();//等待直到当前线程结束public final void join();</code></pre><h3 id="线程方法实践"><a href="#线程方法实践" class="headerlink" title="线程方法实践"></a>线程方法实践</h3><ul><li><p>sleep 线程休眠，但是持有锁</p><pre><code class="java">//可以防止cpu 100%public static void main(String[] args) &#123;  new Thread(()-&gt;&#123;    while (true)&#123;      try &#123;        Thread.sleep(50);      &#125; catch (InterruptedException e) &#123;        e.printStackTrace();      &#125;      System.out.println(&quot;do something&quot;);    &#125;  &#125;).start();&#125;</code></pre></li><li><p>interrupt 线程中断，线程是否中断应该由线程自己决定，所以为什么取消了stop、resume、suspend的方法</p><pre><code class="java">//用interrupt中断程序public static void main(String[] args) throws InterruptedException &#123;  Thread t1 = new Thread(() -&gt; &#123;    while (Thread.currentThread().isInterrupted())&#123;      try &#123;        System.out.println(&quot;t1开始sleep&quot;);        Thread.sleep(100000000000L);        System.out.println(&quot;t1结束sleep&quot;);      &#125; catch (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;, &quot;t1&quot;);  t1.start();  System.out.println(&quot;----main线程开始sleep&quot;);  Thread.sleep(5000);  System.out.println(&quot;----main线程结束sleep,当前他t1线程的状态&quot;+ t1.getState());  //准备打断  System.out.println(&quot;Begin Interupt...&quot;);  t1.interrupt();  System.out.println(&quot;End Interupt...,当前中断状态为：&quot;+t1.isInterrupted());    &#125;</code></pre></li><li><p>join</p><pre><code class="java">//基于wait方法实现，稍后讲到，这里贴出一段源码,供参考while (isAlive()) &#123;wait(0);&#125;</code></pre></li></ul><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>线程通信定义，线程通信就是当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。</p><h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h4><p>线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步的执行，但是如果每个线程间都孤立的运行，那就会造资源浪费。所以在现实中，我们需要这些线程间可以按照指定的规则共同完成一件任务，所以这些线程之间就需要互相协调，这个过程被称为线程的通信</p><h4 id="线程通信方式"><a href="#线程通信方式" class="headerlink" title="线程通信方式"></a>线程通信方式</h4><p>线程通信方式主要有三种，有<strong>共享内存</strong>，<strong>消息传递</strong>和<strong>管道流</strong>，并且每种方式有不同的实现。</p><h5 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h5><p>volatile有一个关键的特性，保证内存可见性，即多个线程访问内存中的同一个被volatile关键字修饰的变量时，当某一个线程修改完该变量后，需要先将这个最新修改的值写回到主内存，从而保证下一个读取该变量的线程取得的就是主内存中该数据的最新值，这样就保证线程之间的透明性，便于线程通信。</p><pre><code class="java">public class VolatileTest &#123;    private static volatile boolean flag=true;    public static void main(String[] args) &#123;        new Thread(() -&gt;&#123;            while(true)&#123;                if(flag)&#123;                    System.out.println(&quot;线程A&quot;);                    flag = false;                &#125;            &#125;        &#125;, &quot;A&quot;).start();        new Thread(() -&gt;&#123;            while(true)&#123;                if(!flag)&#123;                    System.out.println(&quot;线程B&quot;);                    flag = true;                &#125;            &#125;        &#125;, &quot;B&quot;).start();    &#125;&#125;</code></pre><p>上面代码，结果是线程A和线程B交替执行</p><h5 id="2-忙等待"><a href="#2-忙等待" class="headerlink" title="2. 忙等待"></a>2. 忙等待</h5><p>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号,这个方式会照成cpu100%的问题</p><pre><code class="java">protected MySignal sharedSignal = ......while(!sharedSignal.hasDataToProcess())&#123;  //do nothing... busy waiting&#125;</code></pre><h5 id="3-消息传递"><a href="#3-消息传递" class="headerlink" title="3. 消息传递"></a>3. 消息传递</h5><p>wait&#x2F;notify等待通知方式，从字面上理解，等待通知机制就是将处于等待状态的线程将由其它线程发出通知后重新获取CPU资源，继续执行之前没有执行完的任务，最经典的例子就是生产者-消费者模型</p><pre><code class="java">public class TwoThreadWaitNotify &#123;    private int start = 1;    private boolean flag = false;    public static void main(String[] args) &#123;        TwoThreadWaitNotify twoThread = new TwoThreadWaitNotify();        Thread t1 = new Thread(new OuNum(twoThread));        t1.setName(&quot;A&quot;);        Thread t2 = new Thread(new JiNum(twoThread));        t2.setName(&quot;B&quot;);        t1.start();        t2.start();    &#125;    /**     * 偶数线程     */    public static class OuNum implements Runnable &#123;        private TwoThreadWaitNotify number;        public OuNum(TwoThreadWaitNotify number) &#123;            this.number = number;        &#125;        @Override        public void run() &#123;            while (number.start &lt;= 100) &#123;                synchronized (TwoThreadWaitNotify.class) &#123;                    System.out.println(&quot;偶数线程抢到锁了&quot;);                    if (number.flag) &#123;                        System.out.println(Thread.currentThread().getName() + &quot;+-+偶数&quot; + number.start);                        number.start++;                        number.flag = false;                        TwoThreadWaitNotify.class.notify();                    &#125;else &#123;                        try &#123;                            TwoThreadWaitNotify.class.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    /**     * 奇数线程     */    public static class JiNum implements Runnable &#123;        private TwoThreadWaitNotify number;        public JiNum(TwoThreadWaitNotify number) &#123;            this.number = number;        &#125;        @Override        public void run() &#123;            while (number.start &lt;= 100) &#123;                synchronized (TwoThreadWaitNotify.class) &#123;                    System.out.println(&quot;奇数线程抢到锁了&quot;);                    if (!number.flag) &#123;                        System.out.println(Thread.currentThread().getName() + &quot;+-+奇数&quot; + number.start);                        number.start++;                        number.flag = true;                        TwoThreadWaitNotify.class.notify();                    &#125;else &#123;                        try &#123;                            TwoThreadWaitNotify.class.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>由于，底层存在虚假唤醒的问题，所以jdk推荐如下写法，规避虚假唤醒的风险：</p><pre><code class="java">synchronized (obj) &#123;  while (&lt;condition does not hold&gt;)    obj.wait(timeout);  ... // Perform action appropriate to condition&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;并发编程基础&quot;&gt;&lt;a href=&quot;#并发编程基础&quot; class=&quot;headerlink&quot; title=&quot;并发编程基础&quot;&gt;&lt;/a&gt;并发编程基础&lt;/h1&gt;&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;为什么使用多线程？只有一个目的就是更好的利用多核cpu的资源。多线程一定快吗？不一定，多线程上下文切换需要花费时间，如果执行的任务比较简单，多线程花的时候可能比串行执行还要慢。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Stream函数操作</title>
    <link href="https://github/zhuchong6.github.io/2020/12/19/2020-12-19Stream%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/"/>
    <id>https://github/zhuchong6.github.io/2020/12/19/2020-12-19Stream%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C/</id>
    <published>2020-12-19T08:30:39.000Z</published>
    <updated>2022-09-29T01:04:32.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Stream基础操作"><a href="#Java-Stream基础操作" class="headerlink" title="Java Stream基础操作"></a>Java Stream基础操作</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>jdk8之前，操作集合中的元素，一般都是通过for或者iterator去遍历，代码特别冗长。jdk8提供了Stream，让我对更加方便的操作集合</p><h2 id="Stream构造方式"><a href="#Stream构造方式" class="headerlink" title="Stream构造方式"></a>Stream构造方式</h2><h3 id="stream本身的"><a href="#stream本身的" class="headerlink" title="stream本身的"></a>stream本身的</h3><pre><code class="java">public static&lt;T&gt; Builder&lt;T&gt; builder();public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b);public static&lt;T&gt; Stream&lt;T&gt; empty();public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s);public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f);public static&lt;T&gt; Stream&lt;T&gt; of(T t);public static&lt;T&gt; Stream&lt;T&gt; of(T... values);</code></pre><span id="more"></span><h3 id="Collection接口提供"><a href="#Collection接口提供" class="headerlink" title="Collection接口提供"></a>Collection接口提供</h3><pre><code class="java">default Stream&lt;E&gt; stream();</code></pre><p>默认方法，也就是任意Collection的之类，都能通过调用stream方法获取Stream对象，常见的比如<code>List.stream()</code></p><h2 id="Stream中间操作"><a href="#Stream中间操作" class="headerlink" title="Stream中间操作"></a>Stream中间操作</h2><h3 id="filter过滤操作"><a href="#filter过滤操作" class="headerlink" title="filter过滤操作"></a>filter过滤操作</h3><pre><code class="java">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</code></pre><ul><li>predicate函数时接口，可以使用lambda替代，也可以使用传统实现的方式来入参。如果有复杂的逻辑可以用传统是实现接口方式，并用predicate提供的接口来组合</li></ul><pre><code class="java">List&lt;String&gt; demo = Arrays.asList(&quot;q&quot;, &quot;w&quot;, &quot;e&quot;);Predicate&lt;String&gt; f1 = e -&gt; e.equals(&quot;q&quot;);Predicate&lt;String&gt; f2 = e -&gt; e.equals(&quot;w&quot;);demo.stream().filter(f1.or(f2)).forEach(System.out::println);//或者demo.stream().filter(e-&gt;e.equals(&quot;q&quot;)||e.equals(&quot;w&quot;)).forEach(System.out::println);-------result--------abab</code></pre><h3 id="map映射转化"><a href="#map映射转化" class="headerlink" title="map映射转化"></a>map映射转化</h3><pre><code class="java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);</code></pre><pre><code>class User &#123;    private Long id;    private String name;    public User(Long id, String name) &#123;        this.id = id;        this.name = name;    &#125;    public Long getId() &#123;        return id;    &#125;    public User setId(Long id) &#123;        this.id = id;        return this;    &#125;    public String getName() &#123;        return name;    &#125;    public User setName(String name) &#123;        this.name = name;        return this;    &#125;&#125;static void mapTest()&#123;    List&lt;User&gt; users = Arrays.asList(new User(1L, &quot;11&quot;), new User(2L, &quot;22&quot;));    users.stream().map(e-&gt;e.getId()).forEach(System.out::println);&#125;---result---12</code></pre><h3 id="peek数据处理"><a href="#peek数据处理" class="headerlink" title="peek数据处理"></a>peek数据处理</h3><pre><code class="java">Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action);</code></pre><ul><li>和map的区别是，map有返回值，这个没有</li></ul><pre><code>public static void main(String[] args) &#123;    List&lt;User&gt; demo = Arrays.asList(new User(1L,&quot;11&quot;), new User(2L,&quot;22&quot;), new User(3L,&quot;33&quot;));// id平方，User 转为 Integer(id)demo.stream().peek(user -&gt; user.setId(user.id * user.id)).map(User::getId).forEach(System.out::println);-------result--------149</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>这个没有好的翻译，暂时不翻译。为了更好的了解这个操作的意义，我们假设张三有经理和财务两个角色，两个角色对应不同权限，那么张三的权限&#x3D;经理权限+财务权限，相关类如下：</p><pre><code>class Role&#123;    private List&lt;Private&gt; private;//权限集合&#125;class Private&#123;    private String name;//权限名称&#125;//经理角色Private p1 = new Private().setName(&quot;发布任务&quot;);Private p2 = new Private().setName(&quot;制定计划&quot;);List&lt;Private&gt; provates = Arrays.asList(p1,p2);Role manager = new Role().setPrivates(provates);//财务角色Private p3 = new Private().setName(&quot;做预算&quot;);Private p4 = new Private().setName(&quot;发工资&quot;);List&lt;Private&gt; provates2 = Arrays.asList(p3,p4);Role caiwu = new Role().setPrivates(provates2);//张三角色集合List&lt;Role&gt; roles = Arrays.asList(manager,caiwu);//计算张三所有权限roles.stream().flatMap(e-&gt;e.getPrivates().stream()).forEach(e-&gt; System.out.println(e.getName()));---result----发布任务制定计划做预算发工资</code></pre><p>由上面的demo，可以看出flatMap的作用是，将多个provates列表，压缩成一个</p><h3 id="distinct-去重"><a href="#distinct-去重" class="headerlink" title="distinct 去重"></a>distinct 去重</h3><pre><code class="java">Stream&lt;T&gt; distinct();</code></pre><pre><code>List&lt;Integer&gt; demo = Arrays.asList(1, 1, 2);demo.stream().distinct().forEach(System.out::println);-------result--------12</code></pre><p>如果是对象去重，需要重写对象的equals和hashcode方法</p><h3 id="sorted-排序"><a href="#sorted-排序" class="headerlink" title="sorted 排序"></a>sorted 排序</h3><pre><code class="java">Stream&lt;T&gt; sorted();Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator);</code></pre><pre><code>List&lt;Integer&gt; demo = Arrays.asList(5, 1, 2);//默认升序demo.stream().sorted().forEach(System.out::println);//降序Comparator&lt;Integer&gt; comparator = Comparator.&lt;Integer, Integer&gt;comparing(item -&gt; item).reversed();demo.stream().sorted(comparator).forEach(System.out::println);-------默认升序 result--------125-------降序 result--------521</code></pre><h3 id="limit和skip"><a href="#limit和skip" class="headerlink" title="limit和skip"></a>limit和skip</h3><pre><code class="java">//截取前maxSize个元素Stream&lt;T&gt; limit(long maxSize);//跳过前n个流Stream&lt;T&gt; skip(long n);</code></pre><pre><code>List&lt;Integer&gt; demo = Arrays.asList(1, 2, 3, 4, 5, 6);//跳过前两个，然后限制截取两个demo.stream().skip(2).limit(2).forEach(System.out::println);-------result--------34</code></pre><h2 id="Stream终止操作"><a href="#Stream终止操作" class="headerlink" title="Stream终止操作"></a>Stream终止操作</h2><h3 id="遍历消费"><a href="#遍历消费" class="headerlink" title="遍历消费"></a>遍历消费</h3><pre><code class="java">//遍历消费void forEach(Consumer&lt;? super T&gt; action);//顺序遍历消费,和forEach的区别是forEachOrdered在多线程parallelStream执行，保证顺序void forEachOrdered(Consumer&lt;? super T&gt; action);</code></pre><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;DD&quot;);strings.parallelStream().forEach(System.out::print);System.out.println();strings.parallelStream().forEachOrdered(System.out::print);----------result----------CCDDBBAAAABBCCDD</code></pre><h3 id="转换成数组"><a href="#转换成数组" class="headerlink" title="转换成数组"></a>转换成数组</h3><pre><code class="java">//流转成Object数组Object[] toArray();//流转成Ａ[]数组，指定类型A&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</code></pre><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;DD&quot;);Object[] objects = strings.stream().toArray();String[] strings1 = strings.stream().toArray(String[]::new);</code></pre><h3 id="最大最小"><a href="#最大最小" class="headerlink" title="最大最小"></a>最大最小</h3><pre><code class="java">//获取最小值Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)//获取最大值Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></pre><pre><code>List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 45, 6);Optional&lt;Integer&gt; max = integers.stream().max(Comparator.comparing(i -&gt; i));Optional&lt;Integer&gt; min = integers.stream().min(Comparator.comparing(i -&gt; i));System.out.println(&quot;max=&quot;+max.get()+&quot;,min=&quot;+min.get());--------result-------max=45,min=1</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><pre><code class="java">//两两合并Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)//两两合并，带初始值的T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)//如果是stream的话与第二个完全一样，parallelStream会在合并一次&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></pre><pre><code>List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 45, 6);Optional&lt;Integer&gt; reduce = integers.stream().reduce((v1, v2) -&gt; v1 + v2);Integer reduce1 = integers.stream().reduce(1, (v1, v2) -&gt; v1 + v2);String reduce2 = integers.stream().reduce(&quot;初始值&quot;, (v1, v2) -&gt; v1 + &quot;第一次&quot; + v2, (v3, v4) -&gt; v3 + &quot;第二次&quot; + v4);String reduce3 = integers.parallelStream().reduce(&quot;a&quot;, (v1, v2) -&gt; v1 + &quot;-&quot; + v2, (v3, v4) -&gt; v3 + &quot;第二次&quot; + v4);System.out.println(reduce.get());System.out.println(reduce1);System.out.println(reduce2);--------result--------5758初始值第一次1第一次2第一次3第一次45第一次6a-1第二次a-2第二次a-3第二次a-45第二次a-6</code></pre><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><pre><code class="java">//统计元素个数long count()</code></pre><h3 id="聚合处理"><a href="#聚合处理" class="headerlink" title="聚合处理"></a>聚合处理</h3><pre><code class="java">/** * supplier:返回结果类型的生产者 * accumulator:元素消费者（处理并加入R） * combiner: 返回结果 R 怎么组合（多线程执行时，会产生多个返回值R，需要合并） */&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);/** * collector一般是由 supplier、accumulator、combiner、finisher、characteristics组合成的聚合类 * Collectors 可提供一些内置的聚合类或者方法 */&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</code></pre><p>具体可以看下面</p><h2 id="Collector-聚合类-的操作"><a href="#Collector-聚合类-的操作" class="headerlink" title="Collector(聚合类)的操作"></a>Collector(聚合类)的操作</h2><h3 id="接口Collector和实现类CollectorImpl"><a href="#接口Collector和实现类CollectorImpl" class="headerlink" title="接口Collector和实现类CollectorImpl"></a>接口Collector和实现类CollectorImpl</h3><pre><code class="java">//返回值类型的生产者Supplier&lt;A&gt; supplier();//流元素消费者BiConsumer&lt;A, T&gt; accumulator();//返回值合并器（多个线程操作时，会产生多个返回值，需要合并）BinaryOperator&lt;A&gt; combiner();//返回值转化器（最后一步处理，实际返回结果，一般原样返回）Function&lt;A, R&gt; finisher();//流的特性Set&lt;Characteristics&gt; characteristics();public static&lt;T, A, R&gt; Collector&lt;T, A, R&gt; of(Supplier&lt;A&gt; supplier,    BiConsumer&lt;A, T&gt; accumulator, BinaryOperator&lt;A&gt; combiner,    Function&lt;A, R&gt; finisher, Characteristics... characteristics)</code></pre><h3 id="转换成List-Set"><a href="#转换成List-Set" class="headerlink" title="转换成List, Set"></a>转换成List, Set</h3><pre><code class="java">//流转化成Listpublic static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()//流转化成Setpublic static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code></pre><pre><code class="java">List&lt;Integer&gt; demo = Arrays.asList(1, 2, 3);List&lt;Integer&gt; col = demo.stream().collect(Collectors.toList());Set&lt;Integer&gt; set = demo.stream().collect(Collectors.toSet());</code></pre><h3 id="转换成Map"><a href="#转换成Map" class="headerlink" title="转换成Map"></a>转换成Map</h3><pre><code class="java">//流转化成Mappublic static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(    Function&lt;? super T, ? extends K&gt; keyMapper,    Function&lt;? super T, ? extends U&gt; valueMapper)/** * mergeFunction:相同的key,值怎么合并 */public static &lt;T, K, U&gt; Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(    Function&lt;? super T, ? extends K&gt; keyMapper,    Function&lt;? super T, ? extends U&gt; valueMapper,    BinaryOperator&lt;U&gt; mergeFunction)/** * mergeFunction:相同的key,值怎么合并 * mapSupplier：返回值Map的生产者 */public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(    Function&lt;? super T, ? extends K&gt; keyMapper,    Function&lt;? super T, ? extends U&gt; valueMapper,    BinaryOperator&lt;U&gt; mergeFunction,    Supplier&lt;M&gt; mapSupplier)</code></pre><pre><code>List&lt;User&gt; users = Arrays.asList(new User(1), new User(2), new User(3), new User(1));//Map&lt;Integer, Integer&gt; collect = users.stream().collect(Collectors.toMap(e -&gt; e.getId(), f -&gt; f.getId()));//System.out.println(collect);Map&lt;Integer, Integer&gt; collect1 = users.stream().collect(Collectors.toMap(User::getId, User::getId, (v1,v2)-&gt;v1+v2, HashMap::new ));System.out.println(collect1);--------result------------&#123;1=2, 2=2, 3=3&#125;</code></pre><h3 id="字符流聚合"><a href="#字符流聚合" class="headerlink" title="字符流聚合"></a>字符流聚合</h3><pre><code class="java">//多个字符串拼接成一个字符串public static Collector&lt;CharSequence, ?, String&gt; joining();//多个字符串拼接成一个字符串（指定分隔符）public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter);//多个字符串拼接，指定分隔符，前缀，后缀public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix)</code></pre><pre><code>List&lt;String&gt; integers = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);String collect = integers.stream().collect(Collectors.joining());String collect1 = integers.stream().collect(Collectors.joining(&quot;|&quot;));String collect2 = integers.stream().collect(Collectors.joining(&quot;|&quot;,&quot;[&quot;,&quot;]&quot;));System.out.println(collect);System.out.println(collect1);System.out.println(collect2);--------result----------1231|2|3[1|2|3]</code></pre><h3 id="映射、聚合流"><a href="#映射、聚合流" class="headerlink" title="映射、聚合流"></a>映射、聚合流</h3><pre><code class="java">/** * mapper:映射处理器,相当于map功能 * downstream:映射处理后需要再次聚合处理 */public static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream);</code></pre><pre><code>List&lt;String&gt; integers = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);List collect = integers.stream().collect(Collectors.mapping(e-&gt;e+&quot;8&quot;, Collectors.toList()));System.out.println(collect);--------result--------[18, 28, 38]</code></pre><h3 id="聚合、转换"><a href="#聚合、转换" class="headerlink" title="聚合、转换"></a>聚合、转换</h3><pre><code class="java">/** * downstream:聚合处理 * finisher:结果转换处理 */public static&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt; downstream,        Function&lt;R, RR&gt; finisher); </code></pre><pre><code>List&lt;String&gt; integers = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);//聚合成List,最后提取数组的size作为返回值Integer size =integers.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));System.out.println(size);---------result---------3</code></pre><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><pre><code class="java">/** * classifier 指定T类型某一属性作为Key值分组 * 分组后，使用List作为每个流的容器 */public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(        Function&lt;? super T, ? extends K&gt; classifier);           /** * classifier: 流分组器 * downstream: 每组流的聚合处理器 */public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(        Function&lt;? super T, ? extends K&gt; classifier，         Collector&lt;? super T, A, D&gt; downstream);/** * classifier: 流分组器 * mapFactory: 返回值map的工厂（Map的子类） * downstream: 每组流的聚合处理器 */public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(        Function&lt;? super T, ? extends K&gt; classifier,        Supplier&lt;M&gt; mapFactory,        Collector&lt;? super T, A, D&gt; downstream);///////////////////用法和上面一样/** * classifier: 分组器 ； 分组后，使用List作为每个流的容器 */public static &lt;T, K&gt; Collector&lt;T, ?, ConcurrentMap&lt;K, List&lt;T&gt;&gt;&gt; groupingByConcurrent(        Function&lt;? super T, ? extends K&gt; classifier);/** * classifier: 分组器 * downstream: 流的聚合处理器 */public static &lt;T, K, A, D&gt; Collector&lt;T, ?, ConcurrentMap&lt;K, D&gt;&gt; groupingByConcurrent(        Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)/** * classifier: 分组器 * mapFactory: 返回值类型map的生产工厂（ConcurrentMap的子类） * downstream: 流的聚合处理器 */public static &lt;T, K, A, D, M extends ConcurrentMap&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingByConcurrent(        Function&lt;? super T, ? extends K&gt; classifier,         Supplier&lt;M&gt; mapFactory,        Collector&lt;? super T, A, D&gt; downstream);</code></pre><pre><code>List&lt;Integer&gt; integers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);HashMap&lt;Integer, List&lt;String&gt;&gt; collect = integers.stream().collect(Collectors.groupingBy(i -&gt; i % 3,HashMap::new,Collectors.mapping(String::valueOf, Collectors.toList())));System.out.println(collect);-------------result----------&#123;0=[3, 6, 9], 1=[1, 4, 7, 10], 2=[2, 5, 8]&#125;</code></pre><h3 id="流拆分"><a href="#流拆分" class="headerlink" title="流拆分"></a>流拆分</h3><pre><code class="java">public static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(        Predicate&lt;? super T&gt; predicate)/** * predicate: 二分器 * downstream: 流的聚合处理器 */public static &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(        Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream)</code></pre><pre><code>List&lt;Integer&gt; integers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);        Map&lt;Boolean, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.partitioningBy(i -&gt; i % 3 == 0));        System.out.println(collect);-----------result-----------&#123;false=[1, 2, 4, 5, 7, 8, 10], true=[3, 6, 9]&#125;</code></pre><h3 id="聚合求平均值"><a href="#聚合求平均值" class="headerlink" title="聚合求平均值"></a>聚合求平均值</h3><pre><code class="java">// 返回Double类型public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)// 返回Long 类型public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)//返回Int 类型public static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code></pre><pre><code>List&lt;Double&gt; integers = Arrays.asList(1.1,2.2,3.3,4.4,5.1,6.1,7.1,8.1,9.1,10.1);Double collect = integers.stream().collect(Collectors.averagingDouble(Double::doubleValue));System.out.println(collect);----------result-----------5.659999999999999</code></pre><h3 id="聚合查找最大最小值"><a href="#聚合查找最大最小值" class="headerlink" title="聚合查找最大最小值"></a>聚合查找最大最小值</h3><pre><code class="java">//最小值public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator) //最大值public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator)  </code></pre><pre><code>List&lt;Double&gt; integers = Arrays.asList(1.1,2.2,3.3,4.4,5.1,6.1,7.1,8.1,9.1,10.1);Optional&lt;Double&gt; max = integers.stream().collect(Collectors.maxBy(Comparator.comparing(i -&gt; i)));Optional&lt;Double&gt; min = integers.stream().collect(Collectors.minBy(Comparator.comparing(i -&gt; i)));System.out.println(&quot;max=&quot;+max.get()+&quot;,min=&quot;+min.get());------------result------------max=10.1,min=1.1</code></pre><h3 id="聚合计算统计结果"><a href="#聚合计算统计结果" class="headerlink" title="聚合计算统计结果"></a>聚合计算统计结果</h3><pre><code class="java">//可以获得元素总个数，元素累计总和，最小值，最大值，平均值//返回Int 类型public static &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(        ToIntFunction&lt;? super T&gt; mapper)//返回Double 类型public static &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(        ToDoubleFunction&lt;? super T&gt; mapper)//返回Long 类型public static &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(        ToLongFunction&lt;? super T&gt; mapper)</code></pre><pre><code>List&lt;Double&gt; integers = Arrays.asList(1.1,2.2,3.3,4.4,5.1,6.1,7.1,8.1,9.1,10.1);DoubleSummaryStatistics collect = integers.stream().collect(Collectors.summarizingDouble(Double::doubleValue));System.out.println(collect);--------result----------DoubleSummaryStatistics&#123;count=10, sum=56.600000, min=1.100000, average=5.660000, max=10.100000&#125;</code></pre><h2 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h2><pre><code>List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7);integers.parallelStream().forEach(e-&gt;&#123;System.out.println(e);System.out.println(Thread.currentThread().getName());&#125;);--------reult---------5main4main1main3ForkJoinPool.commonPool-worker-367ForkJoinPool.commonPool-worker-2ForkJoinPool.commonPool-worker-42ForkJoinPool.commonPool-worker-1</code></pre><p>可以看出，并行流使用的是<code>fork/join</code>,他使用的commonPool，所有共用一个。所以，我们一般自定义线程池来运行。</p><pre><code>IntStream range = IntStream.range(1, 10);ForkJoinPool forkJoinPol = new ForkJoinPool(5);forkJoinPol.submit(()-&gt;&#123;range.parallel().forEach(f-&gt;&#123;System.out.println(f);System.out.println(Thread.currentThread().getName());&#125;);&#125;).get();------------result------------6ForkJoinPool-1-worker-13ForkJoinPool-1-worker-25ForkJoinPool-1-worker-18ForkJoinPool-1-worker-34ForkJoinPool-1-worker-27ForkJoinPool-1-worker-49ForkJoinPool-1-worker-32ForkJoinPool-1-worker-11ForkJoinPool-1-worker-5</code></pre><h3 id="parallelStream的坑"><a href="#parallelStream的坑" class="headerlink" title="parallelStream的坑"></a>parallelStream的坑</h3><ol><li>默认情况下，使用通用的<code>fork/join</code>池完成任务，该池是所有并行流共享的。并且该池线程数和cpu核心数一样，对cpu密集型任务是有意义的，因为机器只能执行这么多线程；对于io密集型，瓶颈是io，会等待其他系统。所以，两个流使用通用的线程池，会因为相互等待尔阻塞</li><li>使用foreach会乱序，应该使用foreachOrdered</li><li>线程不安全，写代码的是否需要注意线程安全的问题</li></ol><h3 id="fork-x2F-join是什么"><a href="#fork-x2F-join是什么" class="headerlink" title="fork&#x2F;join是什么"></a>fork&#x2F;join是什么</h3><p><code>fork/join</code>框架是Java7提供的一个用于并行执行任务的框架，拆用‘分而治之’的思想，就是把一个大任务拆成若干个小任务，最后在汇总结果，具体过程，我在网上找了一张图：</p><p><img src="/fork_join.png" alt="fork join"></p><h4 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h4><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="/work_steal.png" alt="fork join"></p><p>我们把一个任务分配给两个线程执行，线程1执行很快，线程2还没执行完，线程1就会去线程儿中窃取一个任务执行，加快速度。此时，他们访问同一队列，为了减少窃取任务线程和被窃取任务线程的竞争，通常拆用双端队列，被窃取任务线程永远从头部取任务，而窃取任务线程永远从尾部拿任务线程</p><h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p> ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。ForkJoinPool提供了如下两个常用的构造器：</p><pre><code class="java">// 创建一个包含parallelism个并行线程的ForkJoinPoolpublic ForkJoinPool(int parallelism)//以Runtime.getRuntime().availableProcessors()的返回值作为parallelism来创建ForkJoinPoolpublic ForkJoinPool() ：</code></pre><p>创建实例后，可以调用<code>public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)</code>和<code>public void execute(ForkJoinTask&lt;?&gt; task)</code>来执行任务。<code>ForkJoinTask</code>是一个抽象类，代表可并行、合并的任务，它还有两个抽象子类：</p><ul><li>RecursiveAction代表没有返回值的任务</li></ul><pre><code class="java">public class Demo1 extends RecursiveAction &#123;    public int start;    public int end;    public Demo1(int start, int end) &#123;        this.start = start;        this.end = end;    &#125;    @Override    protected void compute() &#123;        if((end-start) &gt;40)&#123;            //执行拆分            // 将大任务分解成两个小任务            int middle = (start + end) / 2;            Demo1 left = new Demo1(start, middle);            Demo1 right = new Demo1(middle, end);            left.fork();            right.fork();        &#125;else &#123;            for(int i= start; i&lt;end;i++) &#123;                System.out.println(Thread.currentThread().getName()+&quot;i的值&quot;+i);            &#125;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        // 创建包含Runtime.getRuntime().availableProcessors()返回值作为个数的并行线程的ForkJoinPool        ForkJoinPool forkJoinPool = new ForkJoinPool();        // 提交可分解的PrintTask任务        forkJoinPool.submit(new Demo1(0, 1000));        //阻塞当前线程直到 ForkJoinPool 中所有的任务都执行结束        forkJoinPool.awaitTermination(2, TimeUnit.SECONDS);        // 关闭线程池        forkJoinPool.shutdown();    &#125;&#125;</code></pre><ul><li>RecursiveTask代表有返回值的任务</li></ul><pre><code class="java">public class Demo1 extends RecursiveTask&lt;Integer&gt; &#123;    public int start;    public int end;    public Demo1(int start, int end) &#123;        this.start = start;        this.end = end;    &#125;    @Override    protected Integer compute() &#123;        int sum = 0;        if((end-start) &gt;40)&#123;            //执行拆分            // 将大任务分解成两个小任务            int middle = (start + end) / 2;            Demo1 left = new Demo1(start, middle);            Demo1 right = new Demo1(middle, end);            //并行执行任务            left.fork();            right.fork();            //累加两个任务            return left.join()+right.join();        &#125;else &#123;            for(int i= start; i&lt;end;i++) &#123;                sum+=i;            &#125;            return sum;        &#125;    &#125;    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;        // 创建包含Runtime.getRuntime().availableProcessors()返回值作为个数的并行线程的ForkJoinPool        ForkJoinPool forkJoinPool = new ForkJoinPool();        int sum = IntStream.range(0, 100).parallel().reduce( 0,Integer::sum );        System.out.println(sum);        // 提交可分解的PrintTask任务        ForkJoinTask&lt;Integer&gt; submit = forkJoinPool.submit(new Demo1(0, 100));        Integer integer = submit.get();        System.out.println(integer);        //阻塞当前线程直到 ForkJoinPool 中所有的任务都执行结束        forkJoinPool.awaitTermination(2, TimeUnit.SECONDS);        // 关闭线程池        forkJoinPool.shutdown();    &#125;&#125;</code></pre><p>总结，<code>fork/join</code>总体分两步，第一步fork把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小；第二步，分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-Stream基础操作&quot;&gt;&lt;a href=&quot;#Java-Stream基础操作&quot; class=&quot;headerlink&quot; title=&quot;Java Stream基础操作&quot;&gt;&lt;/a&gt;Java Stream基础操作&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;jdk8之前，操作集合中的元素，一般都是通过for或者iterator去遍历，代码特别冗长。jdk8提供了Stream，让我对更加方便的操作集合&lt;/p&gt;
&lt;h2 id=&quot;Stream构造方式&quot;&gt;&lt;a href=&quot;#Stream构造方式&quot; class=&quot;headerlink&quot; title=&quot;Stream构造方式&quot;&gt;&lt;/a&gt;Stream构造方式&lt;/h2&gt;&lt;h3 id=&quot;stream本身的&quot;&gt;&lt;a href=&quot;#stream本身的&quot; class=&quot;headerlink&quot; title=&quot;stream本身的&quot;&gt;&lt;/a&gt;stream本身的&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static&amp;lt;T&amp;gt; Builder&amp;lt;T&amp;gt; builder();
public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; concat(Stream&amp;lt;? extends T&amp;gt; a, Stream&amp;lt;? extends T&amp;gt; b);
public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; empty();
public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; generate(Supplier&amp;lt;T&amp;gt; s);
public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; iterate(final T seed, final UnaryOperator&amp;lt;T&amp;gt; f);
public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; of(T t);
public static&amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; of(T... values);
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://github/zhuchong6.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>es学习(三)-QueryDSL</title>
    <link href="https://github/zhuchong6.github.io/2020/12/16/2020-12-16es%E6%9F%A5%E8%AF%A2/"/>
    <id>https://github/zhuchong6.github.io/2020/12/16/2020-12-16es%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-12-16T12:08:19.000Z</published>
    <updated>2022-09-29T01:04:32.264Z</updated>
    
    <content type="html"><![CDATA[<pre><code>本文基于官方文档学习：https://www.elastic.co/guide/en/elasticsearch/reference/7.6/query-dsl.html</code></pre><h1 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h1><p>es提供了一套基于json的完整的Query DSL(Domain Specific Language).</p><span id="more"></span><p><strong>叶子查询语句</strong>：</p><p>叶查询子句中寻找一个特定的值在某一特定领域，如 match，term或 range查询。这些查询可以自己使用</p><p><strong>符合查询语句</strong>：</p><p>复合查询子句包装其他叶查询或复合查询，并用于以逻辑方式组合多个查询（例如 bool或dis_max查询），或更改其行为（例如 constant_score查询）</p><p>查询子句的行为会有所不同，具体取决于它们是在 查询上下文中还是在过滤器上下文中使用</p><h2 id="查询和过滤上下文"><a href="#查询和过滤上下文" class="headerlink" title="查询和过滤上下文"></a>查询和过滤上下文</h2><h4 id="相关性分数（-Relevance-scores）"><a href="#相关性分数（-Relevance-scores）" class="headerlink" title="相关性分数（ Relevance scores）"></a>相关性分数（ Relevance scores）</h4><p>默认情况下，es按关联分数对匹配的结果进行排序，这个分数衡量每个文档和查询的匹配度</p><p>相关性分数是一个正浮点数，在search api中<code>_score</code>元字段中返回，<code>_score</code>值越高，文档越相关。尽管不同查询类型可以不同得计算相关性分数，但是相关性分数还是取决于查询子句是在<code>query</code>还是<code>filter</code>上下文中。</p><h4 id="Query-Context"><a href="#Query-Context" class="headerlink" title="Query Context"></a>Query Context</h4><p>在查询上下文中，查询子句回答“此文档与该查询子句得匹配度”的问题，除此之外，查询子句还计算<code>_score</code>元字段中得相关性分数。</p><h4 id="Filter-Context"><a href="#Filter-Context" class="headerlink" title="Filter Context"></a>Filter Context</h4><p>在过滤上下文中，查询子句主要回答“此文档与该查询是否匹配”的问题，不用计算分数，主要用来过滤结构化的数据</p><p>常用过滤器会被es自动缓存，以提高性能</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><pre><code class="console">GET /_search&#123;  &quot;query&quot;: &#123; ------------1    &quot;bool&quot;: &#123; ------------2      &quot;must&quot;: [        &#123; &quot;match&quot;: &#123; &quot;title&quot;:   &quot;Search&quot;        &#125;&#125;,        &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;Elasticsearch&quot; &#125;&#125;      ],      &quot;filter&quot;: [ --------------3        &#123; &quot;term&quot;:  &#123; &quot;status&quot;: &quot;published&quot; &#125;&#125;,        &#123; &quot;range&quot;: &#123; &quot;publish_date&quot;: &#123; &quot;gte&quot;: &quot;2015-01-01&quot; &#125;&#125;&#125;      ]    &#125;  &#125;&#125;</code></pre><ol><li><code>query</code>表示这是一个查询上下文</li><li><code>bool</code>和<code>match</code>在查询上下文中使用，被用来计算每个文档的匹配度，即相关性分数</li><li><code>filter</code>参数表示这个是过滤上下文，<code>term</code>和<code>range</code>用于过滤上下文中，它们过滤出不匹配的文档，并不影响相关性分数</li></ol><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询用来包装其他复合查询或者叶查询，以及组合它们的结果和分数，来改变其行为表现，或者从查询切换到过滤上下文，查询包含以下：</p><h4 id="Bolean-query"><a href="#Bolean-query" class="headerlink" title="Bolean query"></a>Bolean query</h4><p>布尔查询由一个或者多个子句组成，每个子句有特定的类型</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>must</strong></td><td>返回文档<strong>必须</strong>满足<code>must</code>子句的条件，并且参与计算分数</td></tr><tr><td><strong>filter</strong></td><td>返回的文档<strong>必须</strong>满足<code>filter</code>子句的条件,但是不会像<code>must</code>一样，参与计算分值</td></tr><tr><td><strong>should</strong></td><td>返回文档<strong>可能</strong>满足<code>should</code>子句的条件</td></tr><tr><td><strong>must_not</strong></td><td>返回文档不必满足<code>must_not</code>子句的条件，子句在<code>filter context</code>意味着不计分，并且会缓存。由于分数被忽略，所以所有文档的分数都是0</td></tr></tbody></table><p>布尔查询采用<code>more-matches-is-better</code>策略，因此<code>must</code>和<code>should</code>子句的分数会被加起来，为每个文档提供最终的<code>_score</code>值</p><h5 id="使用minimum-should-match"><a href="#使用minimum-should-match" class="headerlink" title="使用minimum_should_match"></a>使用<em>minimum_should_match</em></h5><p>你可以使用minimum_should_match参数指定返回的文档必须匹配的应当子句的数量或百分比</p><p>如果布尔查询中，包含至少一个<code>should</code>子句，并且没有<code>must</code>和<code>filter</code>子句，默认值就是1，否则就是0</p><p>更多信息，请参看：<a href="#%E6%A1%88%E4%BE%8B">minimum_should_match</a></p><h5 id="用bool-filter评分"><a href="#用bool-filter评分" class="headerlink" title="用bool.filter评分"></a>用<code>bool.filter</code>评分</h5><p>在<code>filter</code>查询下面的查询对计算分数没有影响-可以认为返回0分。分数只受指定查询的影响，例如：</p><pre><code class="javascript">GET /_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123;          &quot;status&quot;: &quot;active&quot;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>由于未指定评分查询，第一个查询将所有文档得分设置为0</p><pre><code class="javascript">GET /_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: &#123;        &quot;match_all&quot;: &#123;&#125;      &#125;,      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123;          &quot;status&quot;: &quot;active&quot;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>上面的<code>bool</code>查询具有<code>match_all</code>子句，改查询会为所有文档分配1.0的分数</p><pre><code class="javascript">GET /_search&#123;  &quot;query&quot;: &#123;    &quot;constant_score&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;term&quot;: &#123;          &quot;status&quot;: &quot;active&quot;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p><code>constant_score</code>查询和上面的<code>match_all</code>表现一致，为该过滤器匹配的所有文档分配1.0的分数</p><h4 id="Boosting-query"><a href="#Boosting-query" class="headerlink" title="Boosting query"></a>Boosting query</h4><p>返回匹配<code>positive</code>的文档，同时降低匹配<code>negative</code>的文档的相关性分数</p><p>你可以使用提升查询来降级某些文档，而不必将它们从搜索结果中排除</p><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><pre><code class="javascript">GET /_search&#123;    &quot;query&quot;: &#123;        &quot;boosting&quot; : &#123;            &quot;positive&quot; : &#123;                &quot;term&quot; : &#123;                    &quot;text&quot; : &quot;apple&quot;                &#125;            &#125;,            &quot;negative&quot; : &#123;                 &quot;term&quot; : &#123;                     &quot;text&quot; : &quot;pie tart fruit crumble tree&quot;                &#125;            &#125;,            &quot;negative_boost&quot; : 0.5        &#125;    &#125;&#125;</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><strong>positive</strong></td><td>必需的查询对象）要运行的查询，返回的所有文档都必须与此查询匹配</td></tr><tr><td><strong>negative</strong></td><td>（必需的查询对象）查询用于降低匹配文档的相关性得分,如果返回的文档与肯定查询和该查询匹配，则增强查询将计算文档的最终相关性得分，按照以下步骤:<strong>1.从<code>positive</code>查询中获取原始的相关性分数</strong> <strong>2.将分数乘以<code>negative_boost</code>值</strong></td></tr><tr><td><strong>negative_boost</strong></td><td>（必需，浮点数）0到1.0之间的浮点数，用于降低与否定查询匹配的文档的相关性得分</td></tr></tbody></table><h4 id="Constant-score-query"><a href="#Constant-score-query" class="headerlink" title="Constant score query"></a>Constant score query</h4><p>包装一个<code>filter query</code>,返回相关性分数等于<code>boost</code>的文档</p><pre><code class="javascript">GET /_search&#123;    &quot;query&quot;: &#123;        &quot;constant_score&quot; : &#123;            &quot;filter&quot; : &#123;                &quot;term&quot; : &#123; &quot;user&quot; : &quot;kimchy&quot;&#125;            &#125;,            &quot;boost&quot; : 1.2        &#125;    &#125;&#125;</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><strong>filter</strong></td><td>（必需的查询对象）过滤要运行的查询，返回的所有文档都必须与此查询匹配。过滤查询不计算相关性分数。 为了提高性能，Elasticsearch自动缓存常用的过滤器查询</td></tr><tr><td><strong>boost</strong></td><td>（可选，float）浮点数，用作与过滤器查询匹配的每个文档的恒定相关性得分。 默认为1.0</td></tr></tbody></table><h4 id="Disjunction-max-query"><a href="#Disjunction-max-query" class="headerlink" title="Disjunction max query"></a>Disjunction max query</h4>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;本文基于官方文档学习：
https://www.elastic.co/guide/en/elasticsearch/reference/7.6/query-dsl.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;Query-DSL&quot;&gt;&lt;a href=&quot;#Query-DSL&quot; class=&quot;headerlink&quot; title=&quot;Query DSL&quot;&gt;&lt;/a&gt;Query DSL&lt;/h1&gt;&lt;p&gt;es提供了一套基于json的完整的Query DSL(Domain Specific Language).&lt;/p&gt;</summary>
    
    
    
    <category term="ElasticSearch" scheme="https://github/zhuchong6.github.io/categories/ElasticSearch/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="ElasticSearch" scheme="https://github/zhuchong6.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>es学习(二)-快速开始</title>
    <link href="https://github/zhuchong6.github.io/2020/12/02/2020-12-02es%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>https://github/zhuchong6.github.io/2020/12/02/2020-12-02es%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</id>
    <published>2020-12-02T11:08:20.000Z</published>
    <updated>2022-09-29T01:04:32.260Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="markdown">本文主要记录官方文档学习过程 https://www.elastic.co/guide/en/elasticsearch/reference/7.6/getting-started.html</code></pre><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="运行es"><a href="#运行es" class="headerlink" title="运行es"></a>运行es</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><pre><code class="markdown">由于我使用的win10，所有环境基于windows环境。jdk：java version &quot;1.8.0_211&quot;es版本：7.6.2（这里提供一个下载地址：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.2-windows-x86_64.zip）</code></pre><span id="more"></span><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>安装好jdk，解压好es后，我们就可以启动了</p><ul><li><p>找到es的安装目录下面的bin目录，我这里是：<strong>C:\Users\admin\workspace\Enviroments\es\kibana-7.6.2-windows-x86_64\bin</strong></p></li><li><p>Shift+鼠标右键在bin目录中打开powershell，执行命令：**.\elasticsearch.bat**</p></li></ul><p>这样，我们就启动成功了一个es实例，下面我们可以通过<em>cat</em> API来验证下，有两种方式：</p><ol><li>如果你安装了Kibana，直接在控制台输入：<code>GET /_cat/health?v</code>（推荐这种方式，学习阶段比较方便，后面也是这种方式来实验）</li><li>也可以使用curl命令，打开cmd，执行命令：<code>curl -XGET &quot;http://localhost:9200/_cat/health?v&quot;</code></li></ol><pre><code>warning:注意，上面第二种方式，在powershell中报错，可以改用以下方式：curl -uri &quot;http://localhost:9200/_cat/health?v&quot; -Method &#39;GET&#39;</code></pre><p>结果大概是这样的：</p><p><img src="/res.png" alt="执行结果" title="cat API检测结果"></p><pre><code>上面的启动命令只是单节点启动，多节点得话，可以试试以下命令：.\elasticsearch.bat -E path.data=data2 -E path.logs=log2.\elasticsearch.bat -E path.data=data3 -E path.logs=log3</code></pre><h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><p>在启动好了es后，我们可以为一些数据建立索引。方式如下：</p><pre><code>PUT /customer/_doc/1&#123;  &quot;name&quot;: &quot;zhangshan&quot;&#125;注意：如果，不加id，es会自动生成一个id</code></pre><p>上面请求创建一个名为customer的索引（如果不存在创建），添加一个ID为1的新文档，存储name字段并为其创建索引。执行后，返回结果如下：</p><p><img src="/createDocument.png" alt="创建文档" title="POST结果返回"></p><p>新建后，我们可以查询我们创建的文档：</p><pre><code class="http">GET /customer/_doc/1结果如下:&#123;  &quot;_index&quot; : &quot;customer&quot;,  &quot;_type&quot; : &quot;_doc&quot;,  &quot;_id&quot; : &quot;1&quot;,  &quot;_version&quot; : 1,  &quot;_seq_no&quot; : 0,  &quot;_primary_term&quot; : 1,  &quot;found&quot; : true,  &quot;_source&quot; : &#123;    &quot;name&quot; : &quot;zhangshan&quot;  &#125;&#125;</code></pre><h3 id="批量索引"><a href="#批量索引" class="headerlink" title="批量索引"></a>批量索引</h3><p>当文档数量过大的时候，我们可以通过批量索引的方式来提高插入效率，具体操作如下：</p><ol><li>下载json文件，我们可以使用官网的文件，下载地址如下：<a href="https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json?raw=true">accounts.json</a></li><li>在下载的文件目录下，打开gitbash，执行命令：<code>curl -H &quot;Content-Type: application/json&quot; -XPOST &quot;localhost:9200/mybank/_bulk?pretty&amp;refresh&quot; --data-binary &quot;@accounts.json&quot;</code></li><li>然后在Kibana中执行命令：<code>GET /_cat/indices</code>,可以看到有mybank的文档</li></ol><h2 id="开始查找"><a href="#开始查找" class="headerlink" title="开始查找"></a>开始查找</h2><p>我们完成上面导入数据操作后，就可以试着通过<code>_search</code>端点查询数据。例如：</p><pre><code class="javascript">GET /mybank/_search&#123;  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,  &quot;sort&quot;: [    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;  ]&#125;</code></pre><p>上面的从mybank总索引所有文档，并将其按照account_number升序排序，执行后得到的结果如下：</p><pre><code class="json">&#123;  &quot;took&quot; : 23,  &quot;timed_out&quot; : false,  &quot;_shards&quot; : &#123;    &quot;total&quot; : 1,    &quot;successful&quot; : 1,    &quot;skipped&quot; : 0,    &quot;failed&quot; : 0  &#125;,  &quot;hits&quot; : &#123;    &quot;total&quot; : &#123;      &quot;value&quot; : 1000,      &quot;relation&quot; : &quot;eq&quot;    &#125;,    &quot;max_score&quot; : null,    &quot;hits&quot; : [      &#123;        &quot;_index&quot; : &quot;mybank&quot;,        &quot;_type&quot; : &quot;_doc&quot;,        &quot;_id&quot; : &quot;0&quot;,        &quot;_score&quot; : null,        &quot;_source&quot; : &#123;          &quot;account_number&quot; : 0,          &quot;balance&quot; : 16623,          &quot;firstname&quot; : &quot;Bradshaw&quot;,          &quot;lastname&quot; : &quot;Mckenzie&quot;,          &quot;age&quot; : 29,          &quot;gender&quot; : &quot;F&quot;,          &quot;address&quot; : &quot;244 Columbus Place&quot;,          &quot;employer&quot; : &quot;Euron&quot;,          &quot;email&quot; : &quot;bradshawmckenzie@euron.com&quot;,          &quot;city&quot; : &quot;Hobucken&quot;,          &quot;state&quot; : &quot;CO&quot;        &#125;,        &quot;sort&quot; : [          0        ]      &#125;,...]  &#125;&#125;</code></pre><p>返回信息，相关字段解释：</p><ul><li><code>took</code> - es查询所需的时间，单位是毫秒（milliseconds）</li><li><code>timed_out</code> - 搜索请求是否超时</li><li><code>_shards</code> - 搜索了多少个分片(total)，以及成功(successful)，失败(failed)或跳过(skipped)了多少个分片</li><li><code>max_score</code> - 最相关文件的分数</li><li><code>hits.total.value</code> - 找到多少相关文档</li><li><code>hits.sort</code> - 文档的排序位置（不按相关性得分排序时）</li><li><code>hits._score</code> - 文档的相关性得分（使用match_all时不适用）</li></ul><p>es每次请求相互独立，不会维护相关状态信息，如果要分页搜索，请使用<code>from</code>和<code>size</code>参数，如下：</p><pre><code class="javascript">GET /mybank/_search&#123;  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,  &quot;sort&quot;: [    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;  ],  &quot;from&quot;: 10,  &quot;size&quot;: 10&#125;</code></pre><p>我们现在了解基本的查询结构，可以做一些其他的查询。比如，在字段中搜索特定词，可以用<code>match</code>搜索，查找<code>address</code>中包含<code>mill</code>或者<code>lane</code>的文档，案例如下:</p><pre><code class="javascript">GET /bank/_search&#123;  &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;&#125;</code></pre><p>如果，只想查包含<code>mill lane</code>的文档，可以使用<code>match_phrase</code>查询，如下：</p><pre><code class="javascript">GET /mybank/_search&#123;  &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125; &#125;&#125;</code></pre><p>为了构造更加复杂的查询，需要使用<code>bool</code>查询控制数据范围。可以根据可以根据需要（必须匹配），期望（应该匹配）或不期望（必须不匹配）指定条件，案例如下：</p><pre><code class="javascript">GET /mybank/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;      ],      &quot;must_not&quot;: [        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot;  &#125; &#125;      ]          &#125;  &#125;&#125;</code></pre><p>以上查询的是，包含所有age&#x3D;40，并且state&#x3D;ID的文档。布尔查询中每个<code>should</code> <code>must</code> 和<code>not_must</code>被视为查询子句，<code>must</code>和<code>should</code>的查询会提高文档的相关性分数，分数越高，文档越匹配查询。默认，es返回按这些相关性分数排名的文档。</p><p><code>must_not</code>条件被视为过滤器，它只影响结果是否在文件中，但不会影响文件的评分方式。还可以显式指定任意过滤器以包含或排除文档，如下：</p><pre><code class="javascript">GET /mybank/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,      &quot;filter&quot;: &#123;        &quot;range&quot;: &#123;          &quot;balance&quot;: &#123;            &quot;gte&quot;: 20000,            &quot;lte&quot;: 30000          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>以上请求使用范围过滤器将结果限制为余额在20,000美元到30,000美元（含）之间的帐户</p><h3 id="使用聚合分析结果"><a href="#使用聚合分析结果" class="headerlink" title="使用聚合分析结果"></a>使用聚合分析结果</h3><p>Elasticsearch聚合使您能够获取有关搜索结果的信息，并回答诸如“德克萨斯州有多少个帐户持有人？”之类的问题。 或“田纳西州的平均帐户余额是多少？” 您可以在一个请求中搜索文档，过滤命中并使用汇总分析结果。</p><p>例如，以下请求将银行索引中的所有帐户按状态分组，并以降序返回帐户数量最多的十个州：</p><pre><code class="javascript">GET /mybank/_search&#123;  &quot;size&quot;: 0,  &quot;aggs&quot;: &#123;    &quot;group_by_state&quot;: &#123;      &quot;terms&quot;: &#123;        &quot;field&quot;: &quot;state.keyword&quot;      &#125;    &#125;  &#125;&#125;</code></pre><p>返回结果如下：</p><pre><code class="json">&#123;  &quot;took&quot;: 29,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: &#123;    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot; : 0,    &quot;failed&quot;: 0  &#125;,  &quot;hits&quot; : &#123;     &quot;total&quot; : &#123;        &quot;value&quot;: 1000,        &quot;relation&quot;: &quot;eq&quot;     &#125;,    &quot;max_score&quot; : null,    &quot;hits&quot; : [ ]  &#125;,  &quot;aggregations&quot; : &#123;    &quot;group_by_state&quot; : &#123;      &quot;doc_count_error_upper_bound&quot;: 20,      &quot;sum_other_doc_count&quot;: 770,      &quot;buckets&quot; : [ &#123;        &quot;key&quot; : &quot;ID&quot;,        &quot;doc_count&quot; : 27      &#125;, &#123;        &quot;key&quot; : &quot;TX&quot;,        &quot;doc_count&quot; : 27      &#125;, &#123;        &quot;key&quot; : &quot;AL&quot;,        &quot;doc_count&quot; : 25      &#125;, &#123;        &quot;key&quot; : &quot;MD&quot;,        &quot;doc_count&quot; : 25      &#125;, &#123;        &quot;key&quot; : &quot;TN&quot;,        &quot;doc_count&quot; : 23      &#125;, &#123;        &quot;key&quot; : &quot;MA&quot;,        &quot;doc_count&quot; : 21      &#125;, &#123;        &quot;key&quot; : &quot;NC&quot;,        &quot;doc_count&quot; : 21      &#125;, &#123;        &quot;key&quot; : &quot;ND&quot;,        &quot;doc_count&quot; : 21      &#125;, &#123;        &quot;key&quot; : &quot;ME&quot;,        &quot;doc_count&quot; : 20      &#125;, &#123;        &quot;key&quot; : &quot;MO&quot;,        &quot;doc_count&quot; : 20      &#125; ]    &#125;  &#125;&#125;</code></pre><p>上面<code>buckets</code>存储的是<code>state</code>字段的值，<code>doc_state</code>显示每个state下的值，例如你可以看到有27个账户在state&#x3D;<code>ID</code>条件下。由于<code>size=0</code>，所以查询结果只包含聚合结果。</p><p>总而言之，你可以利用聚合来对每次查询结果进行一个数据聚合分析。</p>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;本文主要记录官方文档学习过程 https://www.elastic.co/guide/en/elasticsearch/reference/7.6/getting-started.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h1&gt;&lt;h2 id=&quot;运行es&quot;&gt;&lt;a href=&quot;#运行es&quot; class=&quot;headerlink&quot; title=&quot;运行es&quot;&gt;&lt;/a&gt;运行es&lt;/h2&gt;&lt;h3 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;由于我使用的win10，所有环境基于windows环境。
jdk：java version &amp;quot;1.8.0_211&amp;quot;
es版本：7.6.2
（这里提供一个下载地址：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.6.2-windows-x86_64.zip）
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="ElasticSearch" scheme="https://github/zhuchong6.github.io/categories/ElasticSearch/"/>
    
    
    <category term="中间件" scheme="https://github/zhuchong6.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="ElasticSearch" scheme="https://github/zhuchong6.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
</feed>
